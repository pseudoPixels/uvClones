
public ToolButton (PaletteListener listener, String iconName, String name, Tool tool) {
    super (listener);
    tool.addToolListener (this);
    setEnabled (tool.isUsable ());
    Iconkit kit = Iconkit.instance ();
    if (kit == null) {
        throw new JHotDrawRuntimeException ("Iconkit instance isn't set");
    }
    Image im [] = new Image [3];
    im [0] = kit.loadImageResource (iconName + "1.gif");
    im [1] = kit.loadImageResource (iconName + "2.gif");
    im [2] = kit.loadImageResource (iconName + "3.gif");
    MediaTracker tracker = new MediaTracker (this);
    for (int i = 0;
    i 

public Tool tool () {
    return myTool;
}


public String name () {
    return getName ();
}


public Object attributeValue () {
    return tool ();
}


public Dimension getMinimumSize () {
    return new Dimension (getPaletteIcon ().getWidth (), getPaletteIcon ().getHeight ());
}


public Dimension getPreferredSize () {
    return new Dimension (getPaletteIcon ().getWidth (), getPaletteIcon ().getHeight ());
}


public Dimension getMaximumSize () {
    return new Dimension (getPaletteIcon ().getWidth (), getPaletteIcon ().getHeight ());
}


public void paintSelected (Graphics g) {
    if (getPaletteIcon ().selected () != null) {
        g.drawImage (getPaletteIcon ().selected (), 0, 0, this);
    }
}


public void paint (Graphics g) {
    if (isSelected ()) {
        paintSelected (g);
    } else {
        super.paint (g);
    }
}


public void toolUsable (EventObject toolEvent) {
    setEnabled (true);
}


public void toolUnusable (EventObject toolEvent) {
    setEnabled (false);
    setSelected (false);
}


public void toolActivated (EventObject toolEvent) {
}


public void toolDeactivated (EventObject toolEvent) {
}


public void toolEnabled (EventObject toolEvent) {
    setEnabled (true);
}


public void toolDisabled (EventObject toolEvent) {
    setEnabled (false);
}


protected PaletteIcon getPaletteIcon () {
    return myIcon;
}


private void setPaletteIcon (PaletteIcon myIcon) {
    this.myIcon = myIcon;
}


private void setTool (Tool myTool) {
    this.myTool = myTool;
}


public void draw (Graphics g, DrawingView view) {
    Dimension d = view.getSize ();
    if ((fOffscreen == null) || (d.width != fImagewidth) || (d.height != fImageheight)) {
        fOffscreen = view.createImage (d.width, d.height);
        fImagewidth = d.width;
        fImageheight = d.height;
    }
    Graphics g2 = fOffscreen.getGraphics ();
    view.drawAll (g2);
    g.drawImage (fOffscreen, 0, 0, view);
}


public GridConstrainer (int x, int y) {
    fGridX = Math.max (1, x);
    fGridY = Math.max (1, y);
}


public Point constrainPoint (Point p) {
    p.x = ((p.x + fGridX / 2) / fGridX) * fGridX;
    p.y = ((p.y + fGridY / 2) / fGridY) * fGridY;
    return p;
}


public int getStepX () {
    return fGridX;
}


public int getStepY () {
    return fGridY;
}


public LocatorHandle (Figure owner, Locator l) {
    super (owner);
    fLocator = l;
}


public Locator getLocator () {
    return fLocator;
}


public Point locate () {
    return fLocator.locate (owner ());
}


public StandardDrawing () {
    super ();
    fListeners = CollectionsFactory.current ().createList (2);
    init (new Rectangle (- 500, - 500, 2000, 2000));
}


public void addDrawingChangeListener (DrawingChangeListener listener) {
    if (fListeners == null) {
        fListeners = CollectionsFactory.current ().createList (2);
    }
    fListeners.add (listener);
}


public void removeDrawingChangeListener (DrawingChangeListener listener) {
    fListeners.remove (listener);
}


public Iterator drawingChangeListeners () {
    return fListeners.iterator ();
}


public synchronized Figure orphan (Figure figure) {
    Figure orphanedFigure = super.orphan (figure);
    if (orphanedFigure.listener () != null) {
        Rectangle rect = invalidateRectangle (displayBox ());
        orphanedFigure.listener ().figureRequestRemove (new FigureChangeEvent (orphanedFigure, rect));
    }
    return orphanedFigure;
}


public synchronized Figure add (Figure figure) {
    Figure addedFigure = super.add (figure);
    if (addedFigure.listener () != null) {
        Rectangle rect = invalidateRectangle (displayBox ());
        addedFigure.listener ().figureRequestUpdate (new FigureChangeEvent (figure, rect));
        return addedFigure;
    }
    return addedFigure;
}


public void figureInvalidated (FigureChangeEvent e) {
    if (fListeners != null) {
        for (int i = 0;
        i 

public void fireDrawingTitleChanged () {
    if (fListeners != null) {
        for (int i = 0;
        i 

public void figureRequestUpdate (FigureChangeEvent e) {
    if (fListeners != null) {
        for (int i = 0;
        i 

public HandleEnumeration handles () {
    List handles = CollectionsFactory.current ().createList ();
    handles.add (new NullHandle (this, RelativeLocator.northWest ()));
    handles.add (new NullHandle (this, RelativeLocator.northEast ()));
    handles.add (new NullHandle (this, RelativeLocator.southWest ()));
    handles.add (new NullHandle (this, RelativeLocator.southEast ()));
    return new HandleEnumerator (handles);
}


public Rectangle displayBox () {
    if (fFigures.size () > 0) {
        FigureEnumeration fe = figures ();
        Rectangle r = fe.nextFigure ().displayBox ();
        while (fe.hasNextFigure ()) {
            r.add (fe.nextFigure ().displayBox ());
        }
        return r;
    }
    return new Rectangle (0, 0, 0, 0);
}


public void basicDisplayBox (Point p1, Point p2) {
}


public synchronized void lock () {
    Thread current = Thread.currentThread ();
    if (fDrawingLockHolder == current) {
        return;
    }
    while (fDrawingLockHolder != null) {
        try {
            wait ();
        } catch (InterruptedException ex) {
        }
    }
    fDrawingLockHolder = current;
}


public synchronized void unlock () {
    if (fDrawingLockHolder != null) {
        fDrawingLockHolder = null;
        notify ();
    }
}


private void readObject (ObjectInputStream s) throws ClassNotFoundException, IOException {
    s.defaultReadObject ();
    fListeners = CollectionsFactory.current ().createList (2);
}


public String getTitle () {
    return myTitle;
}


public void setTitle (String newTitle) {
    myTitle = newTitle;
}


public ChangeConnectionStartHandle (Figure owner) {
    super (owner);
}


protected Connector target () {
    return getConnection ().getStartConnector ();
}


protected void disconnect () {
    getConnection ().disconnectStart ();
}


protected void connect (Connector c) {
    getConnection ().connectStart (c);
}


protected void setPoint (int x, int y) {
    getConnection ().startPoint (x, y);
}


public Point locate () {
    return getConnection ().startPoint ();
}


protected Undoable createUndoActivity (DrawingView newView) {
    return new ChangeConnectionStartHandle.UndoActivity (newView);
}


public UndoActivity (DrawingView newView) {
    super (newView);
}


protected Connector replaceConnector (ConnectionFigure connection) {
    Connector tempStartConnector = connection.getStartConnector ();
    connection.connectStart (getOldConnector ());
    return tempStartConnector;
}


public ToggleGridCommand (String name, DrawingEditor newDrawingEditor, Point grid) {
    super (name, newDrawingEditor);
    fGrid = new Point (grid.x, grid.y);
}


public void execute () {
    super.execute ();
    PointConstrainer grid = view ().getConstrainer ();
    if (grid != null) {
        view ().setConstrainer (null);
    } else {
        view ().setConstrainer (new GridConstrainer (fGrid.x, fGrid.y));
    }
}


public RelativeLocator () {
    fRelativeX = 0.0;
    fRelativeY = 0.0;
}


public boolean equals (Object o) {
    if (RelativeLocator.class.isInstance (o)) {
        RelativeLocator rl = (RelativeLocator) o;
        if ((rl.fRelativeX) == fRelativeX && (rl.fRelativeY == fRelativeY)) {
            return true;
        }
    }
    return false;
}


public RelativeLocator (double relativeX, double relativeY) {
    fRelativeX = relativeX;
    fRelativeY = relativeY;
}


public Point locate (Figure owner) {
    Rectangle r = owner.displayBox ();
    return new Point (r.x + (int) (r.width * fRelativeX), r.y + (int) (r.height * fRelativeY));
}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeDouble (fRelativeX);
    dw.writeDouble (fRelativeY);
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    fRelativeX = dr.readDouble ();
    fRelativeY = dr.readDouble ();
}


static public Locator east () {
    return new RelativeLocator (1.0, 0.5);
}


static public Locator north () {
    return new RelativeLocator (0.5, 0.0);
}


static public Locator west () {
    return new RelativeLocator (0.0, 0.5);
}


static public Locator northEast () {
    return new RelativeLocator (1.0, 0.0);
}


static public Locator northWest () {
    return new RelativeLocator (0.0, 0.0);
}


static public Locator south () {
    return new RelativeLocator (0.5, 1.0);
}


static public Locator southEast () {
    return new RelativeLocator (1.0, 1.0);
}


static public Locator southWest () {
    return new RelativeLocator (0.0, 1.0);
}


static public Locator center () {
    return new RelativeLocator (0.5, 0.5);
}


public BringToFrontCommand (String name, DrawingEditor newDrawingEditor) {
    super (name, newDrawingEditor);
}


public void execute () {
    super.execute ();
    setUndoActivity (createUndoActivity ());
    getUndoActivity ().setAffectedFigures (view ().selection ());
    FigureEnumeration fe = getUndoActivity ().getAffectedFigures ();
    while (fe.hasNextFigure ()) {
        view ().drawing ().bringToFront (fe.nextFigure ());
    }
    view ().checkDamage ();
}


public boolean isExecutableWithView () {
    return view ().selectionCount () > 0;
}


protected Undoable createUndoActivity () {
    return new BringToFrontCommand.UndoActivity (view ());
}


public UndoActivity (DrawingView newDrawingView) {
    super (newDrawingView);
}


protected void sendToCommand (Figure f) {
    getDrawingView ().drawing ().bringToFront (f);
}


public AbstractHandle (Figure owner) {
    fOwner = owner;
}


public void invokeStart (int x, int y, Drawing drawing) {
}


public void invokeStart (int x, int y, DrawingView view) {
    invokeStart (x, y, view.drawing ());
}


public void invokeStep (int dx, int dy, Drawing drawing) {
}


public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
    invokeStep (x - anchorX, y - anchorY, view.drawing ());
}


public void invokeEnd (int x, int y, int anchorX, int anchorY, DrawingView view) {
    invokeEnd (x - anchorX, y - anchorY, view.drawing ());
}


public void invokeEnd (int dx, int dy, Drawing drawing) {
}


public Figure owner () {
    return fOwner;
}


public Rectangle displayBox () {
    Point p = locate ();
    return new Rectangle (p.x - HANDLESIZE / 2, p.y - HANDLESIZE / 2, HANDLESIZE, HANDLESIZE);
}


public boolean containsPoint (int x, int y) {
    return displayBox ().contains (x, y);
}


public void draw (Graphics g) {
    Rectangle r = displayBox ();
    g.setColor (Color.white);
    g.fillRect (r.x, r.y, r.width, r.height);
    g.setColor (Color.black);
    g.drawRect (r.x, r.y, r.width, r.height);
}


public Undoable getUndoActivity () {
    return myUndoableActivity;
}


public void setUndoActivity (Undoable newUndoableActivity) {
    myUndoableActivity = newUndoableActivity;
}


public CopyCommand (String name, DrawingEditor newDrawingEditor) {
    super (name, newDrawingEditor);
}


public void execute () {
    super.execute ();
    copyFigures (view ().selection (), view ().selectionCount ());
}


protected boolean isExecutableWithView () {
    return view ().selectionCount () > 0;
}


public FigureEnumerator (Collection c) {
    myInitialCollection = c;
    reset ();
}


public boolean hasNextFigure () {
    return myIterator.hasNext ();
}


public Figure nextFigure () {
    return (Figure) myIterator.next ();
}


public static FigureEnumeration getEmptyEnumeration () {
    return singletonEmptyEnumerator;
}


public void reset () {
    myIterator = myInitialCollection.iterator ();
}


public void figureInvalidated (FigureChangeEvent e) {
}


public void figureChanged (FigureChangeEvent e) {
}


public void figureRemoved (FigureChangeEvent e) {
}


public void figureRequestRemove (FigureChangeEvent e) {
}


public void figureRequestUpdate (FigureChangeEvent e) {
}


public HandleAndEnumerator (HandleEnumeration newHE1, HandleEnumeration newHE2) {
    myHE1 = newHE1;
    myHE2 = newHE2;
}


public Handle nextHandle () {
    if (myHE1.hasNextHandle ()) {
        return myHE1.nextHandle ();
    } else if (myHE2.hasNextHandle ()) {
        return myHE2.nextHandle ();
    } else {
        return null;
    }

}


public boolean hasNextHandle () {
    return myHE1.hasNextHandle () || myHE2.hasNextHandle ();
}


public List toList () {
    List joinedList = myHE1.toList ();
    joinedList.addAll (myHE2.toList ());
    return joinedList;
}


public void reset () {
    myHE1.reset ();
    myHE2.reset ();
}


public AbstractConnector () {
    fOwner = null;
}


public AbstractConnector (Figure owner) {
    fOwner = owner;
}


public Figure owner () {
    return fOwner;
}


public Point findStart (ConnectionFigure connection) {
    return findPoint (connection);
}


public Point findEnd (ConnectionFigure connection) {
    return findPoint (connection);
}


protected Point findPoint (ConnectionFigure connection) {
    return Geom.center (displayBox ());
}


public Rectangle displayBox () {
    return owner ().displayBox ();
}


public boolean containsPoint (int x, int y) {
    return owner ().containsPoint (x, y);
}


public void draw (Graphics g) {
}


public void write (StorableOutput dw) {
    dw.writeStorable (owner ());
}


public void read (StorableInput dr) throws IOException {
    fOwner = (Figure) dr.readStorable ();
}


public void connectorVisibility (boolean isVisible, ConnectionFigure courtingConnection) {
}


public ConnectionHandle (Figure owner, Locator l, ConnectionFigure prototype) {
    super (owner, l);
    fPrototype = prototype;
}


public void invokeStart (int x, int y, DrawingView view) {
    setConnection (createConnection ());
    Point p = locate ();
    getConnection ().startPoint (p.x, p.y);
    getConnection ().endPoint (p.x, p.y);
    view.drawing ().add (getConnection ());
}


public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
    Point p = new Point (x, y);
    Figure f = findConnectableFigure (x, y, view.drawing ());
    if (f != getTargetFigure ()) {
        if (getTargetFigure () != null) {
            getTargetFigure ().connectorVisibility (false, null);
        }
        setTargetFigure (f);
        if (getTargetFigure () != null) {
            getTargetFigure ().connectorVisibility (true, getConnection ());
        }
    }
    Connector target = findConnectionTarget (p.x, p.y, view.drawing ());
    if (target != null) {
        p = Geom.center (target.displayBox ());
    }
    getConnection ().endPoint (p.x, p.y);
}


public void invokeEnd (int x, int y, int anchorX, int anchorY, DrawingView view) {
    Connector target = findConnectionTarget (x, y, view.drawing ());
    if (target != null) {
        getConnection ().connectStart (startConnector ());
        getConnection ().connectEnd (target);
        getConnection ().updateConnection ();
    } else {
        view.drawing ().remove (getConnection ());
    }
    setConnection (null);
    if (getTargetFigure () != null) {
        getTargetFigure ().connectorVisibility (false, null);
        setTargetFigure (null);
    }
}


private Connector startConnector () {
    Point p = locate ();
    return owner ().connectorAt (p.x, p.y);
}


protected ConnectionFigure createConnection () {
    return (ConnectionFigure) fPrototype.clone ();
}


protected Connector findConnectionTarget (int x, int y, Drawing drawing) {
    Figure target = findConnectableFigure (x, y, drawing);
    if ((target != null) && target.canConnect () && ! target.includes (owner ()) && getConnection ().canConnect (owner (), target)) {
        return findConnector (x, y, target);
    }
    return null;
}


private Figure findConnectableFigure (int x, int y, Drawing drawing) {
    FigureEnumeration fe = drawing.figuresReverse ();
    while (fe.hasNextFigure ()) {
        Figure figure = fe.nextFigure ();
        if (! figure.includes (getConnection ()) && figure.canConnect () && figure.containsPoint (x, y)) {
            return figure;
        }
    }
    return null;
}


protected Connector findConnector (int x, int y, Figure f) {
    return f.connectorAt (x, y);
}


public void draw (Graphics g) {
    Rectangle r = displayBox ();
    g.setColor (Color.blue);
    g.drawOval (r.x, r.y, r.width, r.height);
}


protected void setConnection (ConnectionFigure newConnection) {
    myConnection = newConnection;
}


protected ConnectionFigure getConnection () {
    return myConnection;
}


protected Figure getTargetFigure () {
    return myTargetFigure;
}


protected void setTargetFigure (Figure newTargetFigure) {
    myTargetFigure = newTargetFigure;
}


public ChangeConnectionEndHandle (Figure owner) {
    super (owner);
}


protected Connector target () {
    return getConnection ().getEndConnector ();
}


protected void disconnect () {
    getConnection ().disconnectEnd ();
}


protected void connect (Connector c) {
    getConnection ().connectEnd (c);
}


protected void setPoint (int x, int y) {
    getConnection ().endPoint (x, y);
}


public Point locate () {
    return getConnection ().endPoint ();
}


protected Undoable createUndoActivity (DrawingView newView) {
    return new ChangeConnectionEndHandle.UndoActivity (newView);
}


public UndoActivity (DrawingView newView) {
    super (newView);
}


protected Connector replaceConnector (ConnectionFigure connection) {
    Connector tempEndConnector = connection.getEndConnector ();
    connection.connectEnd (getOldConnector ());
    return tempEndConnector;
}


public QuadTree (Rectangle2D absoluteBoundingRectangle2D) {
    this (2, absoluteBoundingRectangle2D);
}


public QuadTree (int nMaxTreeDepth, Rectangle2D absoluteBoundingRectangle2D) {
    _init (nMaxTreeDepth, absoluteBoundingRectangle2D);
}


public void add (Object anObject, Rectangle2D absoluteBoundingRectangle2D) {
    if (_nMaxTreeDepth == 1) {
        if (absoluteBoundingRectangle2D.intersects (_absoluteBoundingRectangle2D)) {
            _theHashtable.put (anObject, absoluteBoundingRectangle2D);
        } else {
            _outsideHashtable.put (anObject, absoluteBoundingRectangle2D);
        }
        return;
    }
    boolean bNW = absoluteBoundingRectangle2D.intersects (_nwQuadTree.getAbsoluteBoundingRectangle2D ());
    boolean bNE = absoluteBoundingRectangle2D.intersects (_neQuadTree.getAbsoluteBoundingRectangle2D ());
    boolean bSW = absoluteBoundingRectangle2D.intersects (_swQuadTree.getAbsoluteBoundingRectangle2D ());
    boolean bSE = absoluteBoundingRectangle2D.intersects (_seQuadTree.getAbsoluteBoundingRectangle2D ());
    int nCount = 0;
    if (bNW == true) {
        nCount ++;
    }
    if (bNE == true) {
        nCount ++;
    }
    if (bSW == true) {
        nCount ++;
    }
    if (bSE == true) {
        nCount ++;
    }
    if (nCount > 1) {
        _theHashtable.put (anObject, absoluteBoundingRectangle2D);
        return;
    }
    if (nCount == 0) {
        _outsideHashtable.put (anObject, absoluteBoundingRectangle2D);
        return;
    }
    if (bNW == true) {
        _nwQuadTree.add (anObject, absoluteBoundingRectangle2D);
    }
    if (bNE == true) {
        _neQuadTree.add (anObject, absoluteBoundingRectangle2D);
    }
    if (bSW == true) {
        _swQuadTree.add (anObject, absoluteBoundingRectangle2D);
    }
    if (bSE == true) {
        _seQuadTree.add (anObject, absoluteBoundingRectangle2D);
    }
}


public Object remove (Object anObject) {
    Object returnObject = _theHashtable.remove (anObject);
    if (returnObject != null) {
        return returnObject;
    }
    if (_nMaxTreeDepth > 1) {
        returnObject = _nwQuadTree.remove (anObject);
        if (returnObject != null) {
            return returnObject;
        }
        returnObject = _neQuadTree.remove (anObject);
        if (returnObject != null) {
            return returnObject;
        }
        returnObject = _swQuadTree.remove (anObject);
        if (returnObject != null) {
            return returnObject;
        }
        returnObject = _seQuadTree.remove (anObject);
        if (returnObject != null) {
            return returnObject;
        }
    }
    returnObject = _outsideHashtable.remove (anObject);
    if (returnObject != null) {
        return returnObject;
    }
    return null;
}


public void clear () {
    _theHashtable.clear ();
    _outsideHashtable.clear ();
    if (_nMaxTreeDepth > 1) {
        _nwQuadTree.clear ();
        _neQuadTree.clear ();
        _swQuadTree.clear ();
        _seQuadTree.clear ();
    }
}


public int getMaxTreeDepth () {
    return _nMaxTreeDepth;
}


public FigureEnumeration getAllWithin (Rectangle2D r) {
    List l = CollectionsFactory.current ().createList ();
    for (Iterator ii = _outsideHashtable.keySet ().iterator ();
    ii.hasNext ();) {
        Object anObject = ii.next ();
        Rectangle2D itsAbsoluteBoundingRectangle2D = (Rectangle2D) _outsideHashtable.get (anObject);
        if (itsAbsoluteBoundingRectangle2D.intersects (r)) {
            l.add (anObject);
        }
    }
    if (_absoluteBoundingRectangle2D.intersects (r)) {
        for (Iterator i = _theHashtable.keySet ().iterator ();
        i.hasNext ();) {
            Object anObject = i.next ();
            Rectangle2D itsAbsoluteBoundingRectangle2D = (Rectangle2D) _theHashtable.get (anObject);
            if (itsAbsoluteBoundingRectangle2D.intersects (r)) {
                l.add (anObject);
            }
        }
        if (_nMaxTreeDepth > 1) {
            l.add (_nwQuadTree.getAllWithin (r));
            l.add (_neQuadTree.getAllWithin (r));
            l.add (_swQuadTree.getAllWithin (r));
            l.add (_seQuadTree.getAllWithin (r));
        }
    }
    return new FigureEnumerator (l);
}


public Rectangle2D getAbsoluteBoundingRectangle2D () {
    return _absoluteBoundingRectangle2D;
}


private void _init (int nMaxTreeDepth, Rectangle2D absoluteBoundingRectangle2D) {
    _absoluteBoundingRectangle2D.setRect (absoluteBoundingRectangle2D);
    _nMaxTreeDepth = nMaxTreeDepth;
    if (_nMaxTreeDepth > 1) {
        _nwQuadTree = new QuadTree (_nMaxTreeDepth - 1, _makeNorthwest (absoluteBoundingRectangle2D));
        _neQuadTree = new QuadTree (_nMaxTreeDepth - 1, _makeNortheast (absoluteBoundingRectangle2D));
        _swQuadTree = new QuadTree (_nMaxTreeDepth - 1, _makeSouthwest (absoluteBoundingRectangle2D));
        _seQuadTree = new QuadTree (_nMaxTreeDepth - 1, _makeSoutheast (absoluteBoundingRectangle2D));
    }
}


private Rectangle2D _makeNorthwest (Rectangle2D r) {
    return new Rectangle2D.Double (r.getX (), r.getY (), r.getWidth () / 2.0, r.getHeight () / 2.0);
}


private Rectangle2D _makeNortheast (Rectangle2D r) {
    return new Rectangle2D.Double (r.getX () + r.getWidth () / 2.0, r.getY (), r.getWidth () / 2.0, r.getHeight () / 2.0);
}


private Rectangle2D _makeSouthwest (Rectangle2D r) {
    return new Rectangle2D.Double (r.getX (), r.getY () + r.getHeight () / 2.0, r.getWidth () / 2.0, r.getHeight () / 2.0);
}


private Rectangle2D _makeSoutheast (Rectangle2D r) {
    return new Rectangle2D.Double (r.getX () + r.getWidth () / 2.0, r.getY () + r.getHeight () / 2.0, r.getWidth () / 2.0, r.getHeight () / 2.0);
}


public ChangeAttributeCommand (String name, FigureAttributeConstant attribute, Object value, DrawingEditor newDrawingEditor) {
    super (name, newDrawingEditor);
    fAttribute = attribute;
    fValue = value;
}


public void execute () {
    super.execute ();
    setUndoActivity (createUndoActivity ());
    getUndoActivity ().setAffectedFigures (view ().selection ());
    FigureEnumeration fe = getUndoActivity ().getAffectedFigures ();
    while (fe.hasNextFigure ()) {
        fe.nextFigure ().setAttribute (fAttribute, fValue);
    }
    view ().checkDamage ();
}


public boolean isExecutableWithView () {
    return view ().selectionCount () > 0;
}


protected Undoable createUndoActivity () {
    return new ChangeAttributeCommand.UndoActivity (view (), fAttribute, fValue);
}


public UndoActivity (DrawingView newDrawingView, FigureAttributeConstant newUndoAttribute, Object newUndoValue) {
    super (newDrawingView);
    myOriginalValues = new Hashtable ();
    setAttribute (newUndoAttribute);
    setBackupValue (newUndoValue);
    setUndoable (true);
    setRedoable (true);
}


public boolean undo () {
    if (! super.undo ()) {
        return false;
    }
    FigureEnumeration fe = getAffectedFigures ();
    while (fe.hasNextFigure ()) {
        Figure f = fe.nextFigure ();
        if (getOriginalValue (f) != null) {
            f.setAttribute (getAttribute (), getOriginalValue (f));
        }
    }
    return true;
}


public boolean redo () {
    if (! isRedoable ()) {
        return false;
    }
    FigureEnumeration fe = getAffectedFigures ();
    while (fe.hasNextFigure ()) {
        Figure f = fe.nextFigure ();
        if (getBackupValue () != null) {
            f.setAttribute (getAttribute (), getBackupValue ());
        }
    }
    return true;
}


protected void addOriginalValue (Figure affectedFigure, Object newOriginalValue) {
    myOriginalValues.put (affectedFigure, newOriginalValue);
}


protected Object getOriginalValue (Figure lookupAffectedFigure) {
    return myOriginalValues.get (lookupAffectedFigure);
}


protected void setAttribute (FigureAttributeConstant newUndoAttribute) {
    myUndoAttribute = newUndoAttribute;
}


public FigureAttributeConstant getAttribute () {
    return myUndoAttribute;
}


protected void setBackupValue (Object newUndoValue) {
    myUndoValue = newUndoValue;
}


public Object getBackupValue () {
    return myUndoValue;
}


public void release () {
    super.release ();
    myOriginalValues = null;
}


public void setAffectedFigures (FigureEnumeration fe) {
    super.setAffectedFigures (fe);
    FigureEnumeration copyFe = getAffectedFigures ();
    while (copyFe.hasNextFigure ()) {
        Figure f = copyFe.nextFigure ();
        Object attributeValue = f.getAttribute (getAttribute ());
        if (attributeValue != null) {
            addOriginalValue (f, attributeValue);
        }
    }
}


public CutCommand (String name, DrawingEditor newDrawingEditor) {
    super (name, newDrawingEditor);
}


public void execute () {
    super.execute ();
    setUndoActivity (createUndoActivity ());
    getUndoActivity ().setAffectedFigures (view ().selection ());
    copyFigures (getUndoActivity ().getAffectedFigures (), view ().selectionCount ());
    deleteFigures (getUndoActivity ().getAffectedFigures ());
    view ().checkDamage ();
}


public boolean isExecutableWithView () {
    return view ().selectionCount () > 0;
}


protected Undoable createUndoActivity () {
    return new CutCommand.UndoActivity (this);
}


public UndoActivity (FigureTransferCommand newCommand) {
    super (newCommand.view ());
    myCommand = newCommand;
    setUndoable (true);
    setRedoable (true);
}


public boolean undo () {
    if (super.undo () && getAffectedFigures ().hasNextFigure ()) {
        getDrawingView ().clearSelection ();
        setAffectedFigures (myCommand.insertFigures (getAffectedFigures (), 0, 0));
        return true;
    }
    return false;
}


public boolean redo () {
    if (isRedoable ()) {
        myCommand.copyFigures (getAffectedFigures (), getDrawingView ().selectionCount ());
        myCommand.deleteFigures (getAffectedFigures ());
        return true;
    }
    return false;
}


public NullTool (DrawingEditor newDrawingEditor) {
    super (newDrawingEditor);
}


public void activate () {
}


public void deactivate () {
}


protected void checkUsable () {
}


public StandardDrawingView (DrawingEditor editor) {
    this (editor, MINIMUM_WIDTH, MINIMUM_HEIGHT);
}


public StandardDrawingView (DrawingEditor editor, int width, int height) {
    setAutoscrolls (true);
    counter ++;
    fEditor = editor;
    fViewSize = new Dimension (width, height);
    setSize (width, height);
    fSelectionListeners = CollectionsFactory.current ().createList ();
    addFigureSelectionListener (editor ());
    setLastClick (new Point (0, 0));
    fConstrainer = null;
    fSelection = CollectionsFactory.current ().createList ();
    setDisplayUpdate (createDisplayUpdate ());
    setBackground (Color.lightGray);
    addMouseListener (createMouseListener ());
    addMouseMotionListener (createMouseMotionListener ());
    addKeyListener (createKeyListener ());
}


protected MouseListener createMouseListener () {
    return new DrawingViewMouseListener ();
}


protected MouseMotionListener createMouseMotionListener () {
    return new DrawingViewMouseMotionListener ();
}


protected KeyListener createKeyListener () {
    return new DrawingViewKeyListener ();
}


protected Painter createDisplayUpdate () {
    return new SimpleUpdateStrategy ();
}


public void setEditor (DrawingEditor editor) {
    fEditor = editor;
}


public Tool tool () {
    return editor ().tool ();
}


public Drawing drawing () {
    return fDrawing;
}


public void setDrawing (Drawing d) {
    if (drawing () != null) {
        clearSelection ();
        drawing ().removeDrawingChangeListener (this);
    }
    fDrawing = d;
    if (drawing () != null) {
        drawing ().addDrawingChangeListener (this);
    }
    checkMinimumSize ();
    repaint ();
}


public DrawingEditor editor () {
    return fEditor;
}


public Figure add (Figure figure) {
    return drawing ().add (figure);
}


public Figure remove (Figure figure) {
    return drawing ().remove (figure);
}


public void addAll (Collection figures) {
    FigureEnumeration fe = new FigureEnumerator (figures);
    while (fe.hasNextFigure ()) {
        add (fe.nextFigure ());
    }
}


public boolean figureExists (Figure inf, FigureEnumeration fe) {
    while (fe.hasNextFigure ()) {
        Figure figure = fe.nextFigure ();
        if (figure.includes (inf)) {
            return true;
        }
    }
    return false;
}


public FigureEnumeration insertFigures (FigureEnumeration fe, int dx, int dy, boolean bCheck) {
    if (fe == null) {
        return FigureEnumerator.getEmptyEnumeration ();
    }
    List vCF = CollectionsFactory.current ().createList (10);
    InsertIntoDrawingVisitor visitor = new InsertIntoDrawingVisitor (drawing ());
    while (fe.hasNextFigure ()) {
        Figure figure = fe.nextFigure ();
        if (figure instanceof ConnectionFigure) {
            vCF.add (figure);
        } else if (figure != null) {
            figure.moveBy (dx, dy);
            figure.visit (visitor);
        }

    }
    FigureEnumeration ecf = new FigureEnumerator (vCF);
    while (ecf.hasNextFigure ()) {
        ConnectionFigure cf = (ConnectionFigure) ecf.nextFigure ();
        Figure sf = cf.startFigure ();
        Figure ef = cf.endFigure ();
        if (figureExists (sf, drawing ().figures ()) && figureExists (ef, drawing ().figures ()) && (! bCheck || cf.canConnect (sf, ef))) {
            if (bCheck) {
                Point sp = sf.center ();
                Point ep = ef.center ();
                Connector fStartConnector = cf.startFigure ().connectorAt (ep.x, ep.y);
                Connector fEndConnector = cf.endFigure ().connectorAt (sp.x, sp.y);
                if (fEndConnector != null && fStartConnector != null) {
                    cf.connectStart (fStartConnector);
                    cf.connectEnd (fEndConnector);
                    cf.updateConnection ();
                }
            }
            cf.visit (visitor);
        }
    }
    addToSelectionAll (visitor.getInsertedFigures ());
    return visitor.getInsertedFigures ();
}


public FigureEnumeration getConnectionFigures (Figure inFigure) {
    if (inFigure == null || ! inFigure.canConnect ()) {
        return null;
    }
    List result = CollectionsFactory.current ().createList (5);
    FigureEnumeration figures = drawing ().figures ();
    while (figures.hasNextFigure ()) {
        Figure f = figures.nextFigure ();
        if ((f instanceof ConnectionFigure) && ! (isFigureSelected (f))) {
            ConnectionFigure cf = (ConnectionFigure) f;
            if (cf.startFigure ().includes (inFigure) || cf.endFigure ().includes (inFigure)) {
                result.add (f);
            }
        }
    }
    return new FigureEnumerator (result);
}


public Dimension getMinimumSize () {
    return fViewSize;
}


public Dimension getPreferredSize () {
    return getMinimumSize ();
}


public void setDisplayUpdate (Painter updateStrategy) {
    fUpdateStrategy = updateStrategy;
}


public Painter getDisplayUpdate () {
    return fUpdateStrategy;
}


public FigureEnumeration selection () {
    return selectionZOrdered ();
}


public FigureEnumeration selectionZOrdered () {
    List result = CollectionsFactory.current ().createList (selectionCount ());
    FigureEnumeration figures = drawing ().figures ();
    while (figures.hasNextFigure ()) {
        Figure f = figures.nextFigure ();
        if (isFigureSelected (f)) {
            result.add (f);
        }
    }
    return new ReverseFigureEnumerator (result);
}


public int selectionCount () {
    return fSelection.size ();
}


public boolean isFigureSelected (Figure checkFigure) {
    return fSelection.contains (checkFigure);
}


public void addToSelection (Figure figure) {
    if (! isFigureSelected (figure) && drawing ().includes (figure)) {
        fSelection.add (figure);
        fSelectionHandles = null;
        figure.invalidate ();
        fireSelectionChanged ();
    }
}


public void addToSelectionAll (Collection figures) {
    addToSelectionAll (new FigureEnumerator (figures));
}


public void addToSelectionAll (FigureEnumeration fe) {
    while (fe.hasNextFigure ()) {
        addToSelection (fe.nextFigure ());
    }
}


public void removeFromSelection (Figure figure) {
    if (isFigureSelected (figure)) {
        fSelection.remove (figure);
        fSelectionHandles = null;
        figure.invalidate ();
        fireSelectionChanged ();
    }
}


public void toggleSelection (Figure figure) {
    if (isFigureSelected (figure)) {
        removeFromSelection (figure);
    } else {
        addToSelection (figure);
    }
    fireSelectionChanged ();
}


public void clearSelection () {
    if (selectionCount () == 0) {
        return;
    }
    FigureEnumeration fe = selection ();
    while (fe.hasNextFigure ()) {
        fe.nextFigure ().invalidate ();
    }
    fSelection = CollectionsFactory.current ().createList ();
    fSelectionHandles = null;
    fireSelectionChanged ();
}


protected HandleEnumeration selectionHandles () {
    if (fSelectionHandles == null) {
        fSelectionHandles = CollectionsFactory.current ().createList ();
        FigureEnumeration fe = selection ();
        while (fe.hasNextFigure ()) {
            Figure figure = fe.nextFigure ();
            HandleEnumeration kk = figure.handles ();
            while (kk.hasNextHandle ()) {
                fSelectionHandles.add (kk.nextHandle ());
            }
        }
    }
    return new HandleEnumerator (fSelectionHandles);
}


public FigureSelection getFigureSelection () {
    return new StandardFigureSelection (selectionZOrdered (), selectionCount ());
}


public Handle findHandle (int x, int y) {
    Handle handle;
    HandleEnumeration he = selectionHandles ();
    while (he.hasNextHandle ()) {
        handle = he.nextHandle ();
        if (handle.containsPoint (x, y)) {
            return handle;
        }
    }
    return null;
}


protected void fireSelectionChanged () {
    if (fSelectionListeners != null) {
        for (int i = 0;
        i 

protected Rectangle getDamage () {
    return fDamage;
}


protected void setDamage (Rectangle r) {
    fDamage = r;
}


public Point lastClick () {
    return fLastClick;
}


protected void setLastClick (Point newLastClick) {
    fLastClick = newLastClick;
}


public void setConstrainer (PointConstrainer c) {
    fConstrainer = c;
}


public PointConstrainer getConstrainer () {
    return fConstrainer;
}


protected Point constrainPoint (Point p) {
    Dimension size = getSize ();
    p.x = Geom.range (1, size.width, p.x);
    p.y = Geom.range (1, size.height, p.y);
    if (fConstrainer != null) {
        return fConstrainer.constrainPoint (p);
    }
    return p;
}


private void moveSelection (int dx, int dy) {
    FigureEnumeration figures = selection ();
    while (figures.hasNextFigure ()) {
        figures.nextFigure ().moveBy (dx, dy);
    }
    checkDamage ();
}


public synchronized void checkDamage () {
    Iterator each = drawing ().drawingChangeListeners ();
    while (each.hasNext ()) {
        Object l = each.next ();
        if (l instanceof DrawingView) {
            ((DrawingView) l).repairDamage ();
        }
    }
}


public void repairDamage () {
    if (getDamage () != null) {
        repaint (getDamage ().x, getDamage ().y, getDamage ().width, getDamage ().height);
        setDamage (null);
    }
}


public void drawingInvalidated (DrawingChangeEvent e) {
    Rectangle r = e.getInvalidatedRectangle ();
    if (getDamage () == null) {
        setDamage (r);
    } else {
        Rectangle damagedR = getDamage ();
        damagedR.add (r);
        setDamage (damagedR);
    }
}


public void drawingRequestUpdate (DrawingChangeEvent e) {
    repairDamage ();
}


public void drawingTitleChanged (DrawingChangeEvent e) {
}


protected void paintComponent (Graphics g) {
    getDisplayUpdate ().draw (g, this);
}


public void drawAll (Graphics g) {
    boolean isPrinting = g instanceof PrintGraphics;
    drawBackground (g);
    if ((fBackgrounds != null) && ! isPrinting) {
        drawPainters (g, fBackgrounds);
    }
    drawDrawing (g);
    if ((fForegrounds != null) && ! isPrinting) {
        drawPainters (g, fForegrounds);
    }
    if (! isPrinting) {
        drawHandles (g);
    }
}


public void draw (Graphics g, FigureEnumeration fe) {
    boolean isPrinting = g instanceof PrintGraphics;
    if ((fBackgrounds != null) && ! isPrinting) {
        drawPainters (g, fBackgrounds);
    }
    drawing ().draw (g, fe);
    if ((fForegrounds != null) && ! isPrinting) {
        drawPainters (g, fForegrounds);
    }
    if (! isPrinting) {
        drawHandles (g);
    }
}


public void drawHandles (Graphics g) {
    HandleEnumeration he = selectionHandles ();
    while (he.hasNextHandle ()) {
        (he.nextHandle ()).draw (g);
    }
}


public void drawDrawing (Graphics g) {
    drawing ().draw (g);
}


public void drawBackground (Graphics g) {
    g.setColor (getBackground ());
    g.fillRect (0, 0, getBounds ().width, getBounds ().height);
}


protected void drawPainters (Graphics g, List v) {
    for (int i = 0;
    i 

public void addBackground (Painter painter) {
    if (fBackgrounds == null) {
        fBackgrounds = CollectionsFactory.current ().createList (3);
    }
    fBackgrounds.add (painter);
    repaint ();
}


public void removeBackground (Painter painter) {
    if (fBackgrounds != null) {
        fBackgrounds.remove (painter);
    }
    repaint ();
}


protected List getBackgrounds () {
    return fBackgrounds;
}


public void removeForeground (Painter painter) {
    if (fForegrounds != null) {
        fForegrounds.remove (painter);
    }
    repaint ();
}


public void addForeground (Painter painter) {
    if (fForegrounds == null) {
        fForegrounds = CollectionsFactory.current ().createList (3);
    }
    fForegrounds.add (painter);
    repaint ();
}


protected List getForegrounds () {
    return fForegrounds;
}


public void freezeView () {
    drawing ().lock ();
}


public void unfreezeView () {
    drawing ().unlock ();
}


private void readObject (ObjectInputStream s) throws ClassNotFoundException, IOException {
    s.defaultReadObject ();
    fSelection = CollectionsFactory.current ().createList ();
    if (drawing () != null) {
        drawing ().addDrawingChangeListener (this);
    }
    fSelectionListeners = CollectionsFactory.current ().createList ();
}


protected void checkMinimumSize () {
    Dimension d = getDrawingSize ();
    if (fViewSize.height 

protected Dimension getDrawingSize () {
    FigureEnumeration fe = drawing ().figures ();
    Dimension d = new Dimension (0, 0);
    while (fe.hasNextFigure ()) {
        Rectangle r = fe.nextFigure ().displayBox ();
        d.width = Math.max (d.width, r.x + r.width);
        d.height = Math.max (d.height, r.y + r.height);
    }
    return d;
}


public boolean isFocusTraversable () {
    return true;
}


public boolean isInteractive () {
    return true;
}


public void keyTyped (KeyEvent e) {
}


public void keyReleased (KeyEvent e) {
}


public void addFigureSelectionListener (FigureSelectionListener fsl) {
    fSelectionListeners.add (fsl);
}


public void removeFigureSelectionListener (FigureSelectionListener fsl) {
    fSelectionListeners.remove (fsl);
}


public int getDefaultDNDActions () {
    return java.awt.dnd.DnDConstants.ACTION_COPY_OR_MOVE;
}


public void autoscroll (java.awt.Point p) {
    ash.autoscroll (p);
}


public Insets getAutoscrollInsets () {
    return ash.getAutoscrollInsets ();
}


public ASH (int margin) {
    super (margin);
}


public Dimension getSize () {
    return StandardDrawingView.this.getSize ();
}


public Rectangle getVisibleRect () {
    return StandardDrawingView.this.getVisibleRect ();
}


public void scrollRectToVisible (Rectangle aRect) {
    StandardDrawingView.this.scrollRectToVisible (aRect);
}


public String toString () {
    return "DrawingView Nr: " + myCounter;
}


protected void handleMouseEventException (Throwable t) {
    JOptionPane.showMessageDialog (this, t.getClass ().getName () + " - " + t.getMessage (), "Error", JOptionPane.ERROR_MESSAGE);
    t.printStackTrace ();
}


public void mousePressed (MouseEvent e) {
    try {
        requestFocus ();
        Point p = constrainPoint (new Point (e.getX (), e.getY ()));
        setLastClick (new Point (e.getX (), e.getY ()));
        tool ().mouseDown (e, p.x, p.y);
        checkDamage ();
    } catch (Throwable t) {
        handleMouseEventException (t);
    }
}


public void mouseReleased (MouseEvent e) {
    try {
        Point p = constrainPoint (new Point (e.getX (), e.getY ()));
        tool ().mouseUp (e, p.x, p.y);
        checkDamage ();
    } catch (Throwable t) {
        handleMouseEventException (t);
    }
}


public void mouseDragged (MouseEvent e) {
    try {
        Point p = constrainPoint (new Point (e.getX (), e.getY ()));
        tool ().mouseDrag (e, p.x, p.y);
        checkDamage ();
    } catch (Throwable t) {
        handleMouseEventException (t);
    }
}


public void mouseMoved (MouseEvent e) {
    try {
        tool ().mouseMove (e, e.getX (), e.getY ());
    } catch (Throwable t) {
        handleMouseEventException (t);
    }
}


public DrawingViewKeyListener () {
    deleteCmd = createDeleteCommand ();
}


public void keyPressed (KeyEvent e) {
    int code = e.getKeyCode ();
    if ((code == KeyEvent.VK_BACK_SPACE) || (code == KeyEvent.VK_DELETE)) {
        if (deleteCmd.isExecutable ()) {
            deleteCmd.execute ();
        }
    } else if ((code == KeyEvent.VK_DOWN) || (code == KeyEvent.VK_UP) || (code == KeyEvent.VK_RIGHT) || (code == KeyEvent.VK_LEFT)) {
        handleCursorKey (code);
    } else {
        tool ().keyDown (e, code);
    }

    checkDamage ();
}


protected void handleCursorKey (int key) {
    int dx = 0, dy = 0;
    int stepX = 1, stepY = 1;
    if (fConstrainer != null) {
        stepX = fConstrainer.getStepX ();
        stepY = fConstrainer.getStepY ();
    }
    switch (key) {
        case KeyEvent.VK_DOWN :
            dy = stepY;
            break;
        case KeyEvent.VK_UP :
            dy = - stepY;
            break;
        case KeyEvent.VK_RIGHT :
            dx = stepX;
            break;
        case KeyEvent.VK_LEFT :
            dx = - stepX;
            break;
    }
    moveSelection (dx, dy);
}


public void keyTyped (KeyEvent event) {
}


public void keyReleased (KeyEvent event) {
}


protected Command createDeleteCommand () {
    return new UndoableCommand (new DeleteCommand ("Delete", editor ()));
}


protected DNDHelper createDNDHelper () {
    return new DNDHelper () {
        protected DrawingView view () {
            return StandardDrawingView.this;
        }}

    ;
}


protected DrawingView view () {
    return StandardDrawingView.this;
}


protected DNDHelper getDNDHelper () {
    if (dndh == null) {
        dndh = createDNDHelper ();
    }
    return dndh;
}


public boolean setDragSourceActive (boolean state) {
    return getDNDHelper ().setDragSourceActive (state);
}


public boolean setDropTargetActive (boolean state) {
    return getDNDHelper ().setDropTargetActive (state);
}


public NullHandle (Figure owner, Locator locator) {
    super (owner, locator);
}


public void draw (Graphics g) {
    Rectangle r = displayBox ();
    g.setColor (Color.black);
    g.drawRect (r.x, r.y, r.width, r.height);
}


protected FigureTransferCommand (String name, DrawingEditor newDrawingEditor) {
    super (name, newDrawingEditor);
}


protected void deleteFigures (FigureEnumeration fe) {
    DeleteFromDrawingVisitor deleteVisitor = new DeleteFromDrawingVisitor (view ().drawing ());
    while (fe.hasNextFigure ()) {
        fe.nextFigure ().visit (deleteVisitor);
    }
    view ().clearSelection ();
}


protected void copyFigures (FigureEnumeration fe, int figureCount) {
    Clipboard.getClipboard ().setContents (new StandardFigureSelection (fe, figureCount));
}


public FigureEnumeration insertFigures (FigureEnumeration fe, int dx, int dy) {
    return view ().insertFigures (fe, dx, dy, false);
}


protected CompositeFigure () {
    fFigures = CollectionsFactory.current ().createList ();
    _nLowestZ = 0;
    _nHighestZ = 0;
}


public Figure add (Figure figure) {
    if (! containsFigure (figure)) {
        figure.setZValue (++ _nHighestZ);
        fFigures.add (figure);
        figure.addToContainer (this);
        _addToQuadTree (figure);
    }
    return figure;
}


public void addAll (List newFigures) {
    addAll (new FigureEnumerator (newFigures));
}


public void addAll (FigureEnumeration fe) {
    while (fe.hasNextFigure ()) {
        add (fe.nextFigure ());
    }
}


public Figure remove (Figure figure) {
    Figure orphanedFigure = orphan (figure);
    if (orphanedFigure != null) {
        orphanedFigure.release ();
    }
    return orphanedFigure;
}


public void removeAll (List figures) {
    removeAll (new FigureEnumerator (figures));
}


public void removeAll (FigureEnumeration fe) {
    while (fe.hasNextFigure ()) {
        remove (fe.nextFigure ());
    }
}


public void removeAll () {
    FigureEnumeration fe = figures ();
    while (fe.hasNextFigure ()) {
        Figure figure = fe.nextFigure ();
        figure.removeFromContainer (this);
    }
    fFigures.clear ();
    _clearQuadTree ();
    _nLowestZ = 0;
    _nHighestZ = 0;
}


public synchronized Figure orphan (Figure figure) {
    figure.removeFromContainer (this);
    fFigures.remove (figure);
    _removeFromQuadTree (figure);
    return figure;
}


public void orphanAll (List newFigures) {
    orphanAll (new FigureEnumerator (newFigures));
}


public void orphanAll (FigureEnumeration fe) {
    while (fe.hasNextFigure ()) {
        orphan (fe.nextFigure ());
    }
}


public synchronized Figure replace (Figure figure, Figure replacement) {
    int index = fFigures.indexOf (figure);
    if (index != - 1) {
        replacement.setZValue (figure.getZValue ());
        replacement.addToContainer (this);
        figure.removeFromContainer (this);
        fFigures.set (index, replacement);
        figure.changed ();
        replacement.changed ();
    }
    return replacement;
}


public synchronized void sendToBack (Figure figure) {
    if (containsFigure (figure)) {
        fFigures.remove (figure);
        fFigures.add (0, figure);
        _nLowestZ --;
        figure.setZValue (_nLowestZ);
        figure.changed ();
    }
}


public synchronized void bringToFront (Figure figure) {
    if (containsFigure (figure)) {
        fFigures.remove (figure);
        fFigures.add (figure);
        _nHighestZ ++;
        figure.setZValue (_nHighestZ);
        figure.changed ();
    }
}


public void sendToLayer (Figure figure, int layerNr) {
    if (containsFigure (figure)) {
        if (layerNr >= fFigures.size ()) {
            layerNr = fFigures.size () - 1;
        }
        Figure layerFigure = getFigureFromLayer (layerNr);
        int layerFigureZValue = layerFigure.getZValue ();
        int figureLayer = getLayer (figure);
        if (figureLayer  layerNr) {
            assignFiguresToSuccessorZValue (layerNr, figureLayer - 1);
        }

        fFigures.remove (figure);
        fFigures.add (layerNr, figure);
        figure.setZValue (layerFigureZValue);
        figure.changed ();
    }
}


private void assignFiguresToPredecessorZValue (int lowerBound, int upperBound) {
    if (upperBound >= fFigures.size ()) {
        upperBound = fFigures.size () - 1;
    }
    for (int i = upperBound;
    i >= lowerBound; i --) {
        Figure currentFigure = (Figure) fFigures.get (i);
        Figure predecessorFigure = (Figure) fFigures.get (i - 1);
        currentFigure.setZValue (predecessorFigure.getZValue ());
    }
}


private void assignFiguresToSuccessorZValue (int lowerBound, int upperBound) {
    if (upperBound >= fFigures.size ()) {
        upperBound = fFigures.size () - 1;
    }
    for (int i = upperBound;
    i >= lowerBound; i --) {
        Figure currentFigure = (Figure) fFigures.get (i);
        Figure successorFigure = (Figure) fFigures.get (i + 1);
        currentFigure.setZValue (successorFigure.getZValue ());
    }
}


public int getLayer (Figure figure) {
    if (! containsFigure (figure)) {
        return - 1;
    } else {
        return fFigures.indexOf (figure);
    }
}


public Figure getFigureFromLayer (int layerNr) {
    if ((layerNr >= 0) && (layerNr 

public void draw (Graphics g) {
    draw (g, figures ());
}


public void draw (Graphics g, FigureEnumeration fe) {
    while (fe.hasNextFigure ()) {
        fe.nextFigure ().draw (g);
    }
}


public Figure figureAt (int i) {
    return (Figure) fFigures.get (i);
}


public FigureEnumeration figures () {
    return new FigureEnumerator (CollectionsFactory.current ().createList (fFigures));
}


public FigureEnumeration figures (Rectangle viewRectangle) {
    if (_theQuadTree != null) {
        FigureEnumeration fe = _theQuadTree.getAllWithin (new Bounds (viewRectangle).asRectangle2D ());
        List l2 = CollectionsFactory.current ().createList ();
        while (fe.hasNextFigure ()) {
            Figure f = fe.nextFigure ();
            l2.add (new OrderedFigureElement (f, f.getZValue ()));
        }
        Collections.sort (l2);
        List l3 = CollectionsFactory.current ().createList ();
        for (Iterator iter = l2.iterator ();
        iter.hasNext ();) {
            OrderedFigureElement ofe = (OrderedFigureElement) iter.next ();
            l3.add (ofe.getFigure ());
        }
        return new FigureEnumerator (l3);
    }
    return figures ();
}


public int figureCount () {
    return fFigures.size ();
}


public boolean containsFigure (Figure checkFigure) {
    return fFigures.contains (checkFigure);
}


public final FigureEnumeration figuresReverse () {
    return new ReverseFigureEnumerator (CollectionsFactory.current ().createList (fFigures));
}


public Figure findFigure (int x, int y) {
    FigureEnumeration fe = figuresReverse ();
    while (fe.hasNextFigure ()) {
        Figure figure = fe.nextFigure ();
        if (figure.containsPoint (x, y)) {
            return figure;
        }
    }
    return null;
}


public Figure findFigure (Rectangle r) {
    FigureEnumeration fe = figuresReverse ();
    while (fe.hasNextFigure ()) {
        Figure figure = fe.nextFigure ();
        Rectangle fr = figure.displayBox ();
        if (r.intersects (fr)) {
            return figure;
        }
    }
    return null;
}


public Figure findFigureWithout (int x, int y, Figure without) {
    if (without == null) {
        return findFigure (x, y);
    }
    FigureEnumeration fe = figuresReverse ();
    while (fe.hasNextFigure ()) {
        Figure figure = fe.nextFigure ();
        if (figure.containsPoint (x, y) && ! figure.includes (without)) {
            return figure;
        }
    }
    return null;
}


public Figure findFigure (Rectangle r, Figure without) {
    if (without == null) {
        return findFigure (r);
    }
    FigureEnumeration fe = figuresReverse ();
    while (fe.hasNextFigure ()) {
        Figure figure = fe.nextFigure ();
        Rectangle fr = figure.displayBox ();
        if (r.intersects (fr) && ! figure.includes (without)) {
            return figure;
        }
    }
    return null;
}


public Figure findFigureInside (int x, int y) {
    FigureEnumeration fe = figuresReverse ();
    while (fe.hasNextFigure ()) {
        Figure figure = fe.nextFigure ().findFigureInside (x, y);
        if (figure != null) {
            return figure;
        }
    }
    if (containsPoint (x, y)) {
        return this;
    } else {
        return null;
    }
}


public Figure findFigureInsideWithout (int x, int y, Figure without) {
    if (without == null) {
        return findFigureInside (x, y);
    }
    FigureEnumeration fe = figuresReverse ();
    while (fe.hasNextFigure ()) {
        Figure figure = fe.nextFigure ();
        if (figure != without) {
            Figure found = figure.findFigureInside (x, y);
            if ((found != null) && ! figure.includes (without)) {
                return found;
            }
        }
    }
    if (containsPoint (x, y)) {
        return this;
    } else {
        return null;
    }
}


public boolean includes (Figure figure) {
    if (super.includes (figure)) {
        return true;
    }
    FigureEnumeration fe = figures ();
    while (fe.hasNextFigure ()) {
        Figure f = fe.nextFigure ();
        if (f.includes (figure)) {
            return true;
        }
    }
    return false;
}


protected void basicMoveBy (int x, int y) {
    FigureEnumeration fe = figures ();
    while (fe.hasNextFigure ()) {
        fe.nextFigure ().moveBy (x, y);
    }
}


public void release () {
    FigureEnumeration fe = figures ();
    while (fe.hasNextFigure ()) {
        Figure figure = fe.nextFigure ();
        figure.release ();
    }
    super.release ();
}


public void figureInvalidated (FigureChangeEvent e) {
    if (listener () != null) {
        listener ().figureInvalidated (e);
    }
}


public void figureRequestRemove (FigureChangeEvent e) {
    if (listener () != null) {
        listener ().figureRequestRemove (new FigureChangeEvent (this));
    }
}


public void figureRequestUpdate (FigureChangeEvent e) {
    if (listener () != null) {
        listener ().figureRequestUpdate (e);
    }
}


public void figureChanged (FigureChangeEvent e) {
    _removeFromQuadTree (e.getFigure ());
    _addToQuadTree (e.getFigure ());
}


public void figureRemoved (FigureChangeEvent e) {
    if (listener () != null) {
        listener ().figureRemoved (e);
    }
}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeInt (figureCount ());
    FigureEnumeration fe = figures ();
    while (fe.hasNextFigure ()) {
        dw.writeStorable (fe.nextFigure ());
    }
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    int size = dr.readInt ();
    fFigures = CollectionsFactory.current ().createList (size);
    for (int i = 0;
    i 

private void readObject (ObjectInputStream s) throws ClassNotFoundException, IOException {
    s.defaultReadObject ();
    FigureEnumeration fe = figures ();
    while (fe.hasNextFigure ()) {
        Figure figure = fe.nextFigure ();
        figure.addToContainer (this);
    }
    init (new Rectangle (0, 0));
}


public void init (Rectangle viewRectangle) {
    _theQuadTree = new QuadTree (new Bounds (viewRectangle).asRectangle2D ());
    FigureEnumeration fe = figures ();
    while (fe.hasNextFigure ()) {
        _addToQuadTree (fe.nextFigure ());
    }
}


private void _addToQuadTree (Figure f) {
    if (_theQuadTree != null) {
        Rectangle r = f.displayBox ();
        if (r.height == 0) {
            r.grow (0, 1);
        }
        if (r.width == 0) {
            r.grow (1, 0);
        }
        _theQuadTree.add (f, new Bounds (r).asRectangle2D ());
    }
}


private void _removeFromQuadTree (Figure f) {
    if (_theQuadTree != null) {
        _theQuadTree.remove (f);
    }
}


private void _clearQuadTree () {
    if (_theQuadTree != null) {
        _theQuadTree.clear ();
    }
}


public ConnectionTool (DrawingEditor newDrawingEditor, ConnectionFigure newPrototype) {
    super (newDrawingEditor);
    fPrototype = newPrototype;
}


public void mouseMove (MouseEvent e, int x, int y) {
    trackConnectors (e, x, y);
}


public void mouseDown (MouseEvent e, int x, int y) {
    super.mouseDown (e, x, y);
    int ex = e.getX ();
    int ey = e.getY ();
    setTargetFigure (findConnectionStart (ex, ey, drawing ()));
    if (getTargetFigure () != null) {
        setStartConnector (findConnector (ex, ey, getTargetFigure ()));
        if (getStartConnector () != null) {
            setConnection (createConnection ());
            getConnection ().startPoint (ex, ey);
            getConnection ().endPoint (ex, ey);
            setAddedFigure (view ().add (getConnection ()));
        }
    } else {
        ConnectionFigure connection = findConnection (ex, ey, drawing ());
        if (connection != null) {
            if (! connection.joinSegments (ex, ey)) {
                fSplitPoint = connection.splitSegment (ex, ey);
                fEditedConnection = connection;
            } else {
                fEditedConnection = null;
            }
        }
    }
}


public void mouseDrag (MouseEvent e, int x, int y) {
    Point p = new Point (e.getX (), e.getY ());
    if (getConnection () != null) {
        trackConnectors (e, x, y);
        if (getTargetConnector () != null) {
            p = Geom.center (getTargetConnector ().displayBox ());
        }
        getConnection ().endPoint (p.x, p.y);
    } else if (fEditedConnection != null) {
        Point pp = new Point (x, y);
        fEditedConnection.setPointAt (pp, fSplitPoint);
    }

}


public void mouseUp (MouseEvent e, int x, int y) {
    Figure c = null;
    if (getStartConnector () != null) {
        c = findTarget (e.getX (), e.getY (), drawing ());
    }
    if (c != null) {
        setEndConnector (findConnector (e.getX (), e.getY (), c));
        if (getEndConnector () != null) {
            getConnection ().connectStart (getStartConnector ());
            getConnection ().connectEnd (getEndConnector ());
            getConnection ().updateConnection ();
            setUndoActivity (createUndoActivity ());
            getUndoActivity ().setAffectedFigures (new SingleFigureEnumerator (getAddedFigure ()));
        }
    } else if (getConnection () != null) {
        view ().remove (getConnection ());
    }

    setConnection (null);
    setStartConnector (null);
    setEndConnector (null);
    setAddedFigure (null);
    editor ().toolDone ();
}


public void deactivate () {
    super.deactivate ();
    if (getTargetFigure () != null) {
        getTargetFigure ().connectorVisibility (false, null);
    }
}


protected ConnectionFigure createConnection () {
    return (ConnectionFigure) fPrototype.clone ();
}


protected Figure findSource (int x, int y, Drawing drawing) {
    return findConnectableFigure (x, y, drawing);
}


protected Figure findTarget (int x, int y, Drawing drawing) {
    Figure target = findConnectableFigure (x, y, drawing);
    Figure start = getStartConnector ().owner ();
    if (target != null && getConnection () != null && target.canConnect () && ! target.includes (start) && getConnection ().canConnect (start, target)) {
        return target;
    }
    return null;
}


protected ConnectionFigure findConnection (int x, int y, Drawing drawing) {
    FigureEnumeration fe = drawing.figuresReverse ();
    while (fe.hasNextFigure ()) {
        Figure figure = fe.nextFigure ();
        figure = figure.findFigureInside (x, y);
        if (figure != null && (figure instanceof ConnectionFigure)) {
            return (ConnectionFigure) figure;
        }
    }
    return null;
}


protected void setConnection (ConnectionFigure newConnection) {
    myConnection = newConnection;
}


protected ConnectionFigure getConnection () {
    return myConnection;
}


protected void trackConnectors (MouseEvent e, int x, int y) {
    Figure c = null;
    if (getStartConnector () == null) {
        c = findSource (x, y, getActiveDrawing ());
    } else {
        c = findTarget (x, y, getActiveDrawing ());
    }
    if (c != getTargetFigure ()) {
        if (getTargetFigure () != null) {
            getTargetFigure ().connectorVisibility (false, null);
        }
        setTargetFigure (c);
        if (getTargetFigure () != null) {
            getTargetFigure ().connectorVisibility (true, getConnection ());
        }
    }
    Connector cc = null;
    if (c != null) {
        cc = findConnector (e.getX (), e.getY (), c);
    }
    if (cc != getTargetConnector ()) {
        setTargetConnector (cc);
    }
    getActiveView ().checkDamage ();
}


protected Connector findConnector (int x, int y, Figure f) {
    return f.connectorAt (x, y);
}


protected Figure findConnectionStart (int x, int y, Drawing drawing) {
    Figure target = findConnectableFigure (x, y, drawing);
    if ((target != null) && target.canConnect ()) {
        return target;
    }
    return null;
}


protected Figure findConnectableFigure (int x, int y, Drawing drawing) {
    FigureEnumeration fe = drawing.figuresReverse ();
    while (fe.hasNextFigure ()) {
        Figure figure = fe.nextFigure ();
        if (! figure.includes (getConnection ()) && figure.canConnect () && figure.containsPoint (x, y)) {
            return figure;
        }
    }
    return null;
}


protected void setStartConnector (Connector newStartConnector) {
    myStartConnector = newStartConnector;
}


protected Connector getStartConnector () {
    return myStartConnector;
}


protected void setEndConnector (Connector newEndConnector) {
    myEndConnector = newEndConnector;
}


protected Connector getEndConnector () {
    return myEndConnector;
}


protected void setTargetConnector (Connector newTargetConnector) {
    myTargetConnector = newTargetConnector;
}


protected Connector getTargetConnector () {
    return myTargetConnector;
}


protected void setTargetFigure (Figure newTarget) {
    myTarget = newTarget;
}


protected Figure getTargetFigure () {
    return myTarget;
}


protected Figure getAddedFigure () {
    return myAddedFigure;
}


protected void setAddedFigure (Figure newAddedFigure) {
    myAddedFigure = newAddedFigure;
}


protected Undoable createUndoActivity () {
    return new ConnectionTool.UndoActivity (view (), getConnection ());
}


public UndoActivity (DrawingView newDrawingView, ConnectionFigure newConnection) {
    super (newDrawingView);
    setConnection (newConnection);
    myStartConnector = getConnection ().getStartConnector ();
    myEndConnector = getConnection ().getEndConnector ();
    setUndoable (true);
    setRedoable (true);
}


public boolean undo () {
    if (! super.undo ()) {
        return false;
    }
    getConnection ().disconnectStart ();
    getConnection ().disconnectEnd ();
    FigureEnumeration fe = getAffectedFigures ();
    while (fe.hasNextFigure ()) {
        getDrawingView ().drawing ().orphan (fe.nextFigure ());
    }
    getDrawingView ().clearSelection ();
    return true;
}


public boolean redo () {
    if (! super.redo ()) {
        return false;
    }
    getConnection ().connectStart (myStartConnector);
    getConnection ().connectEnd (myEndConnector);
    getConnection ().updateConnection ();
    getDrawingView ().insertFigures (getAffectedFigures (), 0, 0, false);
    return true;
}


protected void setConnection (ConnectionFigure newConnection) {
    myConnection = newConnection;
}


protected ConnectionFigure getConnection () {
    return myConnection;
}


public DeleteFromDrawingVisitor (Drawing newDrawing) {
    myDeletedFigures = CollectionsFactory.current ().createSet ();
    setDrawing (newDrawing);
}


private void setDrawing (Drawing newDrawing) {
    myDrawing = newDrawing;
}


protected Drawing getDrawing () {
    return myDrawing;
}


public void visitFigure (Figure hostFigure) {
    if (! myDeletedFigures.contains (hostFigure) && getDrawing ().containsFigure (hostFigure)) {
        Figure orphanedFigure = getDrawing ().orphan (hostFigure);
        myDeletedFigures.add (orphanedFigure);
    }
}


public void visitHandle (Handle hostHandle) {
}


public void visitFigureChangeListener (FigureChangeListener hostFigureChangeListener) {
}


public FigureEnumeration getDeletedFigures () {
    return new FigureEnumerator (myDeletedFigures);
}


private PeripheralLocator () {
}


public PeripheralLocator (int pointsPerSide, int index) {
    fPPS = pointsPerSide;
    fIndex = index;
    if (index >= pointsPerSide * 4) {
        throw new IllegalArgumentException ("Index must be within the range of points starting with index = 0.");
    }
}


public Point locate (Figure parm1) {
    Rectangle r = parm1.displayBox ();
    int circumference = r.width * 2 + r.height * 2;
    int insets = 2 * 4 * CORNERSPACE;
    int spacing = circumference / (fPPS * 4 + 4);
    float hSpacing = (float) r.width / (fPPS + 1);
    float vSpacing = (float) r.height / (fPPS + 1);
    int x, y;
    if (fIndex 

public OffsetLocator () {
    fBase = null;
    fOffsetX = 0;
    fOffsetY = 0;
}


public OffsetLocator (Locator base) {
    this ();
    fBase = base;
}


public OffsetLocator (Locator base, int offsetX, int offsetY) {
    this (base);
    fOffsetX = offsetX;
    fOffsetY = offsetY;
}


public Point locate (Figure owner) {
    Point p = fBase.locate (owner);
    p.x += fOffsetX;
    p.y += fOffsetY;
    return p;
}


public void moveBy (int dx, int dy) {
    fOffsetX += dx;
    fOffsetY += dy;
}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeInt (fOffsetX);
    dw.writeInt (fOffsetY);
    dw.writeStorable (fBase);
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    fOffsetX = dr.readInt ();
    fOffsetY = dr.readInt ();
    fBase = (Locator) dr.readStorable ();
}


public LocatorConnector () {
    setLocator (null);
}


public LocatorConnector (Figure owner, Locator l) {
    super (owner);
    setLocator (l);
}


public boolean containsPoint (int x, int y) {
    return displayBox ().contains (x, y);
}


public Rectangle displayBox () {
    Point p = getLocator ().locate (owner ());
    return new Rectangle (p.x - SIZE / 2, p.y - SIZE / 2, SIZE, SIZE);
}


public void draw (Graphics g) {
    Rectangle r = displayBox ();
    g.setColor (Color.blue);
    g.fillOval (r.x, r.y, r.width, r.height);
    g.setColor (Color.black);
    g.drawOval (r.x, r.y, r.width, r.height);
}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeStorable (getLocator ());
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    setLocator ((Locator) dr.readStorable ());
}


protected void setLocator (Locator newLocator) {
    myLocator = newLocator;
}


public Locator getLocator () {
    return myLocator;
}


public InsertIntoDrawingVisitor (Drawing newDrawing) {
    myInsertedFigures = CollectionsFactory.current ().createSet ();
    setDrawing (newDrawing);
}


private void setDrawing (Drawing newDrawing) {
    myDrawing = newDrawing;
}


protected Drawing getDrawing () {
    return myDrawing;
}


public void visitFigure (Figure hostFigure) {
    if (! myInsertedFigures.contains (hostFigure) && ! getDrawing ().includes (hostFigure)) {
        Figure addedFigure = getDrawing ().add (hostFigure);
        myInsertedFigures.add (addedFigure);
    }
}


public void visitHandle (Handle hostHandle) {
}


public void visitFigureChangeListener (FigureChangeListener hostFigureChangeListener) {
}


public FigureEnumeration getInsertedFigures () {
    return new FigureEnumerator (myInsertedFigures);
}


public DecoratorFigure () {
    initialize ();
}


public DecoratorFigure (Figure figure) {
    initialize ();
    decorate (figure);
}


protected void initialize () {
}


public Insets connectionInsets () {
    return getDecoratedFigure ().connectionInsets ();
}


public boolean canConnect () {
    return getDecoratedFigure ().canConnect ();
}


public boolean containsPoint (int x, int y) {
    return getDecoratedFigure ().containsPoint (x, y);
}


public void decorate (Figure figure) {
    setDecoratedFigure (figure);
    getDecoratedFigure ().addToContainer (this);
}


public Figure peelDecoration () {
    getDecoratedFigure ().removeFromContainer (this);
    removeDependendFigure (getDecoratedFigure ());
    return getDecoratedFigure ();
}


public void setDecoratedFigure (Figure newDecoratedFigure) {
    myDecoratedFigure = newDecoratedFigure;
}


public Figure getDecoratedFigure () {
    return myDecoratedFigure;
}


public Rectangle displayBox () {
    return getDecoratedFigure ().displayBox ();
}


public void basicDisplayBox (Point origin, Point corner) {
    getDecoratedFigure ().basicDisplayBox (origin, corner);
}


public void draw (Graphics g) {
    getDecoratedFigure ().draw (g);
}


public Figure findFigureInside (int x, int y) {
    Figure foundFigure = getDecoratedFigure ().findFigureInside (x, y);
    if ((foundFigure != null) && (foundFigure == getDecoratedFigure ())) {
        return this;
    } else {
        return foundFigure;
    }
}


public HandleEnumeration handles () {
    return getDecoratedFigure ().handles ();
}


public boolean includes (Figure figure) {
    return (super.includes (figure) || getDecoratedFigure ().includes (figure));
}


public void moveBy (int x, int y) {
    getDecoratedFigure ().moveBy (x, y);
}


protected void basicMoveBy (int x, int y) {
}


public void release () {
    super.release ();
    getDecoratedFigure ().removeFromContainer (this);
    getDecoratedFigure ().release ();
}


public void figureInvalidated (FigureChangeEvent e) {
    if (listener () != null) {
        listener ().figureInvalidated (e);
    }
}


public void figureChanged (FigureChangeEvent e) {
}


public void figureRemoved (FigureChangeEvent e) {
}


public void figureRequestUpdate (FigureChangeEvent e) {
    if (listener () != null) {
        listener ().figureRequestUpdate (e);
    }
}


public void figureRequestRemove (FigureChangeEvent e) {
    if (listener () != null) {
        listener ().figureRequestRemove (new FigureChangeEvent (this));
    }
}


public FigureEnumeration figures () {
    return getDecoratedFigure ().figures ();
}


public FigureEnumeration decompose () {
    return getDecoratedFigure ().decompose ();
}


public void setAttribute (String name, Object value) {
    getDecoratedFigure ().setAttribute (name, value);
}


public void setAttribute (FigureAttributeConstant attributeConstant, Object value) {
    getDecoratedFigure ().setAttribute (attributeConstant, value);
}


public Object getAttribute (String name) {
    return getDecoratedFigure ().getAttribute (name);
}


public Object getAttribute (FigureAttributeConstant attributeConstant) {
    return getDecoratedFigure ().getAttribute (attributeConstant);
}


public Locator connectedTextLocator (Figure text) {
    return getDecoratedFigure ().connectedTextLocator (text);
}


public Connector connectorAt (int x, int y) {
    return getDecoratedFigure ().connectorAt (x, y);
}


public void connectorVisibility (boolean isVisible, ConnectionFigure courtingConnection) {
    getDecoratedFigure ().connectorVisibility (isVisible, null);
}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeStorable (getDecoratedFigure ());
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    decorate ((Figure) dr.readStorable ());
}


private void readObject (ObjectInputStream s) throws ClassNotFoundException, IOException {
    s.defaultReadObject ();
    getDecoratedFigure ().addToContainer (this);
}


public TextHolder getTextHolder () {
    return getDecoratedFigure ().getTextHolder ();
}


public synchronized FigureEnumeration getDependendFigures () {
    return getDecoratedFigure ().getDependendFigures ();
}


public synchronized void addDependendFigure (Figure newDependendFigure) {
    getDecoratedFigure ().addDependendFigure (newDependendFigure);
}


public synchronized void removeDependendFigure (Figure oldDependendFigure) {
    getDecoratedFigure ().removeDependendFigure (oldDependendFigure);
}


public AbstractTool (DrawingEditor newDrawingEditor) {
    myDrawingEditor = newDrawingEditor;
    setEventDispatcher (createEventDispatcher ());
    setEnabled (true);
    checkUsable ();
    editor ().addViewChangeListener (this);
}


public void activate () {
    if (getActiveView () != null) {
        getActiveView ().clearSelection ();
        getActiveView ().checkDamage ();
        getEventDispatcher ().fireToolActivatedEvent ();
    }
}


public void deactivate () {
    if (isActive ()) {
        if (getActiveView () != null) {
            getActiveView ().setCursor (Cursor.getDefaultCursor ());
        }
        getEventDispatcher ().fireToolDeactivatedEvent ();
    }
}


public void viewSelectionChanged (DrawingView oldView, DrawingView newView) {
    if (isActive ()) {
        deactivate ();
        activate ();
    }
    checkUsable ();
}


public void viewCreated (DrawingView view) {
}


public void viewDestroying (DrawingView view) {
}


public void mouseDown (MouseEvent e, int x, int y) {
    setAnchorX (x);
    setAnchorY (y);
    setView ((DrawingView) e.getSource ());
}


public void mouseDrag (MouseEvent e, int x, int y) {
}


public void mouseUp (MouseEvent e, int x, int y) {
}


public void mouseMove (MouseEvent evt, int x, int y) {
}


public void keyDown (KeyEvent evt, int key) {
}


public Drawing drawing () {
    return view ().drawing ();
}


public Drawing getActiveDrawing () {
    return getActiveView ().drawing ();
}


public DrawingEditor editor () {
    return myDrawingEditor;
}


protected void setEditor (DrawingEditor newDrawingEditor) {
    myDrawingEditor = newDrawingEditor;
}


public DrawingView view () {
    return myDrawingView;
}


protected void setView (DrawingView newDrawingView) {
    myDrawingView = newDrawingView;
}


public DrawingView getActiveView () {
    return editor ().view ();
}


public boolean isUsable () {
    return isEnabled () && myIsUsable;
}


public void setUsable (boolean newIsUsable) {
    if (isUsable () != newIsUsable) {
        myIsUsable = newIsUsable;
        if (isUsable ()) {
            getEventDispatcher ().fireToolUsableEvent ();
        } else {
            getEventDispatcher ().fireToolUnusableEvent ();
        }
    }
}


public void setEnabled (boolean newIsEnabled) {
    if (isEnabled () != newIsEnabled) {
        myIsEnabled = newIsEnabled;
        if (isEnabled ()) {
            getEventDispatcher ().fireToolEnabledEvent ();
        } else {
            getEventDispatcher ().fireToolDisabledEvent ();
            setUsable (false);
            deactivate ();
        }
    }
}


public boolean isEnabled () {
    return myIsEnabled;
}


protected void setAnchorX (int newAnchorX) {
    myAnchorX = newAnchorX;
}


protected int getAnchorX () {
    return myAnchorX;
}


protected void setAnchorY (int newAnchorY) {
    myAnchorY = newAnchorY;
}


protected int getAnchorY () {
    return myAnchorY;
}


public Undoable getUndoActivity () {
    return myUndoActivity;
}


public void setUndoActivity (Undoable newUndoActivity) {
    myUndoActivity = newUndoActivity;
}


public boolean isActive () {
    return (editor ().tool () == this) && isUsable ();
}


public void addToolListener (ToolListener newToolListener) {
    getEventDispatcher ().addToolListener (newToolListener);
}


public void removeToolListener (ToolListener oldToolListener) {
    getEventDispatcher ().removeToolListener (oldToolListener);
}


private void setEventDispatcher (AbstractTool.EventDispatcher newEventDispatcher) {
    myEventDispatcher = newEventDispatcher;
}


protected AbstractTool.EventDispatcher getEventDispatcher () {
    return myEventDispatcher;
}


public AbstractTool.EventDispatcher createEventDispatcher () {
    return new AbstractTool.EventDispatcher (this);
}


protected void checkUsable () {
    if (isEnabled ()) {
        setUsable ((getActiveView () != null) && getActiveView ().isInteractive ());
    }
}


public EventDispatcher (Tool newObservedTool) {
    myRegisteredListeners = CollectionsFactory.current ().createList ();
    myObservedTool = newObservedTool;
}


public void fireToolUsableEvent () {
    Iterator iter = myRegisteredListeners.iterator ();
    while (iter.hasNext ()) {
        ((ToolListener) iter.next ()).toolUsable (new EventObject (myObservedTool));
    }
}


public void fireToolUnusableEvent () {
    Iterator iter = myRegisteredListeners.iterator ();
    while (iter.hasNext ()) {
        ((ToolListener) iter.next ()).toolUnusable (new EventObject (myObservedTool));
    }
}


public void fireToolActivatedEvent () {
    Iterator iter = myRegisteredListeners.iterator ();
    while (iter.hasNext ()) {
        ((ToolListener) iter.next ()).toolActivated (new EventObject (myObservedTool));
    }
}


public void fireToolDeactivatedEvent () {
    Iterator iter = myRegisteredListeners.iterator ();
    while (iter.hasNext ()) {
        ((ToolListener) iter.next ()).toolDeactivated (new EventObject (myObservedTool));
    }
}


public void fireToolEnabledEvent () {
    Iterator iter = myRegisteredListeners.iterator ();
    while (iter.hasNext ()) {
        ((ToolListener) iter.next ()).toolEnabled (new EventObject (myObservedTool));
    }
}


public void fireToolDisabledEvent () {
    Iterator iter = myRegisteredListeners.iterator ();
    while (iter.hasNext ()) {
        ((ToolListener) iter.next ()).toolDisabled (new EventObject (myObservedTool));
    }
}


public void addToolListener (ToolListener newToolListener) {
    if (! myRegisteredListeners.contains (newToolListener)) {
        myRegisteredListeners.add (newToolListener);
    }
}


public void removeToolListener (ToolListener oldToolListener) {
    if (myRegisteredListeners.contains (oldToolListener)) {
        myRegisteredListeners.remove (oldToolListener);
    }
}


public SelectAreaTracker (DrawingEditor newDrawingEditor) {
    this (newDrawingEditor, Color.black);
}


public SelectAreaTracker (DrawingEditor newDrawingEditor, Color rubberBandColor) {
    super (newDrawingEditor);
    fRubberBandColor = rubberBandColor;
}


public void mouseDown (MouseEvent e, int x, int y) {
    super.mouseDown (e, e.getX (), e.getY ());
    rubberBand (getAnchorX (), getAnchorY (), getAnchorX (), getAnchorY ());
}


public void mouseDrag (MouseEvent e, int x, int y) {
    super.mouseDrag (e, x, y);
    eraseRubberBand ();
    rubberBand (getAnchorX (), getAnchorY (), x, y);
}


public void mouseUp (MouseEvent e, int x, int y) {
    eraseRubberBand ();
    selectGroup (e.isShiftDown ());
    super.mouseUp (e, x, y);
}


private void rubberBand (int x1, int y1, int x2, int y2) {
    fSelectGroup = new Rectangle (new Point (x1, y1));
    fSelectGroup.add (new Point (x2, y2));
    drawXORRect (fSelectGroup);
}


private void eraseRubberBand () {
    drawXORRect (fSelectGroup);
}


private void drawXORRect (Rectangle r) {
    Graphics g = view ().getGraphics ();
    if (g != null) {
        try {
            if (g instanceof Graphics2D) {
                Stroke dashedStroke = new BasicStroke (1.0f, BasicStroke.CAP_SQUARE, BasicStroke.JOIN_MITER, 10.0f, new float [] {5f, 5f, 5f, 5f}, 5.0f);
                ((Graphics2D) g).setStroke (dashedStroke);
            }
            g.setXORMode (view ().getBackground ());
            g.setColor (fRubberBandColor);
            g.drawRect (r.x, r.y, r.width, r.height);
        } finally {
            g.dispose ();
        }
    }
}


private void selectGroup (boolean toggle) {
    FigureEnumeration fe = drawing ().figuresReverse ();
    while (fe.hasNextFigure ()) {
        Figure figure = fe.nextFigure ();
        Rectangle r2 = figure.displayBox ();
        if (fSelectGroup.contains (r2.x, r2.y) && fSelectGroup.contains (r2.x + r2.width, r2.y + r2.height)) {
            if (toggle) {
                view ().toggleSelection (figure);
            } else {
                view ().addToSelection (figure);
            }
        }
    }
}


public JDOStorageFormat () {
    super ();
    pms = CollectionsFactory.current ().createMap ();
    Runtime.getRuntime ().addShutdownHook (new Thread () {
        public void run () {
            Iterator iter = pms.values ().iterator ();
        }}

    );
}


public void run () {
    Iterator iter = pms.values ().iterator ();
}


protected String createFileExtension () {
    return "j2";
}


public String createFileDescription () {
    return "Database (" + getFileExtension () + ")";
}


public String store (String fileName, Drawing storeDrawing) throws IOException {
    PersistenceManager pm = getPersistenceManager (fileName);
    String drawingName = null;
    Drawing txnDrawing = crossTxnBoundaries (storeDrawing);
    endTransaction (pm, false);
    startTransaction (pm);
    try {
        Extent extent = pm.getExtent (StandardDrawing.class, true);
        DrawingListModel listModel = new DrawingListModel (extent.iterator ());
        drawingName = showStoreDialog (listModel, storeDrawing);
        if (drawingName != null) {
            storeDrawing.setTitle (drawingName);
            txnDrawing.setTitle (drawingName);
            pm.makePersistent (txnDrawing);
        }
    } finally {
        endTransaction (pm, (drawingName != null));
    }
    startTransaction (pm);
    return drawingName;
}


public synchronized Drawing restore (String fileName) throws IOException {
    PersistenceManager pm = getPersistenceManager (fileName);
    endTransaction (pm, false);
    startTransaction (pm);
    Drawing restoredDrawing = null;
    try {
        Extent extent = pm.getExtent (StandardDrawing.class, true);
        DrawingListModel listModel = new DrawingListModel (extent.iterator ());
        Drawing txnDrawing = showRestoreDialog (listModel);
        if (txnDrawing != null) {
            restoredDrawing = txnDrawing;
        }
    } finally {
        endTransaction (pm, false);
    }
    startTransaction (pm);
    return restoredDrawing;
}


private void retrieveAll (PersistenceManager pm, Figure figure) {
    pm.retrieve (figure);
    FigureEnumeration fe = figure.figures ();
    while (fe.hasNextFigure ()) {
        retrieveAll (pm, fe.nextFigure ());
    }
}


private Drawing crossTxnBoundaries (Drawing originalDrawing) {
    return (Drawing) ((StandardDrawing) originalDrawing).clone ();
}


private synchronized PersistenceManager getPersistenceManager (String fileName) {
    PersistenceManager pm = (PersistenceManager) pms.get (fileName);
    if (pm == null) {
        pm = createPersistenceManagerFactory (fileName).getPersistenceManager ();
        pms.put (fileName, pm);
    }
    return pm;
}


private PersistenceManagerFactory createPersistenceManagerFactory (String dbFileName) {
    Properties pmfProps = new Properties ();
    pmfProps.put ("javax.jdo.PersistenceManagerFactoryClass", "com.poet.jdo.PersistenceManagerFactories");
    pmfProps.put ("javax.jdo.option.ConnectionURL", "fastobjects://LOCAL/MyBase.j1");
    final PersistenceManagerFactory pmf = JDOHelper.getPersistenceManagerFactory (pmfProps);
    return pmf;
}


private static void startTransaction (PersistenceManager pm) {
    if (! pm.currentTransaction ().isActive ()) {
        pm.currentTransaction ().begin ();
    }
}


private static void endTransaction (PersistenceManager pm, boolean doCommit) {
    if (pm.currentTransaction ().isActive ()) {
        if (doCommit) {
            pm.currentTransaction ().commit ();
        } else {
            pm.currentTransaction ().rollback ();
        }
    }
}


private String showStoreDialog (ListModel listModel, Drawing storeDrawing) {
    final String msgString = "Specify a name for the drawing";
    final JTextField nameTextField = new JTextField (storeDrawing.getTitle ());
    final JList dataList = new JList (listModel);
    final JScrollPane dbContentScrollPane = new JScrollPane (dataList);
    Object [] guiComponents = {msgString, dbContentScrollPane, nameTextField};
    dataList.setSelectionMode (ListSelectionModel.SINGLE_SELECTION);
    dataList.setValueIsAdjusting (true);
    dataList.addListSelectionListener (new ListSelectionListener () {
        public void valueChanged (ListSelectionEvent e) {
            nameTextField.setText (dataList.getSelectedValue ().toString ());
        }}

    );
    final JOptionPane optionPane = new JOptionPane (guiComponents, JOptionPane.PLAIN_MESSAGE, JOptionPane.OK_CANCEL_OPTION);
    final JDialog dialog = optionPane.createDialog (null, "Restore a drawing from the database");
    dialog.setVisible (true);
    if ((optionPane.getValue () != null) && (optionPane.getValue ().equals (new Integer (JOptionPane.OK_OPTION)))) {
        return nameTextField.getText ();
    } else {
        return null;
    }
}


public void valueChanged (ListSelectionEvent e) {
    nameTextField.setText (dataList.getSelectedValue ().toString ());
}


private Drawing showRestoreDialog (DrawingListModel listModel) {
    final String msgString = "Select a drawing";
    final JList dataList = new JList (listModel);
    final JScrollPane dbContentScrollPane = new JScrollPane (dataList);
    Object [] guiComponents = {msgString, dbContentScrollPane};
    dataList.setSelectionMode (ListSelectionModel.SINGLE_SELECTION);
    dataList.setValueIsAdjusting (true);
    final JOptionPane optionPane = new JOptionPane (guiComponents, JOptionPane.PLAIN_MESSAGE, JOptionPane.OK_CANCEL_OPTION);
    final JDialog dialog = optionPane.createDialog (null, "Restore a drawing from the database");
    dialog.setVisible (true);
    if ((optionPane.getValue () != null) && (optionPane.getValue ().equals (new Integer (JOptionPane.OK_OPTION))) && (dataList.getSelectedIndex () >= 0) && (dataList.getSelectedIndex () 

DrawingListModel (Iterator iter) {
    myList = CollectionsFactory.current ().createList ();
    while (iter.hasNext ()) {
        Object o = iter.next ();
        System.out.println ("extent: " + o + " .. " + ((Drawing) o).getTitle ());
        myList.add (o);
    }
}


public Object getElementAt (int index) {
    return getDrawingAt (index).getTitle ();
}


protected Drawing getDrawingAt (int index) {
    return ((Drawing) myList.get (index));
}


public int getSize () {
    return myList.size ();
}


DrawingSelector () {
    init ();
}


private void init () {
    setTitle ("Select Drawing");
    getContentPane ().setLayout (new BorderLayout ());
    getContentPane ().add (new JLabel ("Database content"), BorderLayout.NORTH);
    setSize (200, 200);
}


public static void main (String [] args) {
    DrawingSelector frame = new DrawingSelector ();
    try {
        Drawing newDrawing = new StandardDrawing ();
        newDrawing.setTitle ("TestDrawingName" + new Random (System.currentTimeMillis ()).nextLong ());
        new JDOStorageFormat ().store ("base.j2", newDrawing);
        System.exit (0);
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


public UndoableTool (Tool newWrappedTool) {
    setEventDispatcher (createEventDispatcher ());
    setWrappedTool (newWrappedTool);
    getWrappedTool ().addToolListener (this);
}


public void activate () {
    getWrappedTool ().activate ();
}


public void deactivate () {
    getWrappedTool ().deactivate ();
    Undoable undoActivity = getWrappedTool ().getUndoActivity ();
    if ((undoActivity != null) && (undoActivity.isUndoable ())) {
        editor ().getUndoManager ().pushUndo (undoActivity);
        editor ().getUndoManager ().clearRedos ();
        editor ().figureSelectionChanged (getActiveView ());
    }
}


public void mouseDown (MouseEvent e, int x, int y) {
    getWrappedTool ().mouseDown (e, x, y);
}


public void mouseDrag (MouseEvent e, int x, int y) {
    getWrappedTool ().mouseDrag (e, x, y);
}


public void mouseUp (MouseEvent e, int x, int y) {
    getWrappedTool ().mouseUp (e, x, y);
}


public void mouseMove (MouseEvent evt, int x, int y) {
    getWrappedTool ().mouseMove (evt, x, y);
}


public void keyDown (KeyEvent evt, int key) {
    getWrappedTool ().keyDown (evt, key);
}


public boolean isUsable () {
    return getWrappedTool ().isUsable ();
}


public boolean isActive () {
    return editor ().tool () == this;
}


public boolean isEnabled () {
    return getWrappedTool ().isEnabled ();
}


public void setUsable (boolean newIsUsable) {
    getWrappedTool ().setUsable (newIsUsable);
}


public void setEnabled (boolean newIsEnabled) {
    getWrappedTool ().setEnabled (newIsEnabled);
}


protected void setWrappedTool (Tool newWrappedTool) {
    myWrappedTool = newWrappedTool;
}


protected Tool getWrappedTool () {
    return myWrappedTool;
}


public DrawingEditor editor () {
    return getWrappedTool ().editor ();
}


public DrawingView view () {
    return editor ().view ();
}


public Undoable getUndoActivity () {
    return new UndoableAdapter (view ());
}


public void setUndoActivity (Undoable newUndoableActivity) {
}


public void toolUsable (EventObject toolEvent) {
    getEventDispatcher ().fireToolUsableEvent ();
}


public void toolUnusable (EventObject toolEvent) {
    getEventDispatcher ().fireToolUnusableEvent ();
}


public void toolActivated (EventObject toolEvent) {
    getEventDispatcher ().fireToolActivatedEvent ();
}


public void toolDeactivated (EventObject toolEvent) {
    getEventDispatcher ().fireToolDeactivatedEvent ();
}


public void toolEnabled (EventObject toolEvent) {
    getEventDispatcher ().fireToolEnabledEvent ();
}


public void toolDisabled (EventObject toolEvent) {
    getEventDispatcher ().fireToolDisabledEvent ();
}


public void addToolListener (ToolListener newToolListener) {
    getEventDispatcher ().addToolListener (newToolListener);
}


public void removeToolListener (ToolListener oldToolListener) {
    getEventDispatcher ().removeToolListener (oldToolListener);
}


private void setEventDispatcher (AbstractTool.EventDispatcher newEventDispatcher) {
    myEventDispatcher = newEventDispatcher;
}


protected AbstractTool.EventDispatcher getEventDispatcher () {
    return myEventDispatcher;
}


public AbstractTool.EventDispatcher createEventDispatcher () {
    return new AbstractTool.EventDispatcher (this);
}


public DrawingView getActiveView () {
    return editor ().view ();
}


public GraphLayout () {
}


private GraphNode getGraphNode (Figure node) {
    return (GraphNode) nodes.get (node);
}


private double len (Figure edge) {
    return ((Double) edges.get (edge)).doubleValue () * LENGTH_FACTOR;
}


public void addNode (Figure node) {
    nodes.put (node, new GraphNode (node));
    node.addFigureChangeListener (this);
}


public void addEdge (ConnectionFigure edge, int addlen) {
    Dimension d1 = edge.getStartConnector ().owner ().size ();
    Dimension d2 = edge.getEndConnector ().owner ().size ();
    int len = Math.max (d1.width, d1.height) / 2 + Math.max (d2.width, d2.height) / 2 + addlen;
    edges.put (edge, new Double (len));
}


public synchronized void relax () {
    if (nodes == null) return;

    Enumeration edgeEnum = edges.keys ();
    while (edgeEnum.hasMoreElements ()) {
        ConnectionFigure e = (ConnectionFigure) edgeEnum.nextElement ();
        double targetlen = len (e);
        GraphNode from = getGraphNode (e.getStartConnector ().owner ());
        GraphNode to = getGraphNode (e.getEndConnector ().owner ());
        double vx = to.x - from.x;
        double vy = to.y - from.y;
        double len = Math.sqrt (vx * vx + vy * vy);
        if (len > 0) {
            double f = SPRING_STRENGTH * (targetlen - len) / len;
            double dx = f * vx;
            double dy = f * vy;
            double phi = Math.atan2 (vx, vy);
            double dir = - Math.sin (4 * phi);
            dx += TORQUE_STRENGTH * vy * dir / len;
            dy += - TORQUE_STRENGTH * vx * dir / len;
            to.dx += dx;
            to.dy += dy;
            from.dx += - dx;
            from.dy += - dy;
        }
    }
    Enumeration nodeEnum1 = nodes.elements ();
    while (nodeEnum1.hasMoreElements ()) {
        GraphNode n1 = (GraphNode) nodeEnum1.nextElement ();
        double dx = 0;
        double dy = 0;
        Enumeration nodeEnum2 = nodes.elements ();
        while (nodeEnum2.hasMoreElements ()) {
            GraphNode n2 = (GraphNode) nodeEnum2.nextElement ();
            if (n1 == n2) {
                continue;
            }
            double vx = n1.x - n2.x;
            double vy = n1.y - n2.y;
            double lensqr = vx * vx + vy * vy;
            double len = Math.sqrt (lensqr);
            if (len == 0) {
                dx += REPULSION_STRENGTH * Math.random ();
                dy += REPULSION_STRENGTH * Math.random ();
            } else if (len 

synchronized public void figureChanged (FigureChangeEvent e) {
    if (nodes != null) {
        Figure node = e.getFigure ();
        if (nodes.containsKey (node)) {
            getGraphNode (node).update ();
        }
    }
}


public void remove () {
    if (nodes != null) {
        Enumeration nodeEnum = nodes.keys ();
        while (nodeEnum.hasMoreElements ()) {
            Figure node = (Figure) nodeEnum.nextElement ();
            node.removeFigureChangeListener (this);
        }
        nodes = null;
        edges = null;
    }
}


GraphNode (Figure node) {
    this.node = node;
    update ();
}


void update () {
    Point p = node.center ();
    if (Math.abs (p.x - Math.round (x)) > 1 || Math.abs (p.y - Math.round (y)) > 1) {
        x = p.x;
        y = p.y;
    }
}


public PaletteIcon (Dimension size, Image normal, Image pressed, Image selected) {
    fSize = size;
    fNormal = normal;
    fPressed = pressed;
    fSelected = selected;
}


public Image normal () {
    return fNormal;
}


public Image pressed () {
    return fPressed;
}


public Image selected () {
    return fSelected;
}


public int getWidth () {
    return fSize.width;
}


public int getHeight () {
    return fSize.height;
}


public CommandChoice () {
    super ();
    fCommands = CollectionsFactory.current ().createList (10);
    addItemListener (this);
}


public synchronized void addItem (Command command) {
    addItem (command.name ());
    fCommands.add (command);
}


public void itemStateChanged (ItemEvent e) {
    if ((getSelectedIndex () >= 0) && (getSelectedIndex () 

public static CollectionsFactory current () {
    return factory;
}


protected static CollectionsFactory determineCollectionsFactory () {
    String jdkVersion = null;
    if (isJDK12 ()) {
        jdkVersion = "12";
    } else {
        jdkVersion = "11";
    }
    return createCollectionsFactory (jdkVersion);
}


protected static boolean isJDK12 () {
    try {
        Class.forName (JAVA_UTIL_LIST);
        return true;
    } catch (ClassNotFoundException e) {
    }
    return false;
}


protected static CollectionsFactory createCollectionsFactory (String jdkVersion) {
    try {
        Class factoryClass = Class.forName (COLLECTIONS_FACTORY_PACKAGE + jdkVersion + ".CollectionsFactoryJDK" + jdkVersion);
        return (CollectionsFactory) factoryClass.newInstance ();
    } catch (ClassNotFoundException e) {
        throw new JHotDrawRuntimeException (e);
    } catch (InstantiationException e) {
        throw new JHotDrawRuntimeException (e);
    } catch (IllegalAccessException e) {
        throw new JHotDrawRuntimeException (e);
    }
}


public CommandButton (Command command) {
    super (command.name ());
    fCommand = command;
    addActionListener (this);
}


public void actionPerformed (ActionEvent e) {
    fCommand.execute ();
    if (! getLabel ().equals (fCommand.name ())) {
        setLabel (fCommand.name ());
    }
}


public ReverseVectorEnumerator (Vector v) {
    vector = v;
    count = vector.size () - 1;
}


public boolean hasMoreElements () {
    return count >= 0;
}


public Object nextElement () {
    if (count >= 0) {
        return vector.elementAt (count --);
    }
    throw new NoSuchElementException ("ReverseVectorEnumerator");
}


public Iconkit (Component component) {
    fMap = new Hashtable (53);
    fRegisteredImages = CollectionsFactory.current ().createList (10);
    fComponent = component;
    fgIconkit = this;
}


public static Iconkit instance () {
    return fgIconkit;
}


public void loadRegisteredImages (Component component) {
    if (fRegisteredImages.size () == 0) return;

    MediaTracker tracker = new MediaTracker (component);
    Iterator iter = fRegisteredImages.iterator ();
    while (iter.hasNext ()) {
        String fileName = (String) iter.next ();
        if (basicGetImage (fileName) == null) {
            tracker.addImage (loadImage (fileName), ID);
        }
    }
    fRegisteredImages.clear ();
    try {
        tracker.waitForAll ();
    } catch (Exception e) {
    }
}


public void registerImage (String fileName) {
    fRegisteredImages.add (fileName);
}


public Image registerAndLoadImage (Component component, String fileName) {
    registerImage (fileName);
    loadRegisteredImages (component);
    return getImage (fileName);
}


public Image loadImage (String filename) {
    if (fMap.containsKey (filename)) {
        return (Image) fMap.get (filename);
    }
    Image image = loadImageResource (filename);
    if (image != null) {
        fMap.put (filename, image);
    }
    return image;
}


public Image loadImage (String filename, boolean waitForLoad) {
    Image image = loadImage (filename);
    if (image != null && waitForLoad) {
        ImageIcon icon = new ImageIcon (image);
        image = icon.getImage ();
    }
    return image;
}


public Image loadImageResource (String resourcename) {
    Toolkit toolkit = Toolkit.getDefaultToolkit ();
    try {
        URL url = getClass ().getResource (resourcename);
        if (fgDebug) {
            System.out.println (resourcename);
        }
        return toolkit.createImage ((ImageProducer) url.getContent ());
    } catch (Exception ex) {
        return null;
    }
}


public Image getImage (String filename) {
    Image image = basicGetImage (filename);
    if (image != null) {
        return image;
    }
    loadRegisteredImages (fComponent);
    return basicGetImage (filename);
}


private Image basicGetImage (String filename) {
    if (fMap.containsKey (filename)) {
        return (Image) fMap.get (filename);
    }
    return null;
}


public Filler (int width, int height) {
    this (width, height, null);
}


public Filler (int width, int height, Color background) {
    fWidth = width;
    fHeight = height;
    fBackground = background;
}


public Dimension getMinimumSize () {
    return new Dimension (fWidth, fHeight);
}


public Dimension getPreferredSize () {
    return getMinimumSize ();
}


public Color getBackground () {
    if (fBackground != null) {
        return fBackground;
    }
    return super.getBackground ();
}


public RedoCommand (String name, DrawingEditor newDrawingEditor) {
    super (name, newDrawingEditor);
}


public void execute () {
    super.execute ();
    UndoManager um = getDrawingEditor ().getUndoManager ();
    if ((um == null) || ! um.isRedoable ()) {
        return;
    }
    Undoable lastRedoable = um.popRedo ();
    boolean hasBeenUndone = lastRedoable.redo ();
    if (hasBeenUndone && lastRedoable.isUndoable ()) {
        um.pushUndo (lastRedoable);
    }
    lastRedoable.getDrawingView ().checkDamage ();
    getDrawingEditor ().figureSelectionChanged (lastRedoable.getDrawingView ());
}


public boolean isExecutableWithView () {
    UndoManager um = getDrawingEditor ().getUndoManager ();
    if ((um != null) && (um.getRedoSize () > 0)) {
        return true;
    }
    return false;
}


public CommandMenu (String name) {
    super (name);
    hm = new HashMap ();
}


public synchronized void add (Command command) {
    addMenuItem (command, new JMenuItem (command.name ()));
}


public synchronized void add (Command command, MenuShortcut shortcut) {
    addMenuItem (command, new JMenuItem (command.name (), shortcut.getKey ()));
}


public synchronized void addCheckItem (Command command) {
    addMenuItem (command, new JCheckBoxMenuItem (command.name ()));
}


protected void addMenuItem (Command command, JMenuItem m) {
    m.setName (command.name ());
    m.addActionListener (this);
    add (m);
    command.addCommandListener (this);
    hm.put (m, command);
}


public synchronized void remove (Command command) {
    throw new JHotDrawRuntimeException ("not implemented");
}


public synchronized void remove (MenuItem item) {
    throw new JHotDrawRuntimeException ("not implemented");
}


public synchronized void enable (String name, boolean state) {
    for (int i = 0;
    i 

public synchronized void checkEnabled () {
    for (int i = 0;
    i 

public void actionPerformed (ActionEvent e) {
    Object source = e.getSource ();
    for (int i = 0;
    i 

public void commandExecuted (EventObject commandEvent) {
}


public void commandExecutable (EventObject commandEvent) {
}


public void commandNotExecutable (EventObject commandEvent) {
}


public SerializationStorageFormat () {
    super ();
}


protected String createFileExtension () {
    return "ser";
}


public String createFileDescription () {
    return "Serialization (" + getFileExtension () + ")";
}


public String store (String fileName, Drawing saveDrawing) throws IOException {
    FileOutputStream stream = new FileOutputStream (adjustFileName (fileName));
    ObjectOutput output = new ObjectOutputStream (stream);
    output.writeObject (saveDrawing);
    output.close ();
    return adjustFileName (fileName);
}


public Drawing restore (String fileName) throws IOException {
    try {
        FileInputStream stream = new FileInputStream (fileName);
        ObjectInput input = new ObjectInputStream (stream);
        return (Drawing) input.readObject ();
    } catch (ClassNotFoundException exception) {
        throw new IOException ("Could not restore drawing '" + fileName + "': class not found!");
    }
}


static public Clipboard getClipboard () {
    return fgClipboard;
}


private Clipboard () {
}


public void setContents (Object contents) {
    fContents = contents;
}


public Object getContents () {
    return fContents;
}


public StandardStorageFormat () {
    setFileExtension (createFileExtension ());
    setFileDescription (createFileDescription ());
    setFileFilter (createFileFilter ());
}


protected String createFileExtension () {
    return myFileExtension = "draw";
}


public void setFileExtension (String newFileExtension) {
    myFileExtension = newFileExtension;
}


public String getFileExtension () {
    return myFileExtension;
}


public String createFileDescription () {
    return "Internal Format (" + getFileExtension () + ")";
}


public void setFileDescription (String newFileDescription) {
    myFileDescription = newFileDescription;
}


public String getFileDescription () {
    return myFileDescription;
}


protected FileFilter createFileFilter () {
    return new FileFilter () {
        public boolean accept (File checkFile) {
            if (checkFile.isDirectory ()) {
                return true;
            } else {
                return checkFile.getName ().endsWith ("." + myFileExtension);
            }
        } public String getDescription () {
            return getFileDescription ();
        }}

    ;
}


public boolean accept (File checkFile) {
    if (checkFile.isDirectory ()) {
        return true;
    } else {
        return checkFile.getName ().endsWith ("." + myFileExtension);
    }
}


public String getDescription () {
    return getFileDescription ();
}


public void setFileFilter (FileFilter newFileFilter) {
    myFileFilter = newFileFilter;
}


public FileFilter getFileFilter () {
    return myFileFilter;
}


public String store (String fileName, Drawing saveDrawing) throws IOException {
    FileOutputStream stream = new FileOutputStream (adjustFileName (fileName));
    StorableOutput output = new StorableOutput (stream);
    output.writeStorable (saveDrawing);
    output.close ();
    return adjustFileName (fileName);
}


public Drawing restore (String fileName) throws IOException {
    if (! hasCorrectFileExtension (fileName)) {
        return null;
    } else {
        FileInputStream stream = new FileInputStream (fileName);
        StorableInput input = new StorableInput (stream);
        return (Drawing) input.readStorable ();
    }
}


public boolean equals (Object compareObject) {
    if (compareObject instanceof StandardStorageFormat) {
        return getFileExtension ().equals (((StandardStorageFormat) compareObject).getFileExtension ());
    } else {
        return false;
    }
}


protected String adjustFileName (String testFileName) {
    if (! hasCorrectFileExtension (testFileName)) {
        return testFileName + "." + getFileExtension ();
    } else {
        return testFileName;
    }
}


protected boolean hasCorrectFileExtension (String testFileName) {
    return testFileName.endsWith ("." + getFileExtension ());
}


public StorageFormatManager () {
    myStorageFormats = CollectionsFactory.current ().createList ();
}


public void addStorageFormat (StorageFormat newStorageFormat) {
    myStorageFormats.add (newStorageFormat);
}


public void removeStorageFormat (StorageFormat oldStorageFormat) {
    myStorageFormats.remove (oldStorageFormat);
}


public boolean containsStorageFormat (StorageFormat checkStorageFormat) {
    return myStorageFormats.contains (checkStorageFormat);
}


public void setDefaultStorageFormat (StorageFormat newDefaultStorageFormat) {
    myDefaultStorageFormat = newDefaultStorageFormat;
}


public StorageFormat getDefaultStorageFormat () {
    return myDefaultStorageFormat;
}


public void registerFileFilters (JFileChooser fileChooser) {
    Iterator formatsIterator = myStorageFormats.iterator ();
    while (formatsIterator.hasNext ()) {
        fileChooser.addChoosableFileFilter (((StorageFormat) formatsIterator.next ()).getFileFilter ());
    }
    if (getDefaultStorageFormat () != null) {
        fileChooser.setFileFilter (getDefaultStorageFormat ().getFileFilter ());
    }
}


public StorageFormat findStorageFormat (FileFilter findFileFilter) {
    Iterator formatsIterator = myStorageFormats.iterator ();
    StorageFormat currentStorageFormat = null;
    while (formatsIterator.hasNext ()) {
        currentStorageFormat = (StorageFormat) formatsIterator.next ();
        if (currentStorageFormat.getFileFilter ().equals (findFileFilter)) {
            return currentStorageFormat;
        }
    }
    return null;
}


public PaletteButton (PaletteListener listener) {
    fListener = listener;
    fState = fOldState = NORMAL;
    addMouseListener (this);
    addMouseMotionListener (this);
}


public Object value () {
    return null;
}


public String name () {
    return "";
}


public void reset () {
    if (isEnabled ()) {
        fState = NORMAL;
        setSelected (false);
        repaint ();
    }
}


public void select () {
    if (isEnabled ()) {
        fState = SELECTED;
        setSelected (true);
        repaint ();
    }
}


public void mousePressed (MouseEvent e) {
    if (isEnabled ()) {
        fOldState = fState;
        fState = PRESSED;
        repaint ();
    }
}


public void mouseDragged (MouseEvent e) {
    if (isEnabled ()) {
        if (contains (e.getX (), e.getY ())) {
            fState = PRESSED;
        } else {
            fState = fOldState;
        }
        repaint ();
    }
}


public void mouseReleased (MouseEvent e) {
    if (isEnabled ()) {
        fState = fOldState;
        repaint ();
        if (contains (e.getX (), e.getY ())) {
            fListener.paletteUserSelected (this);
        }
    }
}


public void mouseMoved (MouseEvent e) {
    fListener.paletteUserOver (this, true);
}


public void mouseExited (MouseEvent e) {
    if (fState == PRESSED) {
        mouseDragged (e);
    }
    fListener.paletteUserOver (this, false);
}


public void mouseClicked (MouseEvent e) {
}


public void mouseEntered (MouseEvent e) {
}


public StandardVersionControlStrategy (VersionRequester newVersionRequester) {
    setVersionRequester (newVersionRequester);
}


public void assertCompatibleVersion () {
    String [] requiredVersions = getVersionRequester ().getRequiredVersions ();
    if (requiredVersions.length == 0) {
        return;
    }
    for (int i = 0;
    i 

protected void handleIncompatibleVersions () {
    String [] requiredVersions = getVersionRequester ().getRequiredVersions ();
    StringBuffer expectedVersions = new StringBuffer ("[");
    for (int i = 0;
    i  0) {
        expectedVersions.append (requiredVersions [requiredVersions.length - 1]);
    }
    expectedVersions.append ("]");
    throw new JHotDrawRuntimeException ("Incompatible version of JHotDraw found: " + VersionManagement.getJHotDrawVersion () + " (expected: " + expectedVersions + ")");
}


protected boolean isCompatibleVersion (String compareVersionString) {
    return VersionManagement.isCompatibleVersion (compareVersionString);
}


private void setVersionRequester (VersionRequester newVersionRequester) {
    myVersionRequester = newVersionRequester;
}


protected VersionRequester getVersionRequester () {
    return myVersionRequester;
}


public FloatingTextField () {
    fEditWidget = new JTextField (20);
}


public void createOverlay (Container container) {
    createOverlay (container, null);
}


public void createOverlay (Container container, Font font) {
    container.add (fEditWidget, 0);
    if (font != null) {
        fEditWidget.setFont (font);
    }
    fContainer = container;
}


public void addActionListener (ActionListener listener) {
    fEditWidget.addActionListener (listener);
}


public void removeActionListener (ActionListener listener) {
    fEditWidget.removeActionListener (listener);
}


public void setBounds (Rectangle r, String text) {
    fEditWidget.setText (text);
    fEditWidget.setBounds (r.x, r.y, r.width, r.height);
    fEditWidget.setVisible (true);
    fEditWidget.selectAll ();
    fEditWidget.requestFocus ();
}


public String getText () {
    return fEditWidget.getText ();
}


public Dimension getPreferredSize (int cols) {
    fEditWidget.setColumns (cols);
    return fEditWidget.getPreferredSize ();
}


public void endOverlay () {
    fContainer.requestFocus ();
    if (fEditWidget != null) {
        fEditWidget.setVisible (false);
        fContainer.remove (fEditWidget);
        Rectangle bounds = fEditWidget.getBounds ();
        fContainer.repaint (bounds.x, bounds.y, bounds.width, bounds.height);
    }
}


public static String getJHotDrawVersion () {
    Package pack = packages [4];
    return pack.getSpecificationVersion ();
}


public static String getPackageVersion (final Package lookupPackage) {
    if (lookupPackage == null) {
        return null;
    }
    String specVersion = lookupPackage.getSpecificationVersion ();
    if (specVersion != null) {
        return specVersion;
    } else {
        String normalizedPackageName = normalizePackageName (lookupPackage.getName ());
        String nextPackageName = getNextPackage (normalizedPackageName);
        return getPackageVersion (Package.getPackage (nextPackageName));
    }
}


public static boolean isCompatibleVersion (String compareVersionString) {
    Package pack = packages [4];
    if (compareVersionString == null) {
        return pack.getSpecificationVersion () == null;
    } else {
        return pack.isCompatibleWith (compareVersionString);
    }
}


public static String readVersionFromFile (String applicationName, String versionFileName) {
    try {
        FileInputStream fileInput = new FileInputStream (versionFileName);
        Manifest manifest = new Manifest ();
        manifest.read (fileInput);
        Map entries = manifest.getEntries ();
        Iterator entryIterator = entries.entrySet ().iterator ();
        while (entryIterator.hasNext ()) {
            Map.Entry currentEntry = (Map.Entry) entryIterator.next ();
            String packageName = currentEntry.getKey ().toString ();
            packageName = normalizePackageName (packageName);
            Attributes attributes = (Attributes) currentEntry.getValue ();
            String packageSpecVersion = attributes.getValue (Attributes.Name.SPECIFICATION_VERSION);
            packageSpecVersion = extractVersionInfo (packageSpecVersion);
            return packageSpecVersion;
        }
    } catch (IOException exception) {
        exception.printStackTrace ();
    }
    return null;
}


protected static String getNextPackage (String searchPackage) {
    if (searchPackage == null) {
        return null;
    }
    int foundNextPackage = searchPackage.lastIndexOf ('.');
    if (foundNextPackage > 0) {
        return searchPackage.substring (0, foundNextPackage);
    } else {
        return null;
    }
}


public static String normalizePackageName (String toBeNormalized) {
    String replaced = toBeNormalized.replace ('/', '.');
    replaced = replaced.replace (File.pathSeparatorChar, '.');
    if (replaced.endsWith (".")) {
        int lastSeparator = replaced.lastIndexOf ('.');
        return replaced.substring (0, lastSeparator);
    } else {
        return replaced;
    }
}


public static String extractVersionInfo (String versionString) {
    if (versionString == null) {
        return null;
    }
    if (versionString.length () == 0) {
        return "";
    }
    int startIndex = versionString.indexOf ("\"");
    if (startIndex 

public UndoableAdapter (DrawingView newDrawingView) {
    setDrawingView (newDrawingView);
}


public boolean undo () {
    return isUndoable ();
}


public boolean redo () {
    return isRedoable ();
}


public boolean isUndoable () {
    return myIsUndoable;
}


public void setUndoable (boolean newIsUndoable) {
    myIsUndoable = newIsUndoable;
}


public boolean isRedoable () {
    return myIsRedoable;
}


public void setRedoable (boolean newIsRedoable) {
    myIsRedoable = newIsRedoable;
}


public void setAffectedFigures (FigureEnumeration newAffectedFigures) {
    rememberFigures (newAffectedFigures);
}


public FigureEnumeration getAffectedFigures () {
    return new FigureEnumerator (CollectionsFactory.current ().createList (myAffectedFigures));
}


public int getAffectedFiguresCount () {
    return myAffectedFigures.size ();
}


protected void rememberFigures (FigureEnumeration toBeRemembered) {
    myAffectedFigures = CollectionsFactory.current ().createList ();
    while (toBeRemembered.hasNextFigure ()) {
        myAffectedFigures.add (toBeRemembered.nextFigure ());
    }
}


public void release () {
    FigureEnumeration fe = getAffectedFigures ();
    while (fe.hasNextFigure ()) {
        fe.nextFigure ().release ();
    }
    setAffectedFigures (FigureEnumerator.getEmptyEnumeration ());
}


protected void duplicateAffectedFigures () {
    setAffectedFigures (StandardFigureSelection.duplicateFigures (getAffectedFigures (), getAffectedFiguresCount ()));
}


public DrawingView getDrawingView () {
    return myDrawingView;
}


protected void setDrawingView (DrawingView newDrawingView) {
    myDrawingView = newDrawingView;
}


ColorEntry (String name, Color color) {
    fColor = color;
    fName = name;
}


public static int size () {
    return fMap.length;
}


public static Color color (int index) {
    if (index = 0) {
        return fMap [index].fColor;
    }
    throw new ArrayIndexOutOfBoundsException ("Color index: " + index);
}


public static Color color (String name) {
    for (int i = 0;
    i 

public static String name (int index) {
    if (index = 0) {
        return fMap [index].fName;
    }
    throw new ArrayIndexOutOfBoundsException ("Color index: " + index);
}


public static int colorIndex (Color color) {
    for (int i = 0;
    i 

public static boolean isTransparent (Color color) {
    return color.equals (color ("None"));
}


protected UndoRedoActivity (Undoable newReversedActivity) {
    setReversedActivity (newReversedActivity);
}


public boolean undo () {
    if (isRedoable ()) {
        return getReversedActivity ().redo ();
    }
    return false;
}


public boolean redo () {
    if (isUndoable ()) {
        return getReversedActivity ().undo ();
    }
    return false;
}


public boolean isUndoable () {
    return getReversedActivity ().isRedoable ();
}


public void setUndoable (boolean newIsUndoable) {
    getReversedActivity ().setRedoable (newIsUndoable);
}


public boolean isRedoable () {
    return getReversedActivity ().isUndoable ();
}


public void setRedoable (boolean newIsRedoable) {
    getReversedActivity ().setUndoable (newIsRedoable);
}


public void setAffectedFigures (FigureEnumeration newAffectedFigures) {
    getReversedActivity ().setAffectedFigures (newAffectedFigures);
}


public FigureEnumeration getAffectedFigures () {
    return getReversedActivity ().getAffectedFigures ();
}


public int getAffectedFiguresCount () {
    return getReversedActivity ().getAffectedFiguresCount ();
}


public DrawingView getDrawingView () {
    return getReversedActivity ().getDrawingView ();
}


public void release () {
    getReversedActivity ().release ();
}


protected void setReversedActivity (Undoable newReversedActivity) {
    myReversedActivity = newReversedActivity;
}


public Undoable getReversedActivity () {
    return myReversedActivity;
}


public static Undoable createUndoRedoActivity (Undoable toBeReversed) {
    if (toBeReversed instanceof UndoRedoActivity) {
        return ((UndoRedoActivity) toBeReversed).getReversedActivity ();
    } else {
        return new UndoRedoActivity (toBeReversed);
    }
}


public CollectionsFactoryJDK12 () {
}


public List createList () {
    return new ArrayList ();
}


public List createList (Collection initList) {
    return new ArrayList (initList);
}


public List createList (int initSize) {
    return new ArrayList (initSize);
}


public Map createMap () {
    return new Hashtable ();
}


public Map createMap (Map initMap) {
    return new Hashtable (initMap);
}


public Set createSet () {
    return new HashSet ();
}


public Set createSet (Set initSet) {
    return new HashSet (initSet);
}


public ListWrapper () {
    myDelegee = new Vector ();
}


public ListWrapper (int initialSize) {
    myDelegee = new Vector (initialSize);
}


public ListWrapper (Collection copyCollection) {
    myDelegee = new Vector (copyCollection);
}


public int size () {
    return myDelegee.size ();
}


public boolean isEmpty () {
    return myDelegee.isEmpty ();
}


public boolean contains (Object o) {
    return myDelegee.contains (o);
}


public Iterator iterator () {
    return new IteratorWrapper (myDelegee.elements ());
}


public Object [] toArray () {
    return myDelegee.toArray ();
}


public Object [] toArray (Object a []) {
    return myDelegee.toArray (a);
}


public boolean add (Object o) {
    return myDelegee.add (o);
}


public boolean remove (Object o) {
    return myDelegee.removeElement (o);
}


public boolean containsAll (Collection c) {
    return myDelegee.containsAll (c);
}


public boolean addAll (Collection c) {
    return myDelegee.addAll (c);
}


public boolean addAll (int index, Collection c) {
    return myDelegee.addAll (index, c);
}


public boolean removeAll (Collection c) {
    return myDelegee.removeAll (c);
}


public boolean retainAll (Collection c) {
    return myDelegee.retainAll (c);
}


public void clear () {
    myDelegee.clear ();
}


public Object get (int index) {
    return myDelegee.elementAt (index);
}


public Object set (int index, Object element) {
    return myDelegee.set (index, element);
}


public void add (int index, Object element) {
    myDelegee.add (index, element);
}


public Object remove (int index) {
    return myDelegee.remove (index);
}


public int indexOf (Object o) {
    return myDelegee.indexOf (o);
}


public int lastIndexOf (Object o) {
    return myDelegee.lastIndexOf (o);
}


public ListIterator listIterator () {
    return myDelegee.listIterator ();
}


public ListIterator listIterator (int index) {
    return myDelegee.listIterator (index);
}


public List subList (int fromIndex, int toIndex) {
    return null;
}


public IteratorWrapper (Enumeration enumeration) {
    myEnumeration = enumeration;
}


public boolean hasNext () {
    return myEnumeration.hasMoreElements ();
}


public Object next () {
    return myEnumeration.nextElement ();
}


public void remove () {
}


public SetWrapper () {
    myDelegee = new Hashtable ();
}


public SetWrapper (Set initSet) {
    myDelegee = new Hashtable ();
    Iterator iter = initSet.iterator ();
    while (iter.hasNext ()) {
        add (iter.next ());
    }
}


public int size () {
    return myDelegee.size ();
}


public boolean isEmpty () {
    return myDelegee.isEmpty ();
}


public boolean contains (Object o) {
    return myDelegee.containsKey (o);
}


public Iterator iterator () {
    return new IteratorWrapper (myDelegee.elements ());
}


public Object [] toArray () {
    return new Object [0];
}


public Object [] toArray (Object a []) {
    return new Object [0];
}


public boolean add (Object o) {
    return myDelegee.put (o, o) == null;
}


public boolean remove (Object o) {
    return myDelegee.remove (o) != null;
}


public boolean containsAll (Collection c) {
    return false;
}


public boolean addAll (Collection c) {
    return false;
}


public boolean retainAll (Collection c) {
    return false;
}


public boolean removeAll (Collection c) {
    return false;
}


public void clear () {
    myDelegee.clear ();
}


public MapWrapper () {
    myDelegee = new Hashtable ();
}


public MapWrapper (Map copyMap) {
    myDelegee = new Hashtable (copyMap);
}


public int size () {
    return myDelegee.size ();
}


public boolean isEmpty () {
    return myDelegee.isEmpty ();
}


public boolean containsKey (Object key) {
    return myDelegee.containsKey (key);
}


public boolean containsValue (Object value) {
    return myDelegee.containsKey (value);
}


public Object get (Object key) {
    return myDelegee.get (key);
}


public Object put (Object key, Object value) {
    return myDelegee.put (key, value);
}


public Object remove (Object key) {
    return myDelegee.remove (key);
}


public void putAll (Map t) {
    myDelegee.putAll (t);
}


public void clear () {
    myDelegee.clear ();
}


public Set keySet () {
    return myDelegee.keySet ();
}


public Collection values () {
    return myDelegee.values ();
}


public Set entrySet () {
    return myDelegee.entrySet ();
}


public CollectionsFactoryJDK11 () {
}


public List createList () {
    return new ListWrapper ();
}


public List createList (Collection initList) {
    return new ListWrapper (initList);
}


public List createList (int initSize) {
    return new ListWrapper (initSize);
}


public Map createMap () {
    return new MapWrapper ();
}


public Map createMap (Map initMap) {
    return new MapWrapper (initMap);
}


public Set createSet () {
    return new SetWrapper ();
}


public Set createSet (Set initSet) {
    return new SetWrapper (initSet);
}


public ReverseListEnumerator (List l) {
    myList = l;
    count = myList.size () - 1;
}


public boolean hasNext () {
    return count >= 0;
}


public Object next () {
    if (count >= 0) {
        return myList.get (count --);
    }
    throw new NoSuchElementException ("ReverseListEnumerator");
}


public void remove () {
    myList.remove (count);
    count --;
}


public StorableOutput (OutputStream stream) {
    fStream = new PrintWriter (stream);
    fMap = CollectionsFactory.current ().createList ();
    fIndent = 0;
}


public void writeStorable (Storable storable) {
    if (storable == null) {
        fStream.print ("NULL");
        space ();
        return;
    }
    if (mapped (storable)) {
        writeRef (storable);
        return;
    }
    incrementIndent ();
    startNewLine ();
    map (storable);
    fStream.print (storable.getClass ().getName ());
    space ();
    storable.write (this);
    space ();
    decrementIndent ();
}


public void writeInt (int i) {
    fStream.print (i);
    space ();
}


public void writeLong (long l) {
    fStream.print (l);
    space ();
}


public void writeColor (Color c) {
    writeInt (c.getRed ());
    writeInt (c.getGreen ());
    writeInt (c.getBlue ());
}


public void writeDouble (double d) {
    fStream.print (d);
    space ();
}


public void writeBoolean (boolean b) {
    if (b) {
        fStream.print (1);
    } else {
        fStream.print (0);
    }
    space ();
}


public void writeString (String s) {
    fStream.print ('"');
    for (int i = 0;
    i 

public void close () {
    fStream.close ();
}


private boolean mapped (Storable storable) {
    return fMap.contains (storable);
}


private void map (Storable storable) {
    if (! fMap.contains (storable)) {
        fMap.add (storable);
    }
}


private void writeRef (Storable storable) {
    int ref = fMap.indexOf (storable);
    fStream.print ("REF");
    space ();
    fStream.print (ref);
    space ();
}


private void incrementIndent () {
    fIndent += 4;
}


private void decrementIndent () {
    fIndent -= 4;
    if (fIndent 

private void startNewLine () {
    fStream.println ();
    for (int i = 0;
    i 

private void space () {
    fStream.print (' ');
}


private Geom () {
}


static public boolean lineContainsPoint (int x1, int y1, int x2, int y2, int px, int py) {
    Rectangle r = new Rectangle (new Point (x1, y1));
    r.add (x2, y2);
    r.grow (2, 2);
    if (! r.contains (px, py)) {
        return false;
    }
    double a, b, x, y;
    if (x1 == x2) {
        return (Math.abs (px - x1) 

static public int direction (int x1, int y1, int x2, int y2) {
    int direction = 0;
    int vx = x2 - x1;
    int vy = y2 - y1;
    if (vy  - vy) {
        direction = EAST;
    } else if (vy > vx && vy > - vx) {
        direction = NORTH;
    } else if (vx 

static public Point south (Rectangle r) {
    return new Point (r.x + r.width / 2, r.y + r.height);
}


static public Point center (Rectangle r) {
    return new Point (r.x + r.width / 2, r.y + r.height / 2);
}


static public Point west (Rectangle r) {
    return new Point (r.x, r.y + r.height / 2);
}


static public Point east (Rectangle r) {
    return new Point (r.x + r.width, r.y + r.height / 2);
}


static public Point north (Rectangle r) {
    return new Point (r.x + r.width / 2, r.y);
}


public static Point corner (Rectangle r) {
    return new Point ((int) r.getMaxX (), (int) r.getMaxY ());
}


public static Point topLeftCorner (Rectangle r) {
    return r.getLocation ();
}


public static Point topRightCorner (Rectangle r) {
    return new Point ((int) r.getMaxX (), (int) r.getMinY ());
}


public static Point bottomLeftCorner (Rectangle r) {
    return new Point ((int) r.getMinX (), (int) r.getMaxY ());
}


public static Point bottomRightCorner (Rectangle r) {
    return corner (r);
}


static public int range (int min, int max, int value) {
    if (value  max) {
        value = max;
    }
    return value;
}


static public long length2 (int x1, int y1, int x2, int y2) {
    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
}


static public long length (int x1, int y1, int x2, int y2) {
    return (long) Math.sqrt (length2 (x1, y1, x2, y2));
}


static public double pointToAngle (Rectangle r, Point p) {
    int px = p.x - (r.x + r.width / 2);
    int py = p.y - (r.y + r.height / 2);
    return Math.atan2 (py * r.width, px * r.height);
}


static public Point angleToPoint (Rectangle r, double angle) {
    double si = Math.sin (angle);
    double co = Math.cos (angle);
    double e = 0.0001;
    int x = 0, y = 0;
    if (Math.abs (si) > e) {
        x = (int) ((1.0 + co / Math.abs (si)) / 2.0 * r.width);
        x = range (0, r.width, x);
    } else if (co >= 0.0) {
        x = r.width;
    }

    if (Math.abs (co) > e) {
        y = (int) ((1.0 + si / Math.abs (co)) / 2.0 * r.height);
        y = range (0, r.height, y);
    } else if (si >= 0.0) {
        y = r.height;
    }

    return new Point (r.x + x, r.y + y);
}


static public Point polarToPoint (double angle, double fx, double fy) {
    double si = Math.sin (angle);
    double co = Math.cos (angle);
    return new Point ((int) (fx * co + 0.5), (int) (fy * si + 0.5));
}


static public Point ovalAngleToPoint (Rectangle r, double angle) {
    Point center = Geom.center (r);
    Point p = Geom.polarToPoint (angle, r.width / 2, r.height / 2);
    return new Point (center.x + p.x, center.y + p.y);
}


static public Point intersect (int xa, int ya, int xb, int yb, int xc, int yc, int xd, int yd) {
    double denom = ((xb - xa) * (yd - yc) - (yb - ya) * (xd - xc));
    double rnum = ((ya - yc) * (xd - xc) - (xa - xc) * (yd - yc));
    if (denom == 0.0) {
        if (rnum == 0.0) {
            if ((xa  xb && (xb > xc || xb > xd))) {
                return new Point (xb, yb);
            } else {
                return new Point (xa, ya);
            }
        } else {
            return null;
        }
    }
    double r = rnum / denom;
    double snum = ((ya - yc) * (xb - xa) - (xa - xc) * (yb - ya));
    double s = snum / denom;
    if (0.0 

public static double distanceFromLine (int xa, int ya, int xb, int yb, int xc, int yc) {
    int xdiff = xb - xa;
    int ydiff = yb - ya;
    long l2 = xdiff * xdiff + ydiff * ydiff;
    if (l2 == 0) {
        return Geom.length (xa, ya, xc, yc);
    }
    double rnum = (ya - yc) * (ya - yb) - (xa - xc) * (xb - xa);
    double r = rnum / l2;
    if (r  1.0) {
        return Double.MAX_VALUE;
    }
    double xi = xa + r * xdiff;
    double yi = ya + r * ydiff;
    double xd = xc - xi;
    double yd = yc - yi;
    return Math.sqrt (xd * xd + yd * yd);
}


public static double distanceFromLine2D (int xa, int ya, int xb, int yb, int xc, int yc) {
    Line2D.Double line = new Line2D.Double (xa, xb, ya, yb);
    return line.ptSegDist (xc, yc);
}


public UndoableHandle (Handle newWrappedHandle, DrawingView newDrawingView) {
    setWrappedHandle (newWrappedHandle);
    setDrawingView (newDrawingView);
}


public Point locate () {
    return getWrappedHandle ().locate ();
}


public void invokeStart (int x, int y, Drawing drawing) {
    getWrappedHandle ().invokeStart (x, y, drawing);
}


public void invokeStart (int x, int y, DrawingView view) {
    getWrappedHandle ().invokeStart (x, y, view);
}


public void invokeStep (int dx, int dy, Drawing drawing) {
    getWrappedHandle ().invokeStep (dx, dy, drawing);
}


public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
    getWrappedHandle ().invokeStep (x, y, anchorX, anchorY, view);
}


public void invokeEnd (int x, int y, int anchorX, int anchorY, DrawingView view) {
    getWrappedHandle ().invokeEnd (x, y, anchorX, anchorY, view);
    Undoable undoableActivity = getWrappedHandle ().getUndoActivity ();
    if ((undoableActivity != null) && (undoableActivity.isUndoable ())) {
        getDrawingView ().editor ().getUndoManager ().pushUndo (undoableActivity);
        getDrawingView ().editor ().getUndoManager ().clearRedos ();
    }
}


public void invokeEnd (int dx, int dy, Drawing drawing) {
    getWrappedHandle ().invokeEnd (dx, dy, drawing);
}


public Figure owner () {
    return getWrappedHandle ().owner ();
}


public Rectangle displayBox () {
    return getWrappedHandle ().displayBox ();
}


public boolean containsPoint (int x, int y) {
    return getWrappedHandle ().containsPoint (x, y);
}


public void draw (Graphics g) {
    getWrappedHandle ().draw (g);
}


protected void setWrappedHandle (Handle newWrappedHandle) {
    myWrappedHandle = newWrappedHandle;
}


protected Handle getWrappedHandle () {
    return myWrappedHandle;
}


public DrawingView getDrawingView () {
    return myDrawingView;
}


protected void setDrawingView (DrawingView newDrawingView) {
    myDrawingView = newDrawingView;
}


public Undoable getUndoActivity () {
    return new UndoableAdapter (getDrawingView ());
}


public void setUndoActivity (Undoable newUndoableActivity) {
}


public UndoManager () {
    this (DEFAULT_BUFFER_SIZE);
}


public UndoManager (int newUndoStackSize) {
    maxStackCapacity = newUndoStackSize;
    undoStack = CollectionsFactory.current ().createList (maxStackCapacity);
    redoStack = CollectionsFactory.current ().createList (maxStackCapacity);
}


public void pushUndo (Undoable undoActivity) {
    if (undoActivity.isUndoable ()) {
        removeFirstElementInFullList (undoStack);
        undoStack.add (undoActivity);
    } else {
        undoStack = CollectionsFactory.current ().createList (maxStackCapacity);
    }
}


public void pushRedo (Undoable redoActivity) {
    if (redoActivity.isRedoable ()) {
        removeFirstElementInFullList (redoStack);
        if ((getRedoSize () == 0) || (peekRedo () != redoActivity)) {
            redoStack.add (redoActivity);
        }
    } else {
        redoStack = CollectionsFactory.current ().createList (maxStackCapacity);
    }
}


private void removeFirstElementInFullList (List l) {
    if (l.size () >= maxStackCapacity) {
        Undoable removedActivity = (Undoable) l.remove (0);
        removedActivity.release ();
    }
}


private Undoable getLastElement (List l) {
    if (l.size () > 0) {
        return (Undoable) l.get (l.size () - 1);
    } else {
        return null;
    }
}


public boolean isUndoable () {
    if (getUndoSize () > 0) {
        return getLastElement (undoStack).isUndoable ();
    } else {
        return false;
    }
}


public boolean isRedoable () {
    if (getRedoSize () > 0) {
        return getLastElement (redoStack).isRedoable ();
    } else {
        return false;
    }
}


protected Undoable peekUndo () {
    if (getUndoSize () > 0) {
        return getLastElement (undoStack);
    } else {
        return null;
    }
}


protected Undoable peekRedo () {
    if (getRedoSize () > 0) {
        return getLastElement (redoStack);
    } else {
        return null;
    }
}


public int getUndoSize () {
    return undoStack.size ();
}


public int getRedoSize () {
    return redoStack.size ();
}


public Undoable popUndo () {
    Undoable lastUndoable = peekUndo ();
    undoStack.remove (getUndoSize () - 1);
    return lastUndoable;
}


public Undoable popRedo () {
    Undoable lastUndoable = peekRedo ();
    redoStack.remove (getRedoSize () - 1);
    return lastUndoable;
}


public void clearUndos () {
    clearStack (undoStack);
}


public void clearRedos () {
    clearStack (redoStack);
}


protected void clearStack (List clearStack) {
    clearStack.clear ();
}


public void clearUndos (DrawingView checkDV) {
    Iterator iter = undoStack.iterator ();
    while (iter.hasNext ()) {
        Undoable currentUndo = (Undoable) iter.next ();
        if (currentUndo.getDrawingView () == checkDV) {
            iter.remove ();
        }
    }
}


public void clearRedos (DrawingView checkDV) {
    Iterator iter = redoStack.iterator ();
    while (iter.hasNext ()) {
        Undoable currentRedo = (Undoable) iter.next ();
        if (currentRedo.getDrawingView () == checkDV) {
            iter.remove ();
        }
    }
}


public UndoableCommand (Command newWrappedCommand) {
    setWrappedCommand (newWrappedCommand);
    getWrappedCommand ().addCommandListener (this);
    setEventDispatcher (createEventDispatcher ());
}


public void execute () {
    hasSelectionChanged = false;
    view ().addFigureSelectionListener (this);
    getWrappedCommand ().execute ();
    Undoable undoableCommand = getWrappedCommand ().getUndoActivity ();
    if ((undoableCommand != null) && (undoableCommand.isUndoable ())) {
        getDrawingEditor ().getUndoManager ().pushUndo (undoableCommand);
        getDrawingEditor ().getUndoManager ().clearRedos ();
    }
    if (! hasSelectionChanged || (getDrawingEditor ().getUndoManager ().getUndoSize () == 1)) {
        getDrawingEditor ().figureSelectionChanged (view ());
    }
    view ().removeFigureSelectionListener (this);
}


public boolean isExecutable () {
    return getWrappedCommand ().isExecutable ();
}


protected void setWrappedCommand (Command newWrappedCommand) {
    myWrappedCommand = newWrappedCommand;
}


protected Command getWrappedCommand () {
    return myWrappedCommand;
}


public String name () {
    return getWrappedCommand ().name ();
}


public DrawingEditor getDrawingEditor () {
    return getWrappedCommand ().getDrawingEditor ();
}


public DrawingView view () {
    return getDrawingEditor ().view ();
}


public void figureSelectionChanged (DrawingView view) {
    hasSelectionChanged = true;
}


public Undoable getUndoActivity () {
    return new UndoableAdapter (view ());
}


public void setUndoActivity (Undoable newUndoableActivity) {
}


public void addCommandListener (CommandListener newCommandListener) {
    getEventDispatcher ().addCommandListener (newCommandListener);
}


public void removeCommandListener (CommandListener oldCommandListener) {
    getEventDispatcher ().removeCommandListener (oldCommandListener);
}


private void setEventDispatcher (AbstractCommand.EventDispatcher newEventDispatcher) {
    myEventDispatcher = newEventDispatcher;
}


protected AbstractCommand.EventDispatcher getEventDispatcher () {
    return myEventDispatcher;
}


public AbstractCommand.EventDispatcher createEventDispatcher () {
    return new AbstractCommand.EventDispatcher (this);
}


public void commandExecuted (EventObject commandEvent) {
    getEventDispatcher ().fireCommandExecutedEvent ();
}


public void commandExecutable (EventObject commandEvent) {
    getEventDispatcher ().fireCommandExecutableEvent ();
}


public void commandNotExecutable (EventObject commandEvent) {
    getEventDispatcher ().fireCommandNotExecutableEvent ();
}


public StorableInput (InputStream stream) {
    Reader r = new BufferedReader (new InputStreamReader (stream));
    fTokenizer = new StreamTokenizer (r);
    fTokenizer.wordChars ('$', '$');
    fMap = CollectionsFactory.current ().createList ();
}


public Storable readStorable () throws IOException {
    Storable storable;
    String s = readString ();
    if (s.equals ("NULL")) {
        return null;
    }
    if (s.equals ("REF")) {
        int ref = readInt ();
        return (Storable) retrieve (ref);
    }
    storable = (Storable) makeInstance (s);
    map (storable);
    storable.read (this);
    return storable;
}


public String readString () throws IOException {
    int token = fTokenizer.nextToken ();
    if (token == StreamTokenizer.TT_WORD || token == '"') {
        return fTokenizer.sval;
    }
    String msg = "String expected in line: " + fTokenizer.lineno ();
    throw new IOException (msg);
}


public int readInt () throws IOException {
    int token = fTokenizer.nextToken ();
    if (token == StreamTokenizer.TT_NUMBER) {
        return (int) fTokenizer.nval;
    }
    String msg = "Integer expected in line: " + fTokenizer.lineno ();
    IOException exception = new IOException (msg);
    exception.printStackTrace ();
    throw new IOException (msg);
}


public long readLong () throws IOException {
    long token = fTokenizer.nextToken ();
    if (token == StreamTokenizer.TT_NUMBER) {
        return (long) fTokenizer.nval;
    }
    String msg = "Long expected in line: " + fTokenizer.lineno ();
    IOException exception = new IOException (msg);
    throw exception;
}


public Color readColor () throws IOException {
    return new Color (readInt (), readInt (), readInt ());
}


public double readDouble () throws IOException {
    int token = fTokenizer.nextToken ();
    if (token == StreamTokenizer.TT_NUMBER) {
        return fTokenizer.nval;
    }
    String msg = "Double expected in line: " + fTokenizer.lineno ();
    throw new IOException (msg);
}


public boolean readBoolean () throws IOException {
    int token = fTokenizer.nextToken ();
    if (token == StreamTokenizer.TT_NUMBER) {
        return ((int) fTokenizer.nval) == 1;
    }
    String msg = "Integer expected in line: " + fTokenizer.lineno ();
    throw new IOException (msg);
}


private Object makeInstance (String className) throws IOException {
    try {
        Class cl = Class.forName (className);
        return cl.newInstance ();
    } catch (NoSuchMethodError e) {
        throw new IOException ("Class " + className + " does not seem to have a no-arg constructor");
    } catch (ClassNotFoundException e) {
        throw new IOException ("No class: " + className);
    } catch (InstantiationException e) {
        throw new IOException ("Cannot instantiate: " + className);
    } catch (IllegalAccessException e) {
        throw new IOException ("Class (" + className + ") not accessible");
    }
}


private void map (Storable storable) {
    if (! fMap.contains (storable)) {
        fMap.add (storable);
    }
}


private Storable retrieve (int ref) {
    return (Storable) fMap.get (ref);
}


public Bounds (double x, double y) {
    _dX1 = x;
    _dX2 = x;
    _dY1 = y;
    _dY2 = y;
}


public Bounds (double x1, double y1, double x2, double y2) {
    _dX1 = Math.min (x1, x2);
    _dX2 = Math.max (x1, x2);
    _dY1 = Math.min (y1, y2);
    _dY2 = Math.max (y1, y2);
}


public Bounds (Point2D aPoint2D) {
    this (aPoint2D.getX (), aPoint2D.getY ());
}


public Bounds (Point2D firstPoint2D, Point2D secondPoint2D) {
    this (firstPoint2D.getX (), firstPoint2D.getY (), secondPoint2D.getX (), secondPoint2D.getY ());
}


public Bounds (Bounds aBounds) {
    this (aBounds.getLesserX (), aBounds.getLesserY (), aBounds.getGreaterX (), aBounds.getGreaterY ());
}


public Bounds (Rectangle2D aRectangle2D) {
    _dX1 = aRectangle2D.getMinX ();
    _dX2 = aRectangle2D.getMaxX ();
    _dY1 = aRectangle2D.getMinY ();
    _dY2 = aRectangle2D.getMaxY ();
}


public Bounds (Point2D centerPoint2D, double dWidth, double dHeight) {
    _dX1 = centerPoint2D.getX () - (dWidth / 2.0);
    _dX2 = centerPoint2D.getX () + (dWidth / 2.0);
    _dY1 = centerPoint2D.getY () - (dHeight / 2.0);
    _dY2 = centerPoint2D.getY () + (dHeight / 2.0);
}


public Bounds (Dimension aDimension) {
    this (0, 0, aDimension.width, aDimension.height);
}


protected Bounds () {
}


public double getLesserX () {
    return _dX1;
}


public double getGreaterX () {
    return _dX2;
}


public double getLesserY () {
    return _dY1;
}


public double getGreaterY () {
    return _dY2;
}


public double getWest () {
    return _dX1;
}


public double getEast () {
    return _dX2;
}


public double getSouth () {
    return _dY1;
}


public double getNorth () {
    return _dY2;
}


public double getWidth () {
    return _dX2 - _dX1;
}


public double getHeight () {
    return _dY2 - _dY1;
}


public Rectangle2D asRectangle2D () {
    return new Rectangle2D.Double (getLesserX (), getLesserY (), getWidth (), getHeight ());
}


public void setCenter (Point2D centerPoint2D) {
    Point2D currentCenterPoint2D = getCenter ();
    double dDeltaX = centerPoint2D.getX () - currentCenterPoint2D.getX ();
    double dDeltaY = centerPoint2D.getY () - currentCenterPoint2D.getY ();
    offset (dDeltaX, dDeltaY);
}


public Point2D getCenter () {
    return new Point2D.Double ((_dX1 + _dX2) / 2.0, (_dY1 + _dY2) / 2.0);
}


public void zoomBy (double dRatio) {
    double dWidth = _dX2 - _dX1;
    double dHeight = _dY2 - _dY1;
    double dNewWidth = (dWidth * dRatio);
    double dNewHeight = (dHeight * dRatio);
    Point2D centerPoint2D = getCenter ();
    _dX1 = centerPoint2D.getX () - (dNewWidth / 2.0);
    _dY1 = centerPoint2D.getY () - (dNewHeight / 2.0);
    _dX2 = centerPoint2D.getX () + (dNewWidth / 2.0);
    _dY2 = centerPoint2D.getY () + (dNewHeight / 2.0);
}


public void shiftBy (int nXPercentage, int nYPercentage) {
    double dWidth = _dX2 - _dX1;
    double dHeight = _dY2 - _dY1;
    double dDeltaX = (dWidth * nXPercentage) / 100.0;
    double dDeltaY = (dHeight * nYPercentage) / 100.0;
    offset (dDeltaX, dDeltaY);
}


public void offset (double dDeltaX, double dDeltaY) {
    _dX1 += dDeltaX;
    _dX2 += dDeltaX;
    _dY1 += dDeltaY;
    _dY2 += dDeltaY;
}


public void expandToRatio (double dRatio) {
    double dCurrentRatio = getWidth () / getHeight ();
    if (dCurrentRatio  dRatio) {
        double dNewHeight = getWidth () / dRatio;
        double dCenterY = (_dY1 + _dY2) / 2.0;
        double dDelta = dNewHeight / 2.0;
        _dY1 = dCenterY - dDelta;
        _dY2 = dCenterY + dDelta;
    }
}


public void includeXCoordinate (double x) {
    _dX1 = min (_dX1, _dX2, x);
    _dX2 = max (_dX1, _dX2, x);
}


public void includeYCoordinate (double y) {
    _dY1 = min (_dY1, _dY2, y);
    _dY2 = max (_dY1, _dY2, y);
}


public void includePoint (double x, double y) {
    includeXCoordinate (x);
    includeYCoordinate (y);
}


public void includePoint (Point2D aPoint2D) {
    includePoint (aPoint2D.getX (), aPoint2D.getY ());
}


public void includeLine (double x1, double y1, double x2, double y2) {
    includePoint (x1, y1);
    includePoint (x2, y2);
}


public void includeLine (Point2D onePoint2D, Point2D twoPoint2D) {
    includeLine (onePoint2D.getX (), onePoint2D.getY (), twoPoint2D.getX (), twoPoint2D.getY ());
}


public void includeBounds (Bounds aBounds) {
    includeXCoordinate (aBounds.getLesserX ());
    includeXCoordinate (aBounds.getGreaterX ());
    includeYCoordinate (aBounds.getLesserY ());
    includeYCoordinate (aBounds.getGreaterY ());
}


public void includeRectangle2D (Rectangle2D aRectangle2D) {
    includeXCoordinate (aRectangle2D.getMinX ());
    includeXCoordinate (aRectangle2D.getMaxX ());
    includeYCoordinate (aRectangle2D.getMinY ());
    includeYCoordinate (aRectangle2D.getMaxY ());
}


public void intersect (Bounds aBounds) {
    _dX1 = Math.max (_dX1, aBounds.getLesserX ());
    _dY1 = Math.max (_dY1, aBounds.getLesserY ());
    _dX2 = Math.min (_dX2, aBounds.getGreaterX ());
    _dY2 = Math.min (_dY2, aBounds.getGreaterY ());
    if (_dX1 > _dX2) {
        _dX1 = _dX2;
    }
    if (_dY1 > _dY2) {
        _dY1 = _dY2;
    }
}


public boolean intersectsPoint (double x, double y) {
    return ((_dX1 

public boolean intersectsPoint (Point2D aPoint2D) {
    return intersectsPoint (aPoint2D.getX (), aPoint2D.getY ());
}


public boolean intersectsLine (double x1, double y1, double x2, double y2) {
    if (intersectsPoint (x1, y1)) {
        return true;
    }
    if (intersectsPoint (x2, y2)) {
        return true;
    }
    if ((x1  _dX2) && (x2 > _dX2)) {
        return false;
    }
    if ((y1  _dY2) && (y2 > _dY2)) {
        return false;
    }
    if (((_dX1 

public boolean intersectsLine (Point2D onePoint2D, Point2D twoPoint2D) {
    return intersectsLine (onePoint2D.getX (), onePoint2D.getY (), twoPoint2D.getX (), twoPoint2D.getY ());
}


public boolean intersectsBounds (Bounds aBounds) {
    double dLesserX = aBounds.getLesserX ();
    double dGreaterX = aBounds.getGreaterX ();
    double dLesserY = aBounds.getLesserY ();
    double dGreaterY = aBounds.getGreaterY ();
    if (dLesserX = _dX1) && (dGreaterY >= _dY1));
        } else {
            return ((dGreaterX >= _dX1) && (dLesserY = _dY1));
        } else {
            return ((dLesserX 

public boolean completelyContainsLine (double x1, double y1, double x2, double y2) {
    return (_dX1 > Math.min (x1, x2)) && (_dX2  Math.min (y1, y2)) && (_dY2 

public boolean isCompletelyInside (Bounds aBounds) {
    return (_dX1 > aBounds.getLesserX ()) && (_dX2  aBounds.getLesserY ()) && (_dY2 

public Point2D [] cropLine (double x1, double y1, double x2, double y2) {
    if (! intersectsLine (x1, y1, x2, y2)) {
        return null;
    }
    Point2D [] resultLine = new Point2D [2];
    Point2D beginPoint2D = new Point2D.Double (x1, y1);
    Point2D endPoint2D = new Point2D.Double (x2, y2);
    if (beginPoint2D.getX () == endPoint2D.getX ()) {
        if (beginPoint2D.getY () > _dY2) {
            beginPoint2D.setLocation (beginPoint2D.getX (), _dY2);
        }
        if (endPoint2D.getY () > _dY2) {
            endPoint2D.setLocation (endPoint2D.getX (), _dY2);
        }
        if (beginPoint2D.getY ()  _dX2) {
            beginPoint2D.setLocation (_dX2, beginPoint2D.getY ());
        }
        if (endPoint2D.getX () > _dX2) {
            endPoint2D.setLocation (_dX2, endPoint2D.getY ());
        }
        if (beginPoint2D.getX ()  _dY2) {
                double x = ((_dY2 - beginPoint2D.getY ()) / dSlope) + beginPoint2D.getX ();
                if ((x >= _dX1) && (x = _dX1) && (x  _dX2) {
                double y = dSlope * (_dX2 - beginPoint2D.getX ()) + beginPoint2D.getY ();
                if ((y >= _dY1) && (y = _dY1) && (y  _dY2) {
                double x = ((_dY2 - beginPoint2D.getY ()) / dSlope) + beginPoint2D.getX ();
                if ((x >= _dX1) && (x = _dX1) && (x  _dX2) {
                double y = dSlope * (_dX2 - beginPoint2D.getX ()) + beginPoint2D.getY ();
                if ((y >= _dY1) && (y = _dY1) && (y 

public boolean equals (Object anObject) {
    if ((anObject == null) || (! (anObject instanceof Bounds))) {
        return false;
    }
    Bounds aBounds = (Bounds) anObject;
    if ((_dX1 == aBounds.getLesserX ()) && (_dX2 == aBounds.getGreaterX ()) && (_dY1 == aBounds.getLesserY ()) && (_dY2 == aBounds.getGreaterY ())) {
        return true;
    }
    return false;
}


public int hashCode () {
    double temp = Math.abs (_dX1 + _dX2 + _dY1 + _dY2);
    while ((temp != 0) && (temp 

public String toString () {
    return Double.toString (_dX1) + " " + Double.toString (_dY1) + " " + Double.toString (_dX2) + " " + Double.toString (_dY2);
}


private double min (double x1, double x2, double x3) {
    return Math.min (Math.min (x1, x2), x3);
}


private double max (double x1, double x2, double x3) {
    return Math.max (Math.max (x1, x2), x3);
}


public UndoCommand (String name, DrawingEditor newDrawingEditor) {
    super (name, newDrawingEditor);
}


public void execute () {
    super.execute ();
    UndoManager um = getDrawingEditor ().getUndoManager ();
    if ((um == null) || ! um.isUndoable ()) {
        return;
    }
    Undoable lastUndoable = um.popUndo ();
    boolean hasBeenUndone = lastUndoable.undo ();
    if (hasBeenUndone && lastUndoable.isRedoable ()) {
        um.pushRedo (lastUndoable);
    }
    lastUndoable.getDrawingView ().checkDamage ();
    getDrawingEditor ().figureSelectionChanged (lastUndoable.getDrawingView ());
}


public boolean isExecutableWithView () {
    UndoManager um = getDrawingEditor ().getUndoManager ();
    if ((um != null) && (um.getUndoSize () > 0)) {
        return true;
    }
    return false;
}


public PaletteLayout (int gap) {
    this (gap, new Point (0, 0), true);
}


public PaletteLayout (int gap, Point border) {
    this (gap, border, true);
}


public PaletteLayout (int gap, Point border, boolean vertical) {
    fGap = gap;
    fBorder = border;
    fVerticalLayout = vertical;
}


public void addLayoutComponent (String name, Component comp) {
}


public void removeLayoutComponent (Component comp) {
}


public Dimension preferredLayoutSize (Container target) {
    return minimumLayoutSize (target);
}


public Dimension minimumLayoutSize (Container target) {
    Dimension dim = new Dimension (0, 0);
    int nmembers = target.getComponentCount ();
    for (int i = 0;
    i  0) {
                    dim.height += fGap;
                }
                dim.height += d.height;
            } else {
                dim.height = Math.max (dim.height, d.height);
                if (i > 0) {
                    dim.width += fGap;
                }
                dim.width += d.width;
            }
        }
    }
    Insets insets = target.getInsets ();
    dim.width += insets.left + insets.right;
    dim.width += 2 * fBorder.x;
    dim.height += insets.top + insets.bottom;
    dim.height += 2 * fBorder.y;
    return dim;
}


public void layoutContainer (Container target) {
    Insets insets = target.getInsets ();
    int nmembers = target.getComponentCount ();
    int x = insets.left + fBorder.x;
    int y = insets.top + fBorder.y;
    for (int i = 0;
    i 

public DrawingChangeEvent (Drawing source, Rectangle r) {
    super (source);
    fRectangle = r;
}


public Drawing getDrawing () {
    return (Drawing) getSource ();
}


public Rectangle getInvalidatedRectangle () {
    return fRectangle;
}


private FigureAttributeConstant (String newName, int newID) {
    setName (newName);
    setID (newID);
    addConstant (this);
}


public FigureAttributeConstant (String newName) {
    this (newName, attributeConstants.length + 1);
}


private void setName (String newName) {
    myName = newName;
}


public String getName () {
    return myName;
}


private void setID (int newID) {
    myID = newID;
}


public int getID () {
    return myID;
}


public boolean equals (Object compareObject) {
    if (compareObject == null) {
        return false;
    }
    if (! (compareObject instanceof FigureAttributeConstant)) {
        return false;
    }
    FigureAttributeConstant compareAttribute = (FigureAttributeConstant) compareObject;
    if (compareAttribute.getID () != getID ()) {
        return false;
    }
    if ((compareAttribute.getName () == null) && (getName () == null)) {
        return true;
    }
    if ((compareAttribute.getName () != null) && (getName () != null)) {
        return getName ().equals (compareAttribute.getName ());
    }
    return false;
}


public int hashCode () {
    return getID ();
}


private static void addConstant (FigureAttributeConstant newConstant) {
    int idPos = newConstant.getID () - 1;
    if ((idPos = attributeConstants.length) {
        FigureAttributeConstant [] tempStrs = new FigureAttributeConstant [idPos + 1];
        System.arraycopy (attributeConstants, 0, tempStrs, 0, attributeConstants.length);
        attributeConstants = tempStrs;
    }
    attributeConstants [idPos] = newConstant;
}


public static FigureAttributeConstant getConstant (String constantName) {
    for (int i = 0;
    i 

public static FigureAttributeConstant getConstant (int constantId) {
    return attributeConstants [constantId];
}


public FigureChangeEvent (Figure source, Rectangle r) {
    super (source);
    fRectangle = r;
}


public FigureChangeEvent (Figure source) {
    super (source);
    fRectangle = fgEmptyRectangle;
}


public FigureChangeEvent (Figure source, Rectangle r, FigureChangeEvent nestedEvent) {
    this (source, r);
    myNestedEvent = nestedEvent;
}


public Figure getFigure () {
    return (Figure) getSource ();
}


public Rectangle getInvalidatedRectangle () {
    return fRectangle;
}


public FigureChangeEvent getNestedEvent () {
    return myNestedEvent;
}


public JHotDrawException (String msg) {
    super (msg);
}


public JHotDrawException (Exception nestedException) {
    this (nestedException.getLocalizedMessage ());
    setNestedException (nestedException);
    nestedException.fillInStackTrace ();
}


protected void setNestedException (Exception newNestedException) {
    myNestedException = newNestedException;
}


public Exception getNestedException () {
    return myNestedException;
}


public JHotDrawRuntimeException (String msg) {
    super (msg);
}


public JHotDrawRuntimeException (Exception nestedException) {
    this (nestedException.getLocalizedMessage ());
    setNestedException (nestedException);
    nestedException.fillInStackTrace ();
}


protected void setNestedException (Exception newNestedException) {
    myNestedException = newNestedException;
}


public Exception getNestedException () {
    return myNestedException;
}


public ChopDiamondConnector () {
}


public ChopDiamondConnector (Figure owner) {
    super (owner);
}


protected Point chop (Figure target, Point from) {
    Rectangle r = target.displayBox ();
    Point c1 = new Point (r.x + r.width / 2, r.y + (r.height / 2));
    Point p2 = new Point (r.x + r.width / 2, r.y + r.height);
    Point p4 = new Point (r.x + r.width / 2, r.y);
    if (r.contains (from)) {
        if (from.y > r.y && from.y  0 && ang  1.575 && ang  - 3.14 && ang  - 1.57 && ang 

private ComponentFigure () {
    bounds = new Rectangle ();
}


public ComponentFigure (Component newComponent) {
    this ();
    setComponent (newComponent);
}


public void basicDisplayBox (Point origin, Point corner) {
    bounds = new Rectangle (origin);
    bounds.add (corner);
}


protected void basicMoveBy (int dx, int dy) {
    bounds.translate (dx, dy);
}


public Rectangle displayBox () {
    return new Rectangle (bounds);
}


public HandleEnumeration handles () {
    List handles = CollectionsFactory.current ().createList ();
    BoxHandleKit.addHandles (this, handles);
    return new HandleEnumerator (handles);
}


public Component getComponent () {
    return this.component;
}


protected void setComponent (Component newComponent) {
    this.component = newComponent;
}


public void draw (Graphics g) {
    getComponent ().setBounds (displayBox ());
    Graphics componentG = g.create (bounds.x, bounds.y, bounds.width, bounds.height);
    getComponent ().paint (componentG);
}


public HTMLTextAreaFigure () {
    initialize ();
}


public Object clone () {
    Object cloneObject = super.clone ();
    ((HTMLTextAreaFigure) cloneObject).initialize ();
    return cloneObject;
}


public void basicDisplayBox (Point origin, Point corner) {
    super.basicDisplayBox (origin, corner);
    getFrameFigure ().displayBox (displayBox ());
}


public HandleEnumeration handles () {
    return getFrameFigure ().handles ();
}


public boolean containsPoint (int x, int y) {
    return getFrameFigure ().containsPoint (x, y);
}


public void moveBy (int dx, int dy) {
    super.moveBy (dx, dy);
    getFrameFigure ().moveBy (dx, dy);
}


protected void initialize () {
    fImageHolder = DisposableResourceManagerFactory.createStandardHolder (null);
    setFrameFigure (new RectangleFigure ());
    setIntrinsicContentProducer (new HTMLContentProducer ());
    fContentProducers = new ContentProducerRegistry (fDefaultContentProducers);
    markSizeDirty ();
    markImageDirty ();
    markTextDirty ();
    markFontDirty ();
    setAttribute (Figure.POPUP_MENU, createPopupMenu ());
}


protected void markSizeDirty () {
    markImageDirty ();
    super.markSizeDirty ();
}


protected void markTextDirty () {
    markImageDirty ();
    super.markTextDirty ();
}


protected void markFontDirty () {
    markImageDirty ();
    super.markFontDirty ();
}


public void draw (Graphics g) {
    Color fill = getFillColor ();
    g.setColor (fill);
    drawBackground (g);
    drawText (g, displayBox ());
    Color frame = getFrameColor ();
    g.setColor (frame);
    drawFrame (g);
}


public void drawFrame (Graphics g) {
    ((Graphics2D) g).draw (getClippingShape ());
}


public void drawBackground (Graphics g) {
    ((Graphics2D) g).fill (getClippingShape ());
}


protected float drawText (Graphics g, Rectangle displayBox) {
    Graphics2D g2 = null;
    Shape savedClip = null;
    if (g != null) {
        g2 = (Graphics2D) g;
        savedClip = g2.getClip ();
    }
    Rectangle drawingBox = makeDrawingBox (displayBox);
    if (drawingBox.isEmpty ()) {
        return drawingBox.height;
    }
    if (g != null) {
        g2.clip (getClippingShape ());
    }
    if (usesDirectDraw ()) {
        drawTextDirect (g2, drawingBox);
    } else {
        fImageHolder.lock ();
        if (isImageDirty ()) {
            generateImage (drawingBox);
            setSizeDirty (false);
        }
        if (g2 != null) {
            g2.drawImage (getImage (), drawingBox.x, drawingBox.y, null);
        }
        fImageHolder.unlock ();
    }
    if (g != null) {
        g2.setClip (savedClip);
    }
    drawFrame (g);
    return displayBox.height;
}


protected void generateImage (Rectangle drawingBox) {
    createImage (drawingBox.width, drawingBox.height);
    Graphics2D g2 = (Graphics2D) getImage ().getGraphics ();
    Rectangle finalBox = new Rectangle (drawingBox);
    finalBox.setLocation (0, 0);
    renderText (g2, finalBox);
    g2.dispose ();
}


protected void drawTextDirect (Graphics2D g2, Rectangle drawingBox) {
    Shape savedClipArea = null;
    Color savedFontColor = null;
    Font savedFont = null;
    Rectangle2D clipRect = null;
    RenderingHints savedRenderingHints = null;
    if (g2 != null) {
        savedRenderingHints = g2.getRenderingHints ();
        savedClipArea = g2.getClip ();
        savedFont = g2.getFont ();
        savedFontColor = g2.getColor ();
        g2.clip (drawingBox);
    }
    float finalHeight = renderText (g2, drawingBox);
    if (g2 != null) {
        g2.setClip (savedClipArea);
        g2.setColor (savedFontColor);
        g2.setRenderingHints (savedRenderingHints);
    }
}


protected float renderText (Graphics2D g2, Rectangle drawingBox) {
    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    g2.setRenderingHint (RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
    g2.setBackground (getFillColor ());
    g2.setColor (getFillColor ());
    g2.clearRect (drawingBox.x, drawingBox.y, drawingBox.width, drawingBox.height);
    g2.fillRect (drawingBox.x, drawingBox.y, drawingBox.width, drawingBox.height);
    String text;
    if (isRawHTML ()) {
        text = getText ();
    } else {
        text = getHTMLText (getText (), getFont (), (String) getContentProducer (Color.class).getContent (this, FigureAttributeConstant.TEXT_COLOR_STR, getTextColor ()), (String) getContentProducer (Color.class).getContent (this, FigureAttributeConstant.FILL_COLOR_STR, getFillColor ()), drawingBox);
    }
    text = substituteEntityKeywords (text);
    JLabel displayDelegate = getDisplayDelegate ();
    displayDelegate.setText (text);
    displayDelegate.setBackground (getFillColor ());
    displayDelegate.setLocation (0, 0);
    displayDelegate.setSize (drawingBox.width, drawingBox.height);
    displayDelegate.setHorizontalAlignment (((Integer) getAttribute ("XAlignment")).intValue ());
    displayDelegate.setVerticalAlignment (((Integer) getAttribute ("YAlignment")).intValue ());
    SwingUtilities.paintComponent (g2, displayDelegate, getContainerPanel (displayDelegate, drawingBox), drawingBox.x, drawingBox.y, drawingBox.width, drawingBox.height);
    return drawingBox.height;
}


protected Rectangle makeDrawingBox (Rectangle displayBox) {
    float leftMargin = ((Float) getAttribute ("LeftMargin")).floatValue ();
    float rightMargin = ((Float) getAttribute ("RightMargin")).floatValue ();
    float topMargin = ((Float) getAttribute ("TopMargin")).floatValue ();
    float bottomMargin = ((Float) getAttribute ("BottomMargin")).floatValue ();
    Rectangle drawingBox = new Rectangle (displayBox);
    drawingBox.grow (- 1, - 1);
    drawingBox.x += leftMargin;
    drawingBox.width -= (leftMargin + rightMargin);
    drawingBox.y += topMargin;
    drawingBox.height -= topMargin + bottomMargin;
    return drawingBox;
}


protected JLabel getDisplayDelegate () {
    if (fDisplayDelegate == null) {
        fDisplayDelegate = new JLabel ();
        fDisplayDelegate.setBorder (null);
    }
    return fDisplayDelegate;
}


protected void createImage (int width, int height) {
    fImageHolder.lock ();
    if (! fImageHolder.isAvailable () || ((BufferedImage) fImageHolder.getResource ()).getWidth () != width || ((BufferedImage) fImageHolder.getResource ()).getHeight () != height) {
        fImageHolder.setResource (new BufferedImage (width, height, BufferedImage.TYPE_INT_RGB));
    }
}


protected JPanel getContainerPanel (Component drawingDelegate, Rectangle displayBox) {
    JPanel panel = new JPanel ();
    return panel;
}


protected String getHTMLText (String text, Font font, String textColor, String backColor, Rectangle displayBox) {
    StringBuffer htmlText = new StringBuffer ();
    htmlText.append ("");
    htmlText.append ("");
    htmlText.append ("");
    htmlText.append ("");
    if (((Integer) getAttribute ("XAlignment")).intValue () == SwingConstants.CENTER) {
        htmlText.append ("");
    }
    if (font.isItalic ()) {
        htmlText.append ("");
    }
    if (font.isBold ()) {
        htmlText.append ("");
    }
    htmlText.append (text);
    if (font.isBold ()) {
        htmlText.append ("");
    }
    if (font.isItalic ()) {
        htmlText.append ("");
    }
    if (((Integer) getAttribute ("XAlignment")).intValue () == SwingConstants.CENTER) {
        htmlText.append ("");
    }
    htmlText.append ("");
    htmlText.append ("");
    htmlText.append ("");
    return htmlText.toString ();
}


protected String substituteEntityKeywords (String template) {
    int startPos;
    int chunkEnd;
    int endPos;
    StringBuffer finalText = new StringBuffer ();
    startPos = 0;
    chunkEnd = startPos;
    try {
        while ((startPos = template.indexOf (START_ENTITY_CHAR, startPos)) != - 1) {
            if (startPos != 0 && template.charAt (startPos - 1) == ESCAPE_CHAR) {
                startPos ++;
                continue;
            }
            endPos = startPos + 1;
            while ((endPos = template.indexOf (END_ENTITY_CHAR, endPos)) != - 1) {
                if (endPos == 0 || template.charAt (endPos - 1) != ESCAPE_CHAR) {
                    break;
                }
                throw new InvalidAttributeMarker ();
            }
            String attrName = template.substring (startPos + 1, endPos);
            String attrValue = getEntityHTMLRepresentation (attrName);
            if (attrValue != null) {
                finalText.append (template.substring (chunkEnd, startPos));
                finalText.append (substituteEntityKeywords (attrValue));
                startPos = endPos + 1;
                chunkEnd = startPos;
            } else {
                startPos ++;
            }
        }
    } catch (InvalidAttributeMarker ex) {
    }
    finalText.append (template.substring (chunkEnd));
    return finalText.toString ();
}


protected String getEntityHTMLRepresentation (String attrName) {
    Object attrValue = null;
    attrValue = getIntrinsicContentProducer ().getContent (this, attrName, attrValue);
    if (attrValue == null) {
        return null;
    }
    while (attrValue != null && ! (attrValue instanceof String)) {
        if (attrValue instanceof ContentProducer) {
            attrValue = ((ContentProducer) attrValue).getContent (this, attrName, attrValue);
            continue;
        }
        ContentProducer defaultProducer = getContentProducer (attrValue.getClass ());
        if (defaultProducer != null) {
            attrValue = defaultProducer.getContent (this, attrName, attrValue);
            continue;
        }
        attrValue = attrValue.toString ();
    }
    return (String) attrValue;
}


protected BufferedImage getImage () {
    if (fImageHolder.isAvailable ()) {
        return (BufferedImage) fImageHolder.getResource ();
    }
    return null;
}


protected void setImage (BufferedImage newImage) {
    fImageHolder.setResource (newImage);
}


protected JPopupMenu createPopupMenu () {
    JPopupMenu popupMenu = new JPopupMenu ();
    addPopupMenuItems (popupMenu);
    popupMenu.setLightWeightPopupEnabled (true);
    return popupMenu;
}


protected void addPopupMenuItems (JPopupMenu popupMenu) {
    ButtonGroup drawingPopupGroup;
    JRadioButtonMenuItem rbOption;
    drawingPopupGroup = new ButtonGroup ();
    rbOption = new JRadioButtonMenuItem (new AbstractAction ("Direct drawing") {
        public void actionPerformed (ActionEvent event) {
            setUseDirectDraw (true);
        }}

    );
    drawingPopupGroup.add (rbOption);
    if (usesDirectDraw ()) {
        drawingPopupGroup.setSelected (rbOption.getModel (), true);
    }
    popupMenu.add (rbOption);
    rbOption = new JRadioButtonMenuItem (new AbstractAction ("Buffered drawing") {
        public void actionPerformed (ActionEvent event) {
            setUseDirectDraw (false);
        }}

    );
    drawingPopupGroup.add (rbOption);
    if (usesBufferedDraw ()) {
        drawingPopupGroup.setSelected (rbOption.getModel (), true);
    }
    popupMenu.add (rbOption);
    popupMenu.addSeparator ();
    drawingPopupGroup = new ButtonGroup ();
    rbOption = new JRadioButtonMenuItem (new AbstractAction ("Normal HTML") {
        public void actionPerformed (ActionEvent event) {
            setRawHTML (false);
        }}

    );
    drawingPopupGroup.add (rbOption);
    drawingPopupGroup.setSelected (rbOption.getModel (), true);
    popupMenu.add (rbOption);
    rbOption = new JRadioButtonMenuItem (new AbstractAction ("Raw HTML") {
        public void actionPerformed (ActionEvent event) {
            setRawHTML (true);
        }}

    );
    drawingPopupGroup.add (rbOption);
    popupMenu.add (rbOption);
}


public void actionPerformed (ActionEvent event) {
    setUseDirectDraw (true);
}


public void actionPerformed (ActionEvent event) {
    setUseDirectDraw (false);
}


public void actionPerformed (ActionEvent event) {
    setRawHTML (false);
}


public void actionPerformed (ActionEvent event) {
    setRawHTML (true);
}


public boolean usesDirectDraw () {
    return fUseDirectDraw;
}


public void setUseDirectDraw (boolean newUseDirectDraw) {
    fUseDirectDraw = newUseDirectDraw;
    setAttribute (Figure.POPUP_MENU, createPopupMenu ());
    markSizeDirty ();
}


public void setUseBufferedDraw (boolean newUseBufferedDraw) {
    setUseDirectDraw (! newUseBufferedDraw);
}


public boolean usesBufferedDraw () {
    return ! usesDirectDraw ();
}


protected void markImageDirty () {
    fImageHolder.dispose ();
}


protected boolean isImageDirty () {
    return ! fImageHolder.isAvailable ();
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    setFrameFigure ((Figure) dr.readStorable ());
    setUseDirectDraw (dr.readBoolean ());
    setRawHTML (dr.readBoolean ());
}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeStorable (getFrameFigure ());
    dw.writeBoolean (usesDirectDraw ());
    dw.writeBoolean (isRawHTML ());
}


public void setAttribute (String name, Object value) {
    super.setAttribute (name, value);
    markImageDirty ();
}


public boolean isRawHTML () {
    return fRawHTML;
}


public void setRawHTML (boolean newRawHTML) {
    fRawHTML = newRawHTML;
    setAttribute (Figure.POPUP_MENU, createPopupMenu ());
}


protected ContentProducer getIntrinsicContentProducer () {
    return fIntrinsicContentProducer;
}


public void setIntrinsicContentProducer (ContentProducer newIntrinsicContentProducer) {
    fIntrinsicContentProducer = newIntrinsicContentProducer;
}


public ContentProducer registerContentProducer (Class targetClass, ContentProducer producer) {
    return fContentProducers.registerContentProducer (targetClass, producer);
}


public void unregisterContentProducer (Class targetClass, ContentProducer producer) {
    fContentProducers.unregisterContentProducer (targetClass, producer);
}


protected ContentProducer getContentProducer (Class targetClass) {
    return fContentProducers.getContentProducer (targetClass);
}


public Polygon getPolygon () {
    Polygon polygon = new Polygon ();
    AffineTransform at = AffineTransform.getScaleInstance (1, 1);
    FlatteningPathIterator pIter = new FlatteningPathIterator (getClippingShape ().getPathIterator (at), 1);
    double [] coords = new double [6];
    int pointType;
    while (! pIter.isDone ()) {
        pointType = pIter.currentSegment (coords);
        polygon.addPoint ((int) coords [0], (int) coords [1]);
        pIter.next ();
    }
    return polygon;
}


protected Figure getFrameFigure () {
    return fFrameFigure;
}


public void setFrameFigure (Figure newFrameFigure) {
    if (fFrameFigure != null) {
        fFrameFigure.removeFigureChangeListener (this);
    }
    fFrameFigure = newFrameFigure;
    fFrameFigure.addFigureChangeListener (this);
}


protected Shape getClippingShape () {
    Figure frame = getFrameFigure ();
    if (frame instanceof GeometricFigure) {
        return ((GeometricFigure) frame).getShape ();
    }
    return frame.displayBox ();
}


public void figureInvalidated (FigureChangeEvent e) {
}


public void figureChanged (FigureChangeEvent e) {
    willChange ();
    super.basicDisplayBox (e.getFigure ().displayBox ().getLocation (), Geom.corner (e.getFigure ().displayBox ()));
    changed ();
}


public void figureRemoved (FigureChangeEvent e) {
}


public void figureRequestRemove (FigureChangeEvent e) {
}


public void figureRequestUpdate (FigureChangeEvent e) {
}


public Figure getRepresentingFigure () {
    return this;
}


public AbstractContentProducer () {
}


public void write (StorableOutput dw) {
}


public void read (StorableInput dr) throws IOException {
}


public TriangleFigureGeometricAdapter () {
    super ();
}


public TriangleFigureGeometricAdapter (Point origin, Point corner) {
    super (origin, corner);
}


public Shape getShape () {
    return getPolygon ();
}


public StandardDisposableResourceManager (ResourceDisposabilityStrategy strategy) {
    resources = new WeakHashMap ();
    this.strategy = strategy;
    strategy.setManager (this);
}


public synchronized void registerResource (DisposableResourceHolder resource) {
    resources.put (resource, resource);
}


public synchronized void unregisterResource (DisposableResourceHolder resource) {
    resources.remove (resource);
}


public Iterator getResources () {
    return resources.values ().iterator ();
}


public synchronized boolean managesResource (DisposableResourceHolder resource) {
    return resources.containsValue (resource);
}


public ResourceDisposabilityStrategy getStrategy () {
    return strategy;
}


public void setStrategy (ResourceDisposabilityStrategy newStrategy) {
    strategy = newStrategy;
}


public void startDisposing () throws ResourceManagerNotSetException {
    strategy.startDisposing ();
}


public void stopDisposing (long millis) {
    strategy.stopDisposing (millis);
}


public AttributeFigureContentProducer () {
}


public Object getContent (ContentProducerContext context, String ctxAttrName, Object ctxAttrValue) {
    Object attrValue = super.getContent (context, ctxAttrName, ctxAttrValue);
    if (attrValue != null) {
        return attrValue;
    }
    return ((AttributeContentProducerContext) context).getAttribute (ctxAttrName);
}


public void write (StorableOutput dw) {
    super.write (dw);
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
}


public ColorContentProducer () {
}


public ColorContentProducer (Color color) {
    fColor = color;
}


public Object getContent (ContentProducerContext context, String ctxAttrName, Object ctxAttrValue) {
    Color color = (fColor != null) ? fColor : (Color) ctxAttrValue;
    String colorCode = Integer.toHexString (color.getRGB ());
    return "0x" + colorCode.substring (colorCode.length () - 6);
}


public void setColor (Color color) {
    fColor = color;
}


public Color getColor () {
    return fColor;
}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeBoolean ((fColor != null));
    if (fColor != null) {
        dw.writeInt (fColor.getRGB ());
    }
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    boolean hasColor = dr.readBoolean ();
    if (hasColor) {
        fColor = new Color (dr.readInt ());
    } else {
        fColor = null;
    }
}


public StandardDisposableResourceHolder () {
}


public StandardDisposableResourceHolder (Object resource) {
    this.resource = resource;
    resetDelay ();
}


public Object clone () {
    StandardDisposableResourceHolder clone = new StandardDisposableResourceHolder ();
    clone.setDisposableDelay (this.getDisposableDelay ());
    return clone;
}


public Object getResource () throws NullPointerException {
    if (resource != null) {
        resetDelay ();
        return resource;
    }
    throw new NullPointerException ();
}


public void setResource (Object resource) {
    this.resource = resource;
    resetDelay ();
}


public void setDisposableDelay (long millis) {
    disposeDelay = millis;
}


public long getDisposableDelay () {
    return disposeDelay;
}


public void dispose () {
    resource = null;
}


public boolean isAvailable () {
    return (resource != null);
}


public void lock () {
    isLocked = true;
}


public void unlock () {
    resetDelay ();
    isLocked = false;
}


public boolean isLocked () {
    return isLocked;
}


public long getLastTimeAccessed () {
    return lastTimeAccessed;
}


public void resetDelay () {
    lastTimeAccessed = System.currentTimeMillis ();
}


public FigureDataContentProducer () {
}


public Object getContent (ContentProducerContext context, String ctxAttrName, Object ctxAttrValue) {
    if (ctxAttrName.compareTo (ContentProducer.ENTITY_FIGURE_WIDTH) == 0) {
        return Integer.toString (((FigureContentProducerContext) context).displayBox ().width);
    }
    if (ctxAttrName.compareTo (ContentProducer.ENTITY_FIGURE_HEIGHT) == 0) {
        return Integer.toString (((FigureContentProducerContext) context).displayBox ().height);
    }
    if (ctxAttrName.compareTo (ContentProducer.ENTITY_FIGURE_POSX) == 0) {
        return Integer.toString (((FigureContentProducerContext) context).displayBox ().x);
    }
    if (ctxAttrName.compareTo (ContentProducer.ENTITY_FIGURE_POSY) == 0) {
        return Integer.toString (((FigureContentProducerContext) context).displayBox ().y);
    }
    return null;
}


public void write (StorableOutput dw) {
    super.write (dw);
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
}


public RoundRectangleGeometricAdapter () {
    super ();
}


public RoundRectangleGeometricAdapter (Point origin, Point corner) {
    super (origin, corner);
}


public Shape getShape () {
    Point arc = getArc ();
    Rectangle dspBox = displayBox ();
    RoundRectangle2D.Float roundRectangle = new RoundRectangle2D.Float (dspBox.x, dspBox.y, dspBox.width, dspBox.height, arc.x, arc.y);
    return roundRectangle;
}


public URLContentProducer () {
}


public URLContentProducer (URL url) {
    fURL = url;
}


public Object getContent (ContentProducerContext context, String ctxAttrName, Object ctxAttrValue) {
    try {
        URL url = (fURL != null) ? new URL (fURL.toExternalForm ()) : new URL (((URL) ctxAttrValue).toExternalForm ());
        InputStream reader = url.openStream ();
        int available = reader.available ();
        byte contents [] = new byte [available];
        reader.read (contents, 0, available);
        reader.close ();
        return new String (contents);
    } catch (Exception ex) {
        ex.printStackTrace ();
        return ex.toString ();
    }
}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeBoolean ((fURL != null));
    if (fURL != null) {
        dw.writeString (fURL.toExternalForm ());
    }
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    boolean hasURL = dr.readBoolean ();
    if (hasURL) {
        fURL = new URL (dr.readString ());
    }
}


public ContentProducerRegistry () {
    fParent = fDefaultRegistry;
}


public ContentProducerRegistry (ContentProducerRegistry parent) {
    fParent = parent;
}


public void setAutonomous () {
    fParent = null;
}


public boolean isAutonomous () {
    return (fParent == null);
}


public void setParent (ContentProducerRegistry newParent) {
    fParent = newParent;
}


public ContentProducerRegistry getParent () {
    return fParent;
}


public static ContentProducer registerDefaultContentProducer (Class targetClass, ContentProducer producer) {
    return fDefaultRegistry.registerContentProducer (targetClass, producer);
}


public static void unregisterDefaultContentProducer (Class targetClass, ContentProducer producer) {
    fDefaultRegistry.unregisterContentProducer (targetClass, producer);
}


public static ContentProducer getDefaultContentProducer (Class targetClass) {
    return fDefaultRegistry.getContentProducer (targetClass);
}


public static ContentProducer getExactDefaultContentProducer (Class targetClass) {
    return fDefaultRegistry.getExactContentProducer (targetClass);
}


public ContentProducer registerContentProducer (Class targetClass, ContentProducer producer) {
    ContentProducer previousProducer = getContentProducer (targetClass);
    fContentProducers.put (targetClass, producer);
    return previousProducer;
}


public void unregisterContentProducer (Class targetClass, ContentProducer producer) {
    ContentProducer currentProducer = getContentProducer (targetClass);
    if (currentProducer == producer) {
        fContentProducers.remove (targetClass);
    }
}


public ContentProducer getContentProducer (Class targetClass) {
    ContentProducer producer = getExactContentProducer (targetClass);
    if (producer != null) {
        return producer;
    }
    return getSuperClassContentProducer (targetClass, null);
}


public ContentProducer getExactContentProducer (Class targetClass) {
    ContentProducer producer = (ContentProducer) fContentProducers.get (targetClass);
    if (producer != null) {
        return producer;
    }
    if (! this.isAutonomous ()) {
        return getParent ().getExactContentProducer (targetClass);
    }
    return null;
}


protected ContentProducer getSuperClassContentProducer (Class targetClass, Class closestClass) {
    Map.Entry entry;
    Class entryClass;
    ContentProducer closestProducer = null;
    Iterator iter = fContentProducers.entrySet ().iterator ();
    while (iter.hasNext ()) {
        entry = (Map.Entry) iter.next ();
        entryClass = (Class) entry.getKey ();
        if (entryClass.isAssignableFrom (targetClass)) {
            if (closestClass != null && closestClass.isAssignableFrom (entryClass)) {
                closestClass = entryClass;
                closestProducer = (ContentProducer) entry.getValue ();
            }
        }
    }
    if (! this.isAutonomous ()) {
        ContentProducer parentProducer = getParent ().getSuperClassContentProducer (targetClass, closestClass);
        if (parentProducer != null) {
            closestProducer = parentProducer;
        }
    }
    return closestProducer;
}


public void write (StorableOutput dw) {
    dw.writeInt (fContentProducers.size ());
    Map.Entry producerEntry;
    Iterator iter = fContentProducers.entrySet ().iterator ();
    while (iter.hasNext ()) {
        producerEntry = (Map.Entry) iter.next ();
        dw.writeString (((Class) producerEntry.getKey ()).getName ());
        dw.writeStorable ((Storable) producerEntry.getKey ());
    }
}


public void read (StorableInput dr) throws IOException {
    int prodCount = dr.readInt ();
    String prodClass;
    ContentProducer producer;
    for (int cnt = 0;
    cnt 

public ETSLADisposalStrategy () {
}


public ETSLADisposalStrategy (long periodicity) {
    gcPeriodicity = periodicity;
    initDisposalThread ();
}


public ETSLADisposalStrategy (DisposableResourceManager manager, int periodicity) {
    this.manager = manager;
    gcPeriodicity = periodicity;
    initDisposalThread ();
}


public synchronized void setManager (DisposableResourceManager manager) {
    if (manager == null) {
        stopDisposing (Long.MAX_VALUE);
    }
    this.manager = manager;
}


public DisposableResourceManager getManager () {
    return manager;
}


public void startDisposing () throws ResourceManagerNotSetException {
    if (manager == null) {
        throw new ResourceManagerNotSetException ();
    }
    if (disposingActive) {
        return;
    }
    disposingActive = true;
    disposalThread.start ();
}


public void stopDisposing (long millis) {
    if (! disposingActive) {
        return;
    }
    try {
        disposalThread.interruptDisposalPending = true;
        disposalThread.join (millis);
    } catch (InterruptedException ex) {
    } finally {
        disposingActive = false;
    }
}


protected void initDisposalThread () {
    if (disposalThread != null) {
        return;
    }
    disposalThread = new DisposalThread (this, gcPeriodicity);
}


protected synchronized void dispose () {
    synchronized (manager) {
        long currentTime = System.currentTimeMillis ();
        Iterator resourceIter = manager.getResources ();
        DisposableResourceHolder resource;
        while (resourceIter.hasNext ()) {
            resource = (DisposableResourceHolder) resourceIter.next ();
            synchronized (resource) {
                if (! resource.isLocked () && (resource.getLastTimeAccessed () + resource.getDisposableDelay ()) 

public long getPeriodicity () {
    return gcPeriodicity;
}


public void setPeriodicity (int newPeriodicity) {
    gcPeriodicity = newPeriodicity;
    if (disposalThread != null) {
        disposalThread.setPeriodicity (newPeriodicity);
    }
}


DisposalThread (ETSLADisposalStrategy strategy, long periodicity) {
    this.strategy = strategy;
    this.periodicity = periodicity;
}


public void run () {
    interruptDisposalPending = false;
    while (! interruptDisposalPending) {
        try {
            sleep (periodicity);
        } catch (Exception ex) {
            break;
        }
        strategy.dispose ();
    }
    interruptDisposalPending = false;
}


public long getPeriodicity () {
    return periodicity;
}


public void setPeriodicity (long newPeriodicity) {
    periodicity = newPeriodicity;
}


public void interruptDisposal () {
    interruptDisposalPending = true;
}


public HTMLTextAreaTool (DrawingEditor newDrawingEditor, Figure prototype) {
    super (newDrawingEditor, prototype);
}


protected Font getFont (TextHolder figure) {
    return new Font ("Helvetica", Font.PLAIN, 12);
}


public PolygonFigureGeometricAdapter () {
    super ();
}


public PolygonFigureGeometricAdapter (int x, int y) {
    super (x, y);
}


public PolygonFigureGeometricAdapter (Polygon p) {
    super (p);
}


public Shape getShape () {
    return getInternalPolygon ();
}


public HTMLLayouter () {
}


public HTMLLayouter (Layoutable newLayoutable) {
    this ();
}


public Rectangle calculateLayout (Point origin, Point corner) {
    throw new UnsupportedOperationException ("Method calculateLayout() not yet implemented.");
}


public Rectangle layout (Point origin, Point corner) {
    throw new UnsupportedOperationException ("Method layout() not yet implemented.");
}


public void setInsets (Insets newInsets) {
    throw new UnsupportedOperationException ("Method setInsets() not yet implemented.");
}


public Insets getInsets () {
    throw new UnsupportedOperationException ("Method getInsets() not yet implemented.");
}


public void write (StorableOutput dw) {
    throw new UnsupportedOperationException ("Method write() not yet implemented.");
}


public void read (StorableInput dr) throws IOException {
    throw new UnsupportedOperationException ("Method read() not yet implemented.");
}


public Layouter create (Layoutable newLayoutable) {
    return new HTMLLayouter (newLayoutable);
}


public TextHolderContentProducer () {
}


public TextHolderContentProducer (TextHolder figure) {
    fFigure = figure;
}


public Object getContent (ContentProducerContext context, String ctxAttrName, Object ctxAttrValue) {
    TextHolder figure = (fFigure != null) ? fFigure : (TextHolder) ctxAttrValue;
    return figure.getText ();
}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeStorable ((Figure) fFigure);
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    fFigure = (TextHolder) dr.readStorable ();
}


public DiamondFigureGeometricAdapter () {
    super ();
}


public DiamondFigureGeometricAdapter (Point origin, Point corner) {
    super (origin, corner);
}


public Shape getShape () {
    return getPolygon ();
}


public HTMLColorContentProducer () {
}


public Object getContent (ContentProducerContext context, String ctxAttrName, Object ctxAttrValue) {
    Color color = (getColor () != null) ? getColor () : (Color) ctxAttrValue;
    return getHTMLColorCode (color);
}


public static String getHTMLColorCode (Color color) {
    String colorCode = Integer.toHexString (color.getRGB ());
    return "#" + colorCode.substring (colorCode.length () - 6);
}


public EllipseFigureGeometricAdapter () {
    super ();
}


public EllipseFigureGeometricAdapter (Point origin, Point corner) {
    super (origin, corner);
}


public Shape getShape () {
    Rectangle rect = displayBox ();
    Ellipse2D.Float ellipse = new Ellipse2D.Float (rect.x, rect.y, rect.width, rect.height);
    return ellipse;
}


public ResourceContentProducer () {
}


public ResourceContentProducer (String resourceName) {
    fResourceName = resourceName;
}


public Object getContent (ContentProducerContext context, String ctxAttrName, Object ctxAttrValue) {
    try {
        String resourceName = (fResourceName != null) ? fResourceName : (String) ctxAttrValue;
        InputStream reader = this.getClass ().getResourceAsStream (resourceName);
        int available = reader.available ();
        byte contents [] = new byte [available];
        reader.read (contents, 0, available);
        reader.close ();
        return new String (contents);
    } catch (Exception ex) {
        ex.printStackTrace ();
        return ex.toString ();
    }
}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeString (fResourceName);
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    fResourceName = (String) dr.readString ();
}


public ResourceManagerNotSetException () {
}


public HTMLContentProducer () {
}


public Object getContent (ContentProducerContext context, String ctxAttrName, Object ctxAttrValue) {
    HTMLContentProducerContext htmlContext = (HTMLContentProducerContext) context;
    if (ctxAttrName.compareTo (ContentProducer.ENTITY_FONT_SIZE) == 0) {
        return Integer.toString (getHTMLFontSizeEquivalent (htmlContext.getFont ().getSize ()));
    }
    return super.getContent (context, ctxAttrName, ctxAttrValue);
}


public int getHTMLFontSizeEquivalent (int pointSize) {
    for (int i = 0;
    i = htmlFontSizeEquivalences [i] [1] && pointSize 

public static DisposableResourceManager getManager () {
    return currentManager;
}


public static void setStrategy (ResourceDisposabilityStrategy strategy) {
    currentStrategy = strategy;
}


public static DisposableResourceHolder createStandardHolder (Object resource) {
    initManager ();
    DisposableResourceHolder holder = (DisposableResourceHolder) holderPrototype.clone ();
    holder.setResource (resource);
    getManager ().registerResource (holder);
    return holder;
}


protected static void initManager () {
    if (currentManager == null) {
        if (holderPrototype == null) {
            holderPrototype = new StandardDisposableResourceHolder ();
        }
        if (currentStrategy == null) {
            currentStrategy = new ETSLADisposalStrategy (DEFAULT_DISPOSAL_PERIODICITY);
        }
        if (currentManager == null) {
            currentManager = new StandardDisposableResourceManager (currentStrategy);
        }
        try {
            currentManager.startDisposing ();
        } catch (ResourceManagerNotSetException ex) {
        }
    }
}


public DesktopEventService (Desktop newDesktop, Container newContainer) {
    setDesktop (newDesktop);
    setContainer (newContainer);
    getContainer ().addContainerListener (createComponentListener ());
}


private void setDesktop (Desktop newDesktop) {
    myDesktop = newDesktop;
}


protected Desktop getDesktop () {
    return myDesktop;
}


private void setContainer (Container newContainer) {
    myContainer = newContainer;
}


protected Container getContainer () {
    return myContainer;
}


public void addComponent (Component newComponent) {
    getContainer ().add (newComponent);
}


public void removeComponent (DrawingView dv) {
    Component [] comps = getContainer ().getComponents ();
    for (int x = 0;
    x 

public void removeAllComponents () {
    getContainer ().removeAll ();
}


public void addDesktopListener (DesktopListener dpl) {
    listenerList.add (DesktopListener.class, dpl);
}


public void removeDesktopListener (DesktopListener dpl) {
    listenerList.remove (DesktopListener.class, dpl);
}


protected void fireDrawingViewAddedEvent (final DrawingView dv) {
    final Object [] listeners = listenerList.getListenerList ();
    DesktopListener dpl;
    DesktopEvent dpe = createDesktopEvent (getActiveDrawingView (), dv);
    for (int i = listeners.length - 2;
    i >= 0; i -= 2) {
        if (listeners [i] == DesktopListener.class) {
            dpl = (DesktopListener) listeners [i + 1];
            dpl.drawingViewAdded (dpe);
        }
    }
}


protected void fireDrawingViewRemovedEvent (final DrawingView dv) {
    final Object [] listeners = listenerList.getListenerList ();
    DesktopListener dpl;
    DesktopEvent dpe = createDesktopEvent (getActiveDrawingView (), dv);
    for (int i = listeners.length - 2;
    i >= 0; i -= 2) {
        if (listeners [i] == DesktopListener.class) {
            dpl = (DesktopListener) listeners [i + 1];
            dpl.drawingViewRemoved (dpe);
        }
    }
}


protected void fireDrawingViewSelectedEvent (final DrawingView oldView, final DrawingView newView) {
    final Object [] listeners = listenerList.getListenerList ();
    DesktopListener dpl;
    DesktopEvent dpe = createDesktopEvent (oldView, newView);
    for (int i = listeners.length - 2;
    i >= 0; i -= 2) {
        if (listeners [i] == DesktopListener.class) {
            dpl = (DesktopListener) listeners [i + 1];
            dpl.drawingViewSelected (dpe);
        }
    }
}


protected DesktopEvent createDesktopEvent (DrawingView oldView, DrawingView newView) {
    return new DesktopEvent (getDesktop (), newView, oldView);
}


public DrawingView [] getDrawingViews (Component [] comps) {
    List al = CollectionsFactory.current ().createList ();
    for (int x = 0;
    x 

public DrawingView getActiveDrawingView () {
    return mySelectedView;
}


protected void setActiveDrawingView (DrawingView newActiveDrawingView) {
    mySelectedView = newActiveDrawingView;
}


protected ContainerListener createComponentListener () {
    return new ContainerAdapter () {
        public void componentAdded (ContainerEvent e) {
            DrawingView dv = Helper.getDrawingView ((java.awt.Container) e.getChild ());
            DrawingView oldView = getActiveDrawingView ();
            if (dv != null) {
                fireDrawingViewAddedEvent (dv);
                setActiveDrawingView (dv);
                fireDrawingViewSelectedEvent (oldView, getActiveDrawingView ());
            }
        } public void componentRemoved (ContainerEvent e) {
            DrawingView dv = Helper.getDrawingView ((java.awt.Container) e.getChild ());
            if (dv != null) {
                DrawingView oldView = getActiveDrawingView ();
                setActiveDrawingView (NullDrawingView.getManagedDrawingView (oldView.editor ()));
                fireDrawingViewSelectedEvent (oldView, getActiveDrawingView ());
                fireDrawingViewRemovedEvent (dv);
            }
        }}

    ;
}


public void componentAdded (ContainerEvent e) {
    DrawingView dv = Helper.getDrawingView ((java.awt.Container) e.getChild ());
    DrawingView oldView = getActiveDrawingView ();
    if (dv != null) {
        fireDrawingViewAddedEvent (dv);
        setActiveDrawingView (dv);
        fireDrawingViewSelectedEvent (oldView, getActiveDrawingView ());
    }
}


public void componentRemoved (ContainerEvent e) {
    DrawingView dv = Helper.getDrawingView ((java.awt.Container) e.getChild ());
    if (dv != null) {
        DrawingView oldView = getActiveDrawingView ();
        setActiveDrawingView (NullDrawingView.getManagedDrawingView (oldView.editor ()));
        fireDrawingViewSelectedEvent (oldView, getActiveDrawingView ());
        fireDrawingViewRemovedEvent (dv);
    }
}


public CompositeFigureCreationTool (DrawingEditor newDrawingEditor, Figure prototype) {
    super (newDrawingEditor, prototype);
}


public void mouseDown (MouseEvent e, int x, int y) {
    setView ((DrawingView) e.getSource ());
    Figure figure = drawing ().findFigure (e.getX (), e.getY ());
    if (figure != null) {
        figure = figure.getDecoratedFigure ();
        if (figure instanceof CompositeFigure) {
            setContainerFigure ((CompositeFigure) figure);
            setCreatedFigure (createFigure ());
            setAddedFigure ((getContainerFigure ().add (getCreatedFigure ())));
            getAddedFigure ().displayBox (new Point (x, y), new Point (x, y));
        } else {
            toolDone ();
        }
    } else {
        toolDone ();
    }
}


public void mouseMove (MouseEvent e, int x, int y) {
    if ((getContainerFigure () != null) && ! getContainerFigure ().containsPoint (e.getX (), e.getY ())) {
        toolDone ();
    } else {
        super.mouseMove (e, x, y);
    }
}


protected void setContainerFigure (CompositeFigure newContainerFigure) {
    myContainerFigure = newContainerFigure;
}


public CompositeFigure getContainerFigure () {
    return myContainerFigure;
}


protected void toolDone () {
    setCreatedFigure (null);
    setAddedFigure (null);
    setContainerFigure (null);
    editor ().toolDone ();
}


public MiniMapView (DrawingView newMappedDrawingView, JScrollPane subject) {
    m_subjectListener = new SubjectListener ();
    setSubject (subject);
    setMappedDrawingView (newMappedDrawingView);
    myDrawingChangeListener = new MappedDrawingChangeListener ();
    getMappedDrawingView ().drawing ().addDrawingChangeListener (myDrawingChangeListener);
    MouseListener ml = new MouseListener ();
    addMouseListener (new MouseListener ());
    addMouseMotionListener (ml);
}


protected void setMappedDrawingView (DrawingView newMappedDrawingView) {
    myMappedDrawingView = newMappedDrawingView;
}


public DrawingView getMappedDrawingView () {
    return myMappedDrawingView;
}


protected void setSubject (JScrollPane subject) {
    if (m_subject != null) {
        m_subject.getViewport ().removeChangeListener (m_subjectListener);
    }
    m_subject = subject;
    if (m_subject != null) {
        m_subject.getViewport ().addChangeListener (m_subjectListener);
    }
    repaint ();
}


public JScrollPane getSubject () {
    return m_subject;
}


public Color getViewBowColor () {
    return m_viewBoxColor;
}


public void setViewBoxColor (Color c) {
    m_viewBoxColor = c;
    repaint ();
}


protected Component getMappedComponent () {
    return (Component) getMappedDrawingView ();
}


public void paint (Graphics g) {
    Graphics2D g2d = (Graphics2D) g;
    Component mappedComponent = getMappedComponent ();
    AffineTransform at = getViewToMiniMapTransform (mappedComponent);
    g2d.transform (at);
    getMappedDrawingView ().drawAll (g2d);
    drawViewRectangle (g2d, getViewRectangle ());
}


protected void drawViewRectangle (Graphics2D g2d, Rectangle viewPortRectangle) {
    AffineTransform at = new AffineTransform ();
    at.setToIdentity ();
    g2d.setTransform (at);
    g2d.setColor (m_viewBoxColor);
    g2d.draw (viewPortRectangle);
}


protected AffineTransform getViewToMiniMapTransform (Component mappedComponent) {
    double scaleX = ((double) getWidth ()) / ((double) mappedComponent.getWidth ());
    double scaleY = ((double) getHeight ()) / ((double) mappedComponent.getHeight ());
    AffineTransform at = getInverseSubjectTransform ();
    at.concatenate (AffineTransform.getScaleInstance (scaleX, scaleY));
    return at;
}


protected AffineTransform getInverseSubjectTransform () {
    AffineTransform at = new AffineTransform ();
    at.setToIdentity ();
    return at;
}


protected Rectangle getViewRectangle () {
    Rectangle visiblePortion = m_subject.getViewportBorderBounds ();
    Point upperLeftViewPos = m_subject.getViewport ().getViewPosition ();
    double [] srcRecCorners = new double [4];
    double [] dstRecCorners = new double [4];
    srcRecCorners [0] = upperLeftViewPos.x + visiblePortion.getX ();
    srcRecCorners [1] = upperLeftViewPos.y + visiblePortion.getY ();
    srcRecCorners [2] = upperLeftViewPos.x + visiblePortion.getX () + visiblePortion.getWidth ();
    srcRecCorners [3] = upperLeftViewPos.y + visiblePortion.getY () + visiblePortion.getHeight ();
    getViewToMiniMapTransform (getMappedComponent ()).transform (srcRecCorners, 0, dstRecCorners, 0, srcRecCorners.length / 2);
    return new Rectangle ((int) dstRecCorners [0], (int) dstRecCorners [1], (int) (dstRecCorners [2] - dstRecCorners [0]), (int) (dstRecCorners [3] - dstRecCorners [1]));
}


protected void scrollSubjectTo (int upperLeftX, int upperLeftY) {
    AffineTransform at = null;
    try {
        at = getViewToMiniMapTransform (getMappedComponent ()).createInverse ();
    } catch (NoninvertibleTransformException nite) {
        nite.printStackTrace ();
        return;
    }
    double [] srcPoints = new double [2];
    double [] destPoints = new double [2];
    srcPoints [0] = upperLeftX;
    srcPoints [1] = upperLeftY;
    at.transform (srcPoints, 0, destPoints, 0, 1);
    if (destPoints [0] 

protected int [] getUpperLeftPointsFromCenter (int centerX, int centerY) {
    int [] upperLeft = new int [2];
    Rectangle oldRectangle = getViewRectangle ();
    upperLeft [0] = centerX - oldRectangle.width / 2;
    upperLeft [1] = centerY - oldRectangle.height / 2;
    return upperLeft;
}


public void mousePressed (MouseEvent e) {
    int [] rectangleUpperLeft = getUpperLeftPointsFromCenter (e.getX (), e.getY ());
    scrollSubjectTo (rectangleUpperLeft [0], rectangleUpperLeft [1]);
}


public void mouseDragged (MouseEvent e) {
    int [] rectangleUpperLeft = getUpperLeftPointsFromCenter (e.getX (), e.getY ());
    scrollSubjectTo (rectangleUpperLeft [0], rectangleUpperLeft [1]);
}


public void mouseMoved (MouseEvent e) {
}


public void stateChanged (ChangeEvent e) {
    repaint ();
}


public void drawingInvalidated (DrawingChangeEvent e) {
    repaint ();
}


public void drawingRequestUpdate (DrawingChangeEvent e) {
    repaint ();
}


public void drawingTitleChanged (DrawingChangeEvent e) {
}


public CustomSelectionTool (DrawingEditor editor) {
    super (editor);
}


public void mouseDown (MouseEvent e, int x, int y) {
    setView ((DrawingView) e.getSource ());
    if (e.isPopupTrigger ()) {
        handlePopupMenu (e, x, y);
    } else {
        super.mouseDown (e, x, y);
        handleMouseDown (e, x, y);
    }
}


public void mouseDrag (MouseEvent e, int x, int y) {
    if (! e.isPopupTrigger ()) {
        super.mouseDrag (e, x, y);
    }
}


public void mouseUp (MouseEvent e, int x, int y) {
    if (e.isPopupTrigger ()) {
        handlePopupMenu (e, x, y);
        super.mouseUp (e, x, y);
    } else if (e.getClickCount () == 2) {
        super.mouseUp (e, x, y);
        handleMouseDoubleClick (e, x, y);
    } else {
        super.mouseUp (e, x, y);
        handleMouseUp (e, x, y);
        handleMouseClick (e, x, y);
    }

}


protected void handleMouseDown (MouseEvent e, int x, int y) {
}


protected void handleMouseUp (MouseEvent e, int x, int y) {
}


protected void handleMouseClick (MouseEvent e, int x, int y) {
}


protected void handleMouseDoubleClick (MouseEvent e, int x, int y) {
}


protected void handlePopupMenu (MouseEvent e, int x, int y) {
    Figure figure = drawing ().findFigure (e.getX (), e.getY ());
    if (figure != null) {
        Object attribute = figure.getAttribute (Figure.POPUP_MENU);
        if (attribute == null) {
            figure = drawing ().findFigureInside (e.getX (), e.getY ());
        }
        if (figure != null) {
            showPopupMenu (figure, e.getX (), e.getY (), e.getComponent ());
        }
    }
}


protected void showPopupMenu (Figure figure, int x, int y, Component comp) {
    Object attribute = figure.getAttribute (Figure.POPUP_MENU);
    if ((attribute != null) && (attribute instanceof JPopupMenu)) {
        JPopupMenu popup = (JPopupMenu) attribute;
        if (popup instanceof PopupMenuFigureSelection) {
            ((PopupMenuFigureSelection) popup).setSelectedFigure (figure);
        }
        Point newLocation = new Point (x, y);
        adjustOffsets (comp.getParent (), newLocation);
        popup.setLocation (newLocation);
        popup.setInvoker (comp);
        popup.setVisible (true);
    }
}


private void adjustOffsets (Component comp, Point offsetPoint) {
    if (comp != null) {
        Point compLocation = comp.getLocation ();
        offsetPoint.translate (compLocation.x, compLocation.y);
        adjustOffsets (comp.getParent (), offsetPoint);
    }
}


public StandardLayouter () {
    this (null);
}


public StandardLayouter (Layoutable newLayoutable) {
    super (newLayoutable);
}


public Layouter create (Layoutable newLayoutable) {
    return new StandardLayouter (newLayoutable);
}


public Rectangle calculateLayout (Point origin, Point corner) {
    int maxWidth = Math.abs (corner.x - origin.x);
    int maxHeight = 0;
    FigureEnumeration fe = getLayoutable ().figures ();
    while (fe.hasNextFigure ()) {
        Figure currentFigure = fe.nextFigure ();
        Rectangle r = null;
        if (currentFigure instanceof Layoutable) {
            Layouter layoutStrategy = ((Layoutable) currentFigure).getLayouter ();
            r = layoutStrategy.calculateLayout (new Point (0, 0), new Point (0, 0));
            r.grow (layoutStrategy.getInsets ().left + layoutStrategy.getInsets ().right, layoutStrategy.getInsets ().top + layoutStrategy.getInsets ().bottom);
        } else {
            r = new Rectangle (currentFigure.displayBox ().getBounds ());
        }
        maxWidth = Math.max (maxWidth, r.width);
        maxHeight += r.height;
    }
    return new Rectangle (origin.x, origin.y, maxWidth, maxHeight);
}


public Rectangle layout (Point origin, Point corner) {
    Rectangle r = calculateLayout (origin, corner);
    int maxHeight = getInsets ().top;
    FigureEnumeration fe = getLayoutable ().figures ();
    while (fe.hasNextFigure ()) {
        Figure currentFigure = fe.nextFigure ();
        Point partOrigin = new Point (r.x + getInsets ().left, r.y + maxHeight);
        Point partCorner = new Point (r.x + getInsets ().left - getInsets ().right + r.width, r.y + currentFigure.displayBox ().height);
        currentFigure.displayBox (partOrigin, partCorner);
        maxHeight += currentFigure.displayBox ().height;
    }
    return new Rectangle (r.x, r.y, r.width, maxHeight + getInsets ().bottom);
}


public TriangleRotationHandle (TriangleFigure owner) {
    super (owner);
}


public void invokeStart (int x, int y, DrawingView view) {
    fOrigin = getOrigin ();
    TriangleRotationHandle.UndoActivity activity = (TriangleRotationHandle.UndoActivity) createUndoActivity (view);
    setUndoActivity (activity);
    activity.setAffectedFigures (new SingleFigureEnumerator (owner ()));
    double rotation = ((TriangleFigure) (owner ())).getRotationAngle ();
    activity.setRotationAngle (rotation);
}


public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
    Point fCenter = owner ().center ();
    double angle = Math.atan2 (fOrigin.y + y - anchorY - fCenter.y, fOrigin.x + x - anchorX - fCenter.x);
    ((TriangleFigure) (owner ())).rotate (angle);
}


public void invokeEnd (int x, int y, int anchorX, int anchorY, DrawingView view) {
    fOrigin = null;
}


public Point locate () {
    return getOrigin ();
}


Point getOrigin () {
    Polygon p = ((TriangleFigure) (owner ())).getPolygon ();
    Point first = new Point (p.xpoints [0], p.ypoints [0]);
    Point ctr = owner ().center ();
    double len = Geom.length (first.x, first.y, ctr.x, ctr.y);
    if (len == 0) {
        return new Point (first.x - HANDLESIZE / 2, first.y + HANDLESIZE / 2);
    }
    double u = HANDLESIZE / len;
    if (u > 1.0) {
        return new Point ((first.x * 3 + ctr.x) / 4, (first.y * 3 + ctr.y) / 4);
    } else {
        return new Point ((int) (first.x * (1.0 - u) + ctr.x * u), (int) (first.y * (1.0 - u) + ctr.y * u));
    }
}


public void draw (Graphics g) {
    Rectangle r = displayBox ();
    g.setColor (Color.yellow);
    g.fillOval (r.x, r.y, r.width, r.height);
    g.setColor (Color.black);
    g.drawOval (r.x, r.y, r.width, r.height);
}


protected Undoable createUndoActivity (DrawingView newView) {
    return new TriangleRotationHandle.UndoActivity (newView);
}


public UndoActivity (DrawingView newView) {
    super (newView);
    setUndoable (true);
    setRedoable (true);
}


public boolean undo () {
    if (! super.undo ()) {
        return false;
    }
    return resetRotationAngle ();
}


public boolean redo () {
    if (! isRedoable ()) {
        return false;
    }
    return resetRotationAngle ();
}


protected boolean resetRotationAngle () {
    FigureEnumeration fe = getAffectedFigures ();
    if (! fe.hasNextFigure ()) {
        return false;
    }
    TriangleFigure figure = (TriangleFigure) fe.nextFigure ();
    double backupAngle = figure.getRotationAngle ();
    figure.willChange ();
    figure.rotate (getRotationAngle ());
    figure.changed ();
    setRotationAngle (backupAngle);
    return true;
}


protected void setRotationAngle (double newRotationAngle) {
    myRotationAngle = newRotationAngle;
}


public double getRotationAngle () {
    return myRotationAngle;
}


public NestedCreationTool (DrawingEditor newDrawingEditor, Figure prototype) {
    super (newDrawingEditor, prototype);
}


public void mouseDown (MouseEvent e, int x, int y) {
    Figure figure = drawing ().findFigure (e.getX (), e.getY ());
    if (figure != null) {
        figure = figure.getDecoratedFigure ();
        if (figure instanceof CompositeFigure) {
            setContainerFigure ((CompositeFigure) figure);
            super.mouseDown (e, x, y);
        } else {
            toolDone ();
        }
    } else {
        toolDone ();
    }
}


public void mouseMove (MouseEvent e, int x, int y) {
    if ((getContainerFigure () != null) && ! getContainerFigure ().containsPoint (e.getX (), e.getY ())) {
        toolDone ();
    } else {
        super.mouseMove (e, x, y);
    }
}


public void mouseUp (MouseEvent e, int x, int y) {
    if ((getContainerFigure () != null) && (getCreatedFigure () != null) && getContainerFigure ().containsPoint (e.getX (), e.getY ())) {
        getContainerFigure ().add (getCreatedFigure ());
    }
    toolDone ();
}


protected void setContainerFigure (CompositeFigure newContainerFigure) {
    myContainerFigure = newContainerFigure;
}


public CompositeFigure getContainerFigure () {
    return myContainerFigure;
}


protected void toolDone () {
    setCreatedFigure (null);
    setAddedFigure (null);
    setContainerFigure (null);
    editor ().toolDone ();
}


public FloatingTextArea () {
    fEditWidget = new JEditorPane ();
    fEditScrollContainer = new JScrollPane (fEditWidget, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
    fEditScrollContainer.setCursor (Cursor.getPredefinedCursor (Cursor.DEFAULT_CURSOR));
    fEditScrollContainer.setBorder (BorderFactory.createLineBorder (Color.black));
}


public void createOverlay (Container container) {
    createOverlay (container, null);
}


public void createOverlay (Container container, Font font) {
    container.add (fEditScrollContainer, 0);
    if (font != null) {
        fEditWidget.setFont (font);
    }
    fContainer = container;
}


public void setBounds (Rectangle r, String text) {
    fEditWidget.setText (text);
    fEditScrollContainer.setBounds (r.x, r.y, r.width, r.height);
    fEditScrollContainer.setVisible (true);
    fEditWidget.setCaretPosition (0);
    fEditWidget.requestFocus ();
}


public String getText () {
    return fEditWidget.getText ();
}


public Dimension getPreferredSize (int cols) {
    return new Dimension (fEditWidget.getWidth (), fEditWidget.getHeight ());
}


public void endOverlay () {
    fContainer.requestFocus ();
    if (fEditScrollContainer != null) {
        fEditScrollContainer.setVisible (false);
        fContainer.remove (fEditScrollContainer);
        Rectangle bounds = fEditScrollContainer.getBounds ();
        fContainer.repaint (bounds.x, bounds.y, bounds.width, bounds.height);
    }
}


public TextAreaFigure () {
    fParagraphs = CollectionsFactory.current ().createList ();
    fDisplayBox = new Rectangle (0, 0, 30, 15);
    fFont = createFont ();
    fText = new String ("");
    fSizeIsDirty = true;
    fTextIsDirty = true;
    fFontIsDirty = true;
}


public String getText () {
    return fText;
}


public void setText (String newText) {
    if (! newText.equals (fText)) {
        markTextDirty ();
        fText = newText;
        changed ();
    }
}


public Rectangle textDisplayBox () {
    return displayBox ();
}


public Font createFont () {
    return new Font ((String) getAttribute ("FontName"), ((Integer) getAttribute ("FontStyle")).intValue (), ((Integer) getAttribute ("FontSize")).intValue ());
}


public boolean isReadOnly () {
    return fIsReadOnly;
}


public void setReadOnly (boolean newReadOnly) {
    fIsReadOnly = newReadOnly;
}


public boolean acceptsTyping () {
    return ! isReadOnly ();
}


protected void markTextDirty () {
    setTextDirty (true);
}


protected void setTextDirty (boolean newTextDirty) {
    fTextIsDirty = newTextDirty;
}


public boolean isTextDirty () {
    return fTextIsDirty;
}


protected void markSizeDirty () {
    setSizeDirty (true);
}


public void setSizeDirty (boolean newSizeIsDirty) {
    fSizeIsDirty = newSizeIsDirty;
}


public boolean isSizeDirty () {
    return fSizeIsDirty;
}


public Font getFont () {
    return fFont;
}


public void setFont (Font newFont) {
    willChange ();
    fFont = newFont;
    markSizeDirty ();
    markFontDirty ();
    attributesMap = new Hashtable (1);
    attributesMap.put (TextAttribute.FONT, newFont);
    changed ();
}


public int overlayColumns () {
    return 0;
}


public void basicDisplayBox (Point origin, Point corner) {
    Dimension prevSize = fDisplayBox.getSize ();
    fDisplayBox = new Rectangle (origin);
    fDisplayBox.add (corner);
    if (! fDisplayBox.getSize ().equals (prevSize)) {
        markSizeDirty ();
    }
}


public HandleEnumeration handles () {
    List handles = CollectionsFactory.current ().createList ();
    BoxHandleKit.addHandles (this, handles);
    return new HandleEnumerator (handles);
}


public Rectangle displayBox () {
    return new Rectangle (fDisplayBox.x, fDisplayBox.y, fDisplayBox.width, fDisplayBox.height);
}


public void moveBy (int x, int y) {
    willChange ();
    basicMoveBy (x, y);
    if (fLocator != null) {
        fLocator.moveBy (x, y);
    }
    changed ();
}


protected void basicMoveBy (int x, int y) {
    fDisplayBox.translate (x, y);
}


public void drawBackground (Graphics g) {
    Rectangle r = displayBox ();
    g.fillRect (r.x, r.y, r.width, r.height);
}


public void draw (Graphics g) {
    super.draw (g);
    drawText (g, displayBox ());
}


public void drawFrame (Graphics g) {
    Rectangle r = displayBox ();
    g.setColor ((Color) getAttribute ("FrameColor"));
    g.drawRect (r.x, r.y, r.width, r.height);
}


protected float drawText (Graphics g, Rectangle displayBox) {
    Graphics2D g2 = null;
    Shape savedClipArea = null;
    Color savedFontColor = null;
    Rectangle2D clipRect = null;
    RenderingHints savedRenderingHints = null;
    if (g != null) {
        g2 = (Graphics2D) g;
        savedRenderingHints = g2.getRenderingHints ();
        g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g2.setRenderingHint (RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
        Font savedFont = g2.getFont ();
        savedFontColor = g2.getColor ();
        savedClipArea = g2.getClip ();
        if (savedClipArea != null) {
            clipRect = displayBox.createIntersection ((Rectangle2D) savedClipArea);
        } else {
            clipRect = displayBox;
        }
        g2.setClip (clipRect);
        Color textColor = getTextColor ();
        if (! ColorMap.isTransparent (textColor)) {
            g2.setColor (textColor);
        }
        g2.setFont (getFont ());
    }
    FontRenderContext fontRenderCtx = new FontRenderContext (null, false, false);
    prepareText ();
    float leftMargin = displayBox.x + ((Float) getAttribute ("LeftMargin")).floatValue ();
    float rightMargin = displayBox.x + displayBox.width - ((Float) getAttribute ("RightMargin")).floatValue ();
    float topMargin = displayBox.y + ((Float) getAttribute ("TopMargin")).floatValue ();
    float [] tabStops = new float [40];
    float tabSize = ((Float) getAttribute ("TabSize")).floatValue () * getFontWidth ();
    float tabPos = tabSize;
    for (int tabCnt = 0;
    tabCnt = tabStops [tabStops.length - 1]) {
                    lineComplete = true;
                }

                if (! lineComplete) {
                    int j;
                    for (j = 0; horizontalPos >= tabStops [j]; j ++) {
                    }
                    horizontalPos = tabStops [j];
                }
            }
            verticalPos += maxAscent;
            Iterator layoutEnum = layouts.iterator ();
            Iterator positionEnum = penPositions.iterator ();
            while (layoutEnum.hasNext ()) {
                TextLayout nextLayout = (TextLayout) layoutEnum.next ();
                Float nextPosition = (Float) positionEnum.next ();
                if (g2 != null) {
                    nextLayout.draw (g2, nextPosition.floatValue (), verticalPos);
                }
            }
            verticalPos += maxDescent;
        }
    }
    if (g2 != null && verticalPos > clipRect.getMaxY () && clipRect.getMaxY () == displayBox.getMaxY ()) {
        Stroke savedStroke = g2.getStroke ();
        float [] dash = new float [2];
        dash [0] = 2f;
        dash [1] = 4f;
        g2.setStroke (new BasicStroke (1f, BasicStroke.CAP_SQUARE, BasicStroke.JOIN_MITER, 1f, dash, 0f));
        g2.setColor (Color.red);
        g2.drawLine ((int) clipRect.getMinX () + 1, (int) clipRect.getMaxY () - 1, (int) clipRect.getMaxX () - 1, (int) clipRect.getMaxY () - 1);
        g2.setStroke (savedStroke);
    }
    if (g2 != null) {
        if (savedClipArea != null) {
            g2.setClip (savedClipArea);
        }
        g2.setColor (savedFontColor);
        g2.setRenderingHints (savedRenderingHints);
    }
    return verticalPos;
}


protected void prepareText () {
    if (! isTextDirty ()) {
        return;
    }
    fParagraphs = CollectionsFactory.current ().createList ();
    String paragraphText;
    Point pos = new Point (- 1, - 1);
    while ((paragraphText = getNextParagraph (fText, pos)) != null) {
        if (paragraphText.length () == 0) {
            paragraphText = " ";
        }
        fParagraphs.add (paragraphText);
    }
    setTextDirty (false);
}


protected String getNextParagraph (String text, Point pos) {
    int start = pos.y + 1;
    if (start >= text.length ()) {
        return null;
    }
    pos.x = start;
    int end = text.indexOf ('\n', start);
    if (end == - 1) {
        end = text.length ();
    }
    pos.y = end;
    if (text.charAt (end - 1) == '\r') {
        return text.substring (start, end - 1);
    } else {
        return text.substring (start, end);
    }
}


public Object getAttribute (String name) {
    return super.getAttribute (name);
}


public void setAttribute (String name, Object value) {
    Font font = getFont ();
    if (name.equals ("FontSize")) {
        Integer s = (Integer) value;
        setFont (new Font (font.getName (), font.getStyle (), s.intValue ()));
        super.setAttribute (name, value);
    } else if (name.equals ("FontStyle")) {
        Integer s = (Integer) value;
        int style = font.getStyle ();
        if (s.intValue () == Font.PLAIN) {
            style = font.PLAIN;
        } else {
            style = style ^ s.intValue ();
        }
        setFont (new Font (font.getName (), style, font.getSize ()));
        super.setAttribute (name, new Integer (style));
    } else if (name.equals ("FontName")) {
        String n = (String) value;
        setFont (new Font (n, font.getStyle (), font.getSize ()));
        super.setAttribute (name, value);
    } else {
        super.setAttribute (name, value);
    }

}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeInt (fDisplayBox.x);
    dw.writeInt (fDisplayBox.y);
    dw.writeInt (fDisplayBox.width);
    dw.writeInt (fDisplayBox.height);
    dw.writeString (fText);
    dw.writeBoolean (fIsReadOnly);
    dw.writeStorable (fObservedFigure);
    dw.writeStorable (fLocator);
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    markSizeDirty ();
    markTextDirty ();
    markFontDirty ();
    fDisplayBox.x = dr.readInt ();
    fDisplayBox.y = dr.readInt ();
    fDisplayBox.width = dr.readInt ();
    fDisplayBox.height = dr.readInt ();
    fText = dr.readString ();
    fIsReadOnly = dr.readBoolean ();
    fObservedFigure = (Figure) dr.readStorable ();
    if (fObservedFigure != null) {
        fObservedFigure.addFigureChangeListener (this);
    }
    fLocator = (OffsetLocator) dr.readStorable ();
    setFont (createFont ());
}


protected void readObject (ObjectInputStream s) throws ClassNotFoundException, IOException {
    s.defaultReadObject ();
    if (fObservedFigure != null) {
        fObservedFigure.addFigureChangeListener (this);
    }
    markSizeDirty ();
    markTextDirty ();
    markFontDirty ();
}


public void connect (Figure figure) {
    if (fObservedFigure != null) {
        fObservedFigure.removeFigureChangeListener (this);
    }
    fObservedFigure = figure;
    fLocator = new OffsetLocator (figure.connectedTextLocator (this));
    fObservedFigure.addFigureChangeListener (this);
    updateLocation ();
}


public void disconnect (Figure disconnectFigure) {
    if (disconnectFigure != null) {
        disconnectFigure.removeFigureChangeListener (this);
    }
    fLocator = null;
}


public void figureInvalidated (FigureChangeEvent e) {
}


public void figureChanged (FigureChangeEvent e) {
    updateLocation ();
}


protected void updateLocation () {
    if (fLocator != null) {
        Point p = fLocator.locate (fObservedFigure);
        p.x -= size ().width / 2 + fDisplayBox.x;
        p.y -= size ().height / 2 + fDisplayBox.y;
        if (p.x != 0 || p.y != 0) {
            willChange ();
            basicMoveBy (p.x, p.y);
            changed ();
        }
    }
}


public void figureRemoved (FigureChangeEvent e) {
    if (listener () != null) {
        listener ().figureRemoved (new FigureChangeEvent (this));
    }
}


public void figureRequestRemove (FigureChangeEvent e) {
    if (listener () != null) {
        listener ().figureRequestRemove (new FigureChangeEvent (this));
    }
}


public void figureRequestUpdate (FigureChangeEvent e) {
}


protected float getFontWidth () {
    updateFontInfo ();
    return fFontWidth;
}


protected void updateFontInfo () {
    if (! isFontDirty ()) {
        return;
    }
    FontMetrics metrics = Toolkit.getDefaultToolkit ().getFontMetrics (getFont ());
    fFontWidth = metrics.charWidth ('W');
    setFontDirty (false);
}


public Color getTextColor () {
    return (Color) getAttribute ("TextColor");
}


public boolean isEmpty () {
    return (fText.length () == 0);
}


protected void markFontDirty () {
    setFontDirty (true);
}


public boolean isFontDirty () {
    return fFontIsDirty;
}


public void setFontDirty (boolean newFontIsDirty) {
    fFontIsDirty = newFontIsDirty;
}


public Figure getRepresentingFigure () {
    return this;
}


public ChopPolygonConnector () {
}


public ChopPolygonConnector (Figure owner) {
    super (owner);
}


protected Point chop (Figure target, Point from) {
    return ((PolygonFigure) target).chop (from);
}


public GraphicalCompositeFigure () {
    this (new RectangleFigure ());
}


public GraphicalCompositeFigure (Figure newPresentationFigure) {
    super ();
    setPresentationFigure (newPresentationFigure);
    initialize ();
}


protected void initialize () {
    if (getLayouter () != null) {
        setLayouter (getLayouter ().create (this));
    } else {
        setLayouter (new StandardLayouter (this));
    }
}


public Object clone () {
    Object cloneObject = super.clone ();
    ((GraphicalCompositeFigure) cloneObject).initialize ();
    return cloneObject;
}


public Rectangle displayBox () {
    return getPresentationFigure ().displayBox ();
}


public void basicDisplayBox (Point origin, Point corner) {
    Rectangle r = getLayouter ().layout (origin, corner);
    getPresentationFigure ().basicDisplayBox (r.getLocation (), new Point ((int) r.getMaxX (), (int) r.getMaxY ()));
}


protected void basicMoveBy (int dx, int dy) {
    super.basicMoveBy (dx, dy);
    getPresentationFigure ().moveBy (dx, dy);
}


public void update () {
    willChange ();
    layout ();
    change ();
    changed ();
}


public void draw (Graphics g) {
    getPresentationFigure ().draw (g);
    super.draw (g);
}


public HandleEnumeration handles () {
    List handles = CollectionsFactory.current ().createList ();
    BoxHandleKit.addHandles (this, handles);
    return new HandleEnumerator (handles);
}


public Object getAttribute (String name) {
    if (getPresentationFigure () != null) {
        return getPresentationFigure ().getAttribute (name);
    } else {
        return super.getAttribute (name);
    }
}


public Object getAttribute (FigureAttributeConstant attributeConstant) {
    if (getPresentationFigure () != null) {
        return getPresentationFigure ().getAttribute (attributeConstant);
    } else {
        return super.getAttribute (attributeConstant);
    }
}


public void setAttribute (String name, Object value) {
    if (getPresentationFigure () != null) {
        getPresentationFigure ().setAttribute (name, value);
    } else {
        super.setAttribute (name, value);
    }
}


public void setAttribute (FigureAttributeConstant attributeConstant, Object value) {
    if (getPresentationFigure () != null) {
        getPresentationFigure ().setAttribute (attributeConstant, value);
    } else {
        super.setAttribute (attributeConstant, value);
    }
}


public void setPresentationFigure (Figure newPresentationFigure) {
    myPresentationFigure = newPresentationFigure;
}


public Figure getPresentationFigure () {
    return myPresentationFigure;
}


public void layout () {
    if (getLayouter () != null) {
        Rectangle r = getLayouter ().calculateLayout (displayBox ().getLocation (), displayBox ().getLocation ());
        displayBox (r.getLocation (), new Point (r.x + r.width, r.y + r.height));
    }
}


public void setLayouter (Layouter newLayouter) {
    myLayouter = newLayouter;
}


public Layouter getLayouter () {
    return myLayouter;
}


protected void change () {
    if (listener () != null) {
        listener ().figureRequestUpdate (new FigureChangeEvent (this));
    }
}


public void figureRequestRemove (FigureChangeEvent e) {
    if (listener () != null) {
        if (includes (e.getFigure ())) {
            Rectangle r = invalidateRectangle (displayBox ());
            listener ().figureRequestRemove (new FigureChangeEvent (this, r, e));
        } else {
            super.figureRequestRemove (e);
        }
    }
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    setPresentationFigure ((Figure) dr.readStorable ());
    setLayouter ((Layouter) dr.readStorable ());
}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeStorable (getPresentationFigure ());
    dw.writeStorable (getLayouter ());
}


public MDI_DrawApplication () {
    this ("JHotDraw");
}


public MDI_DrawApplication (String title) {
    super (title);
}


protected DrawApplication createApplication () {
    return new MDI_DrawApplication ();
}


protected void createTools (JToolBar palette) {
    super.createTools (palette);
    Tool tool = new DragNDropTool (this);
    ToolButton tb = createToolButton (IMAGES + "SEL", "Drag N Drop Tool", tool);
    palette.add (tb);
}


public void promptNew () {
    newWindow (createDrawing ());
}


public void newWindow (Drawing newDrawing) {
    DrawingView newView = createDrawingView (newDrawing);
    getDesktop ().addToDesktop (newView, Desktop.PRIMARY);
    toolDone ();
}


protected DrawingView createInitialDrawingView () {
    return NullDrawingView.getManagedDrawingView (this);
}


public void newView () {
    if (! view ().isInteractive ()) {
        return;
    }
    newWindow (view ().drawing ());
    String copyTitle = getDrawingTitle ();
    if (copyTitle != null) {
        setDrawingTitle (copyTitle);
    } else {
        setDrawingTitle (getDefaultDrawingTitle ());
    }
}


protected Desktop createDesktop () {
    return new MDIDesktopPane (this);
}


public DrawingView [] views () {
    return getDesktop ().getAllFromDesktop (Desktop.PRIMARY);
}


public String getDefaultDrawingTitle () {
    return super.getDefaultDrawingTitle () + views ().length;
}


protected void setDrawingTitle (String drawingTitle) {
    getDesktop ().updateTitle (drawingTitle);
}


public SplitPaneDrawApplication () {
    this ("JHotDraw");
}


public SplitPaneDrawApplication (String title) {
    super (title);
}


protected Desktop createDesktop () {
    return new SplitPaneDesktop ();
}


public DNDFiguresTransferable (Object o) {
    this.o = o;
}


public DataFlavor [] getTransferDataFlavors () {
    return new DataFlavor [] {DNDFiguresFlavor};
}


public boolean isDataFlavorSupported (DataFlavor flavor) {
    return flavor.equals (DNDFiguresFlavor);
}


public Object getTransferData (DataFlavor flavor) throws UnsupportedFlavorException, IOException {
    if (isDataFlavorSupported (flavor) == false) {
        throw new UnsupportedFlavorException (flavor);
    }
    return o;
}


public DragNDropTool (DrawingEditor editor) {
    super (editor);
    comps = CollectionsFactory.current ().createList ();
}


public void viewCreated (DrawingView view) {
    super.viewCreated (view);
    if (DNDInterface.class.isInstance (view)) {
        DNDInterface dndi = (DNDInterface) view;
        dndi.setDropTargetActive (true);
        dndi.setDragSourceActive (false);
        comps.add (dndi);
    }
}


public void viewDestroying (DrawingView view) {
    if (DNDInterface.class.isInstance (view)) {
        DNDInterface dndi = (DNDInterface) view;
        dndi.setDropTargetActive (false);
        dndi.setDragSourceActive (false);
        comps.remove (dndi);
    }
    super.viewDestroying (view);
}


public void activate () {
    super.activate ();
    System.out.println ("DNDTool Activation");
    setDragSourceActive (true);
}


public void deactivate () {
    System.out.println ("DNDTool deactivation.");
    setDragSourceActive (false);
    super.deactivate ();
}


private void setDragSourceActive (boolean newState) {
    Iterator it = comps.iterator ();
    while (it.hasNext ()) {
        DNDInterface dndi = (DNDInterface) it.next ();
        dndi.setDragSourceActive (newState);
    }
}


public static void setCursor (int x, int y, DrawingView view) {
    if (view == null) {
        return;
    }
    Handle handle = view.findHandle (x, y);
    Figure figure = view.drawing ().findFigure (x, y);
    if (handle != null) {
        if (LocatorHandle.class.isInstance (handle)) {
            LocatorHandle lh = (LocatorHandle) handle;
            Locator loc = lh.getLocator ();
            if (RelativeLocator.class.isInstance (loc)) {
                RelativeLocator rl = (RelativeLocator) loc;
                if (rl.equals (RelativeLocator.north ())) {
                    view.setCursor (new Cursor (Cursor.N_RESIZE_CURSOR));
                } else if (rl.equals (RelativeLocator.northEast ())) {
                    view.setCursor (new Cursor (Cursor.NE_RESIZE_CURSOR));
                } else if (rl.equals (RelativeLocator.east ())) {
                    view.setCursor (new Cursor (Cursor.E_RESIZE_CURSOR));
                } else if (rl.equals (RelativeLocator.southEast ())) {
                    view.setCursor (new Cursor (Cursor.SE_RESIZE_CURSOR));
                } else if (rl.equals (RelativeLocator.south ())) {
                    view.setCursor (new Cursor (Cursor.S_RESIZE_CURSOR));
                } else if (rl.equals (RelativeLocator.southWest ())) {
                    view.setCursor (new Cursor (Cursor.SW_RESIZE_CURSOR));
                } else if (rl.equals (RelativeLocator.west ())) {
                    view.setCursor (new Cursor (Cursor.W_RESIZE_CURSOR));
                } else if (rl.equals (RelativeLocator.northWest ())) {
                    view.setCursor (new Cursor (Cursor.NW_RESIZE_CURSOR));
                }

            }
        }
    } else if (figure != null) {
        view.setCursor (new Cursor (Cursor.MOVE_CURSOR));
    } else {
        view.setCursor (Cursor.getDefaultCursor ());
    }

}


public void mouseMove (MouseEvent evt, int x, int y) {
    if (evt.getSource () == getActiveView ()) {
        setCursor (evt.getX (), evt.getY (), getActiveView ());
    }
}


public void mouseUp (MouseEvent e, int x, int y) {
    if (fChild != null) {
        fChild.mouseUp (e, x, y);
    }
    fChild = null;
    view ().unfreezeView ();
}


public void mouseDown (MouseEvent e, int x, int y) {
    super.mouseDown (e, x, y);
    if (fChild != null) {
        return;
    }
    view ().freezeView ();
    Handle handle = view ().findHandle (e.getX (), e.getY ());
    if (handle != null) {
        fChild = createHandleTracker (handle);
    } else {
        Figure figure = drawing ().findFigure (e.getX (), e.getY ());
        if (figure != null) {
            fChild = null;
            if (e.isShiftDown ()) {
                view ().toggleSelection (figure);
            } else if (! view ().isFigureSelected (figure)) {
                view ().clearSelection ();
                view ().addToSelection (figure);
            }

        } else {
            if (! e.isShiftDown ()) {
                view ().clearSelection ();
            }
            fChild = createAreaTracker ();
        }
    }
    if (fChild != null) {
        fChild.mouseDown (e, x, y);
    }
}


public void mouseDrag (MouseEvent e, int x, int y) {
    if (fChild != null) {
        fChild.mouseDrag (e, x, y);
    }
}


protected Tool createAreaTracker () {
    return new SelectAreaTracker (editor ());
}


protected Tool createDragTracker (DrawingEditor editor, Figure f) {
    return new DragTracker (editor, f);
}


protected Tool createHandleTracker (Handle handle) {
    return new HandleTracker (editor (), handle);
}


public DNDFigures (FigureEnumeration fe, Point origin) {
    this.figures = CollectionsFactory.current ().createList ();
    while (fe.hasNextFigure ()) {
        figures.add (fe.nextFigure ());
    }
    this.origin = origin;
}


public FigureEnumeration getFigures () {
    return new FigureEnumerator (figures);
}


public Point getOrigin () {
    return origin;
}


protected static Object ProcessReceivedData (DataFlavor flavor, Transferable transferable) {
    if (transferable == null) {
        return null;
    }
    try {
        if (flavor.equals (DataFlavor.stringFlavor)) {
            String str = (String) transferable.getTransferData (DataFlavor.stringFlavor);
            return str;
        } else if (flavor.equals (DataFlavor.javaFileListFlavor)) {
            java.util.List aList = (java.util.List) transferable.getTransferData (DataFlavor.javaFileListFlavor);
            File fList [] = new File [aList.size ()];
            aList.toArray (fList);
            return fList;
        } else if (flavor.equals (ASCIIFlavor)) {
            String txt = null;
            InputStream is = (InputStream) transferable.getTransferData (ASCIIFlavor);
            int length = is.available ();
            byte [] bytes = new byte [length];
            int n = is.read (bytes);
            if (n > 0) {
                txt = new String (bytes, 0, n);
            }
            return txt;
        } else if (flavor.equals (DNDFiguresTransferable.DNDFiguresFlavor)) {
            DNDFigures ff = (DNDFigures) transferable.getTransferData (DNDFiguresTransferable.DNDFiguresFlavor);
            return ff;
        } else {
            return null;
        }

    } catch (java.io.IOException ioe) {
        System.err.println (ioe);
        return null;
    } catch (UnsupportedFlavorException ufe) {
        System.err.println (ufe);
        return null;
    } catch (ClassCastException cce) {
        System.err.println (cce);
        return null;
    }
}


public boolean setDropTargetActive (boolean state) {
    if (state == true) {
        return createDropTarget ();
    } else {
        destroyDropTarget ();
        return false;
    }
}


public boolean setDragSourceActive (boolean state) {
    if (state == true) {
        return createDragGestureRecognizer ();
    } else {
        destroyDragGestreRecognizer ();
        return false;
    }
}


protected boolean createDropTarget () {
    if (Component.class.isInstance (view ())) {
        try {
            dt = new DropTarget ((Component) view (), DnDConstants.ACTION_COPY_OR_MOVE, this);
            System.out.println ("" + view () + " Initialized to DND.");
            return true;
        } catch (java.lang.NullPointerException npe) {
            System.err.println ("View Failed to initialize to DND.");
            System.err.println ("Container likely did not have peer before the DropTarget was added");
            System.err.println (npe);
            npe.printStackTrace ();
        }
    }
    return false;
}


protected void destroyDropTarget () {
    if (dt != null) {
        dt.setComponent (null);
        dt.removeDropTargetListener (this);
        dt = null;
    }
}


protected boolean createDragGestureRecognizer () {
    if (Component.class.isInstance (view ())) {
        Component c = (Component) view ();
        dgr = DragSource.getDefaultDragSource ().createDefaultDragGestureRecognizer (c, DnDConstants.ACTION_COPY_OR_MOVE, this);
        return true;
    } else return false;

}


protected void destroyDragGestreRecognizer () {
    System.out.println ("Destroying DGR");
    if (dgr != null) {
        dgr.removeDragGestureListener (this);
        dgr.setComponent (null);
        dgr = null;
    }
}


public void dragGestureRecognized (DragGestureEvent dge) {
    Component c = dge.getComponent ();
    if (DrawingView.class.isInstance (c)) {
        boolean found = false;
        DrawingView dv = (DrawingView) c;
        FigureEnumeration selectedElements = dv.selection ();
        if (selectedElements.hasNextFigure () == false) {
            return;
        }
        Point p = dge.getDragOrigin ();
        while (selectedElements.hasNextFigure ()) {
            Figure f = selectedElements.nextFigure ();
            if (f.containsPoint (p.x, p.y)) {
                found = true;
                break;
            }
        }
        if (found == true) {
            DNDFigures dndff = new DNDFigures (dv.selection (), p);
            DNDFiguresTransferable trans = new DNDFiguresTransferable (dndff);
            if (JComponent.class.isInstance (c)) {
                ((JComponent) c).setAutoscrolls (false);
            }
            dge.getDragSource ().startDrag (dge, null, trans, this);
        }
    }
}


public void dragEnter (DropTargetDragEvent dtde) {
    supportDropTargetDragEvent (dtde);
    if (fLastX == 0) {
        fLastX = dtde.getLocation ().x;
    }
    if (fLastY == 0) {
        fLastY = dtde.getLocation ().y;
    }
}


public void dragExit (DropTargetEvent dte) {
}


public void dragOver (DropTargetDragEvent dtde) {
    if (supportDropTargetDragEvent (dtde) == true) {
        int x = dtde.getLocation ().x;
        int y = dtde.getLocation ().y;
        if ((Math.abs (x - fLastX) > 0) || (Math.abs (y - fLastY) > 0)) {
            fLastX = x;
            fLastY = y;
        }
    }
}


public void drop (DropTargetDropEvent dtde) {
    System.out.println ("DropTargetDropEvent-drop");
    if (dtde.isDataFlavorSupported (DNDFiguresTransferable.DNDFiguresFlavor) == true) {
        System.out.println ("DNDFiguresFlavor");
        if ((dtde.getDropAction () & DnDConstants.ACTION_COPY_OR_MOVE) != 0) {
            System.out.println ("copy or move");
            if (dtde.isLocalTransfer () == false) {
                System.err.println ("Intra-JVM Transfers not implemented for figures yet.");
                return;
            }
            dtde.acceptDrop (dtde.getDropAction ());
            try {
                DNDFigures ff = (DNDFigures) ProcessReceivedData (DNDFiguresTransferable.DNDFiguresFlavor, dtde.getTransferable ());
                FigureEnumeration fe = ff.getFigures ();
                Point theO = ff.getOrigin ();
                view ().clearSelection ();
                Point newP = dtde.getLocation ();
                int dx = newP.x - theO.x;
                int dy = newP.y - theO.y;
                while (fe.hasNextFigure ()) {
                    Figure f = fe.nextFigure ();
                    f.moveBy (dx, dy);
                    view ().add (f);
                    if (dtde.getDropAction () == DnDConstants.ACTION_MOVE) view ().addToSelection (f);

                    System.out.println ("added to view");
                }
                view ().checkDamage ();
                dtde.getDropTargetContext ().dropComplete (true);
            } catch (NullPointerException npe) {
                npe.printStackTrace ();
                dtde.getDropTargetContext ().dropComplete (false);
            }
        } else {
            dtde.rejectDrop ();
        }
    } else if (dtde.isDataFlavorSupported (DataFlavor.stringFlavor)) {
        dtde.acceptDrop (dtde.getDropAction ());
        Object o = ProcessReceivedData (DataFlavor.stringFlavor, dtde.getTransferable ());
        if (o != null) {
            dtde.getDropTargetContext ().dropComplete (true);
        } else {
            dtde.getDropTargetContext ().dropComplete (false);
        }
    } else if (dtde.isDataFlavorSupported (ASCIIFlavor) == true) {
        dtde.acceptDrop (DnDConstants.ACTION_COPY);
        Object o = ProcessReceivedData (ASCIIFlavor, dtde.getTransferable ());
        if (o != null) {
            dtde.getDropTargetContext ().dropComplete (true);
        } else {
            dtde.getDropTargetContext ().dropComplete (false);
        }
    } else if (dtde.isDataFlavorSupported (DataFlavor.javaFileListFlavor)) {
        dtde.acceptDrop (DnDConstants.ACTION_COPY);
        java.io.File [] fList = (java.io.File []) ProcessReceivedData (DataFlavor.javaFileListFlavor, dtde.getTransferable ());
        if (fList != null) {
            for (int x = 0;
            x 

public void dropActionChanged (DropTargetDragEvent dtde) {
    supportDropTargetDragEvent (dtde);
}


protected boolean supportDropTargetDragEvent (DropTargetDragEvent dtde) {
    if (dtde.isDataFlavorSupported (DNDFiguresTransferable.DNDFiguresFlavor) == true) {
        if (dtde.getDropAction () == DnDConstants.ACTION_COPY) {
            dtde.acceptDrag (DnDConstants.ACTION_COPY);
            return true;
        } else if (dtde.getDropAction () == DnDConstants.ACTION_MOVE) {
            dtde.acceptDrag (DnDConstants.ACTION_MOVE);
            return true;
        } else {
            dtde.rejectDrag ();
            return false;
        }

    } else if (dtde.isDataFlavorSupported (ASCIIFlavor) == true) {
        dtde.acceptDrag (dtde.getDropAction ());
        return true;
    } else if (dtde.isDataFlavorSupported (DataFlavor.stringFlavor) == true) {
        dtde.acceptDrag (dtde.getDropAction ());
        return true;
    } else if (dtde.isDataFlavorSupported (DataFlavor.javaFileListFlavor) == true) {
        dtde.acceptDrag (dtde.getDropAction ());
        return true;
    } else {
        dtde.rejectDrag ();
        return false;
    }

}


public void dragDropEnd (DragSourceDropEvent dsde) {
    DrawingView view = (DrawingView) dsde.getDragSourceContext ().getComponent ();
    System.out.println ("DragSourceDropEvent-dragDropEnd");
    if (dsde.getDropSuccess () == true) {
        if (dsde.getDropAction () == DnDConstants.ACTION_MOVE) {
            DNDFigures df = (DNDFigures) ProcessReceivedData (DNDFiguresTransferable.DNDFiguresFlavor, dsde.getDragSourceContext ().getTransferable ());
            FigureEnumeration fe = df.getFigures ();
            if (fe != null) {
                while (fe.hasNextFigure ()) {
                    Figure f = fe.nextFigure ();
                    view.remove (f);
                    System.out.println ("removing " + f);
                }
                view.clearSelection ();
                view.checkDamage ();
            }
        } else if (dsde.getDropAction () == DnDConstants.ACTION_COPY) {
        }

    }
    if (autoscrollState != null) {
        Component c = dsde.getDragSourceContext ().getComponent ();
        if (JComponent.class.isInstance (c)) {
            JComponent jc = (JComponent) c;
            jc.setAutoscrolls (autoscrollState.booleanValue ());
            autoscrollState = null;
        }
    }
}


public void dragEnter (DragSourceDragEvent dsde) {
    if (autoscrollState == null) {
        Component c = dsde.getDragSourceContext ().getComponent ();
        if (JComponent.class.isInstance (c)) {
            JComponent jc = (JComponent) c;
            autoscrollState = new Boolean (jc.getAutoscrolls ());
            jc.setAutoscrolls (false);
        }
    }
}


public void dragExit (DragSourceEvent dse) {
}


public void dragOver (DragSourceDragEvent dsde) {
}


public void dropActionChanged (DragSourceDragEvent dsde) {
}


public TextAreaTool (DrawingEditor newDrawingEditor, Figure prototype) {
    super (newDrawingEditor, prototype);
}


public void mouseDown (MouseEvent e, int x, int y) {
    setView ((DrawingView) e.getSource ());
    Figure pressedFigure = drawing ().findFigureInside (x, y);
    TextHolder textHolder = null;
    if (pressedFigure != null) {
        textHolder = pressedFigure.getTextHolder ();
    }
    if ((textHolder != null) && (textHolder.acceptsTyping ())) {
        beginEdit (textHolder, pressedFigure);
        return;
    }
    if (getTypingTarget () != null) {
        endEdit ();
        if (getCreatedFigure () != null && getCreatedFigure ().isEmpty ()) {
            drawing ().remove (getAddedFigure ());
            setUndoActivity (null);
        } else {
        }
        setTypingTarget (null);
        setCreatedFigure (null);
        setEditedFigure (null);
        setAddedFigure (null);
        editor ().toolDone ();
    } else {
        super.mouseDown (e, x, y);
    }
}


public void mouseDrag (MouseEvent e, int x, int y) {
    if (getCreatedFigure () == null) {
        return;
    }
    super.mouseDrag (e, x, y);
}


public void mouseUp (MouseEvent e, int x, int y) {
    if (getCreatedFigure () == null) {
        return;
    }
    view ().checkDamage ();
    TextHolder textHolder = (TextHolder) getCreatedFigure ();
    if (textHolder.acceptsTyping ()) {
        beginEdit (textHolder, getCreatedFigure ());
    } else {
        editor ().toolDone ();
    }
}


public void deactivate () {
    endEdit ();
    super.deactivate ();
}


public void activate () {
    super.activate ();
    getActiveView ().clearSelection ();
}


public boolean isActivated () {
    return getTypingTarget () != null;
}


protected void beginEdit (TextHolder figure, Figure selectedFigure) {
    if (fTextField == null) {
        fTextField = new FloatingTextArea ();
    }
    if (figure != getTypingTarget () && getTypingTarget () != null) {
        endEdit ();
    }
    fTextField.createOverlay ((Container) view (), getFont (figure));
    fTextField.setBounds (fieldBounds (figure), figure.getText ());
    setTypingTarget (figure);
    setEditedFigure (selectedFigure);
    setUndoActivity (createUndoActivity ());
}


protected Font getFont (TextHolder figure) {
    return figure.getFont ();
}


protected void endEdit () {
    if (getTypingTarget () != null) {
        if (fTextField.getText ().length () > 0) {
            getTypingTarget ().setText (fTextField.getText ());
            getUndoActivity ().setAffectedFigures (new SingleFigureEnumerator (getEditedFigure ()));
            ((TextAreaTool.UndoActivity) getUndoActivity ()).setBackupText (getTypingTarget ().getText ());
        } else {
            drawing ().orphan (getAddedFigure ());
        }
        fTextField.endOverlay ();
        fTextField = null;
    }
}


private Rectangle fieldBounds (TextHolder figure) {
    return figure.textDisplayBox ();
}


protected void setTypingTarget (TextHolder newTypingTarget) {
    fTypingTarget = newTypingTarget;
}


protected Figure getEditedFigure () {
    return fEditedFigure;
}


protected void setEditedFigure (Figure figure) {
    fEditedFigure = figure;
}


protected TextHolder getTypingTarget () {
    return fTypingTarget;
}


protected Undoable createUndoActivity () {
    return new TextAreaTool.UndoActivity (view (), getTypingTarget ().getText ());
}


public UndoActivity (DrawingView newDrawingView, String newOriginalText) {
    super (newDrawingView);
    setOriginalText (newOriginalText);
    setUndoable (true);
    setRedoable (true);
}


public boolean undo () {
    if (! super.undo ()) {
        return false;
    }
    getDrawingView ().clearSelection ();
    if (! isValidText (getOriginalText ())) {
        FigureEnumeration fe = getAffectedFigures ();
        while (fe.hasNextFigure ()) {
            getDrawingView ().drawing ().orphan (fe.nextFigure ());
        }
    } else if (! isValidText (getBackupText ())) {
        FigureEnumeration fe = getAffectedFigures ();
        while (fe.hasNextFigure ()) {
            getDrawingView ().add (fe.nextFigure ());
        }
        setText (getOriginalText ());
    } else {
        setText (getOriginalText ());
    }

    return true;
}


public boolean redo () {
    if (! super.redo ()) {
        return false;
    }
    getDrawingView ().clearSelection ();
    if (! isValidText (getBackupText ())) {
        FigureEnumeration fe = getAffectedFigures ();
        while (fe.hasNextFigure ()) {
            getDrawingView ().drawing ().orphan (fe.nextFigure ());
        }
    } else if (! isValidText (getOriginalText ())) {
        FigureEnumeration fe = getAffectedFigures ();
        while (fe.hasNextFigure ()) {
            getDrawingView ().drawing ().add (fe.nextFigure ());
            setText (getBackupText ());
        }
    } else {
        setText (getBackupText ());
    }

    return true;
}


protected boolean isValidText (String toBeChecked) {
    return ((toBeChecked != null) && (toBeChecked.length () > 0));
}


protected void setText (String newText) {
    FigureEnumeration fe = getAffectedFigures ();
    while (fe.hasNextFigure ()) {
        Figure currentFigure = fe.nextFigure ();
        if (currentFigure.getTextHolder () != null) {
            currentFigure.getTextHolder ().setText (newText);
        }
    }
}


public void setBackupText (String newBackupText) {
    myBackupText = newBackupText;
}


public String getBackupText () {
    return myBackupText;
}


public void setOriginalText (String newOriginalText) {
    myOriginalText = newOriginalText;
}


public String getOriginalText () {
    return myOriginalText;
}


public DiamondFigure () {
    super (new Point (0, 0), new Point (0, 0));
}


public DiamondFigure (Point origin, Point corner) {
    super (origin, corner);
}


protected Polygon getPolygon () {
    Rectangle r = displayBox ();
    Polygon p = new Polygon ();
    p.addPoint (r.x, r.y + r.height / 2);
    p.addPoint (r.x + r.width / 2, r.y);
    p.addPoint (r.x + r.width, r.y + r.height / 2);
    p.addPoint (r.x + r.width / 2, r.y + r.height);
    return p;
}


public void draw (Graphics g) {
    Polygon p = getPolygon ();
    g.setColor (getFillColor ());
    g.fillPolygon (p);
    g.setColor (getFrameColor ());
    g.drawPolygon (p);
}


public Insets connectionInsets () {
    Rectangle r = displayBox ();
    return new Insets (r.height / 2, r.width / 2, r.height / 2, r.width / 2);
}


public boolean containsPoint (int x, int y) {
    return getPolygon ().contains (x, y);
}


public Point chop (Point p) {
    return PolygonFigure.chop (getPolygon (), p);
}


public Connector connectorAt (int x, int y) {
    return new ChopDiamondConnector (this);
}


public CommandCheckBoxMenuItem (Command command) {
    super (command.name ());
    setCommand (command);
}


public CommandCheckBoxMenuItem (Command command, Icon icon) {
    super (command.name (), icon);
    setCommand (command);
}


public CommandCheckBoxMenuItem (Command command, boolean b) {
    super (command.name (), b);
    setCommand (command);
}


public CommandCheckBoxMenuItem (Command command, Icon icon, boolean b) {
    super (command.name (), icon, b);
    setCommand (command);
}


public Command getCommand () {
    return fCommand;
}


public void setCommand (Command newCommand) {
    fCommand = newCommand;
}


public SplitConnectionTool (DrawingEditor newDrawingEditor, ConnectionFigure newPrototype) {
    super (newDrawingEditor, newPrototype);
}


public void mouseDown (MouseEvent e, int x, int y) {
    setView ((DrawingView) e.getSource ());
    int ex = e.getX ();
    int ey = e.getY ();
    if (getTargetFigure () == null) {
        setTargetFigure (findConnectableFigure (ex, ey, drawing ()));
    } else {
        if (getAddedFigure () == null) {
            setConnection (createConnection ());
            setStartConnector (findConnector (ex, ey, getTargetFigure ()));
            getConnection ().connectStart (getStartConnector ());
            getConnection ().startPoint (ex, ey);
            setAddedFigure (view ().add (getConnection ()));
        }
        Figure c = findTarget (ex, ey, drawing ());
        if (c != null) {
            setEndConnector (findConnector (ex, ex, c));
            getConnection ().connectEnd (getEndConnector ());
            getConnection ().endPoint (ex, ey);
            setUndoActivity (createUndoActivity ());
            getUndoActivity ().setAffectedFigures (new SingleFigureEnumerator (getAddedFigure ()));
            getConnection ().updateConnection ();
            init ();
            editor ().toolDone ();
        } else {
            if (getEndConnector () == null) {
                Figure tempEndFigure = new NullFigure ();
                tempEndFigure.basicDisplayBox (new Point (ex, ey), new Point (ex, ey));
                setEndConnector (new NullConnector (tempEndFigure));
                getConnection ().connectEnd (getEndConnector ());
                getConnection ().endPoint (ex, ey);
                getConnection ().updateConnection ();
            } else {
                ((PolyLineFigure) getConnection ()).addPoint (ex, ey);
            }
        }
    }
}


public void mouseUp (MouseEvent e, int x, int y) {
    if (e.getClickCount () == 2) {
        init ();
        editor ().toolDone ();
    }
}


public void mouseMove (MouseEvent e, int x, int y) {
}


public void mouseDrag (MouseEvent e, int x, int y) {
}


public void deactivate () {
    if (getConnection () != null) {
        view ().remove (getConnection ());
    }
    super.deactivate ();
    init ();
}


protected void init () {
    setConnection (null);
    setStartConnector (null);
    setEndConnector (null);
    setAddedFigure (null);
    setTargetFigure (null);
}


public PolygonTool (DrawingEditor newDrawingEditor) {
    super (newDrawingEditor);
}


public void activate () {
    super.activate ();
    fPolygon = null;
}


public void deactivate () {
    if (fPolygon != null) {
        fPolygon.smoothPoints ();
        if (fPolygon.pointCount () 

private void addPoint (int x, int y) {
    if (fPolygon == null) {
        fPolygon = new PolygonFigure (x, y);
        setAddedFigure (view ().add (fPolygon));
        fPolygon.addPoint (x, y);
    } else if (fLastX != x || fLastY != y) {
        fPolygon.addPoint (x, y);
    }

    fLastX = x;
    fLastY = y;
}


public void mouseDown (MouseEvent e, int x, int y) {
    super.mouseDown (e, x, y);
    x = e.getX ();
    y = e.getY ();
    if (e.getClickCount () >= 2) {
        if (fPolygon != null) {
            fPolygon.smoothPoints ();
            setUndoActivity (createUndoActivity ());
            getUndoActivity ().setAffectedFigures (new SingleFigureEnumerator (getAddedFigure ()));
            editor ().toolDone ();
        }
        fPolygon = null;
    } else {
        addPoint (e.getX (), e.getY ());
    }
}


public void mouseMove (MouseEvent e, int x, int y) {
    if (e.getSource () == getActiveView ()) {
        if (fPolygon != null) {
            if (fPolygon.pointCount () > 1) {
                fPolygon.setPointAt (new Point (x, y), fPolygon.pointCount () - 1);
                getActiveView ().checkDamage ();
            }
        }
    }
}


public void mouseDrag (MouseEvent e, int x, int y) {
    x = e.getX ();
    y = e.getY ();
    addPoint (x, y);
}


public void mouseUp (MouseEvent e, int x, int y) {
}


protected Figure getAddedFigure () {
    return myAddedFigure;
}


private void setAddedFigure (Figure newAddedFigure) {
    myAddedFigure = newAddedFigure;
}


protected Undoable createUndoActivity () {
    return new PasteCommand.UndoActivity (view ());
}


public WindowMenu (String newText, MDIDesktopPane newDesktop, DrawingEditor newEditor) {
    super (newText);
    this.desktop = newDesktop;
    cascadeCommand = new AbstractCommand ("Cascade", newEditor) {
        public void execute () {
            WindowMenu.this.desktop.cascadeFrames ();
        } public boolean isExecutable () {
            return super.isExecutable () && (WindowMenu.this.desktop.getAllFrames ().length > 0);
        }}

    ;
    tileCommand = new AbstractCommand ("Tile", newEditor) {
        public void execute () {
            WindowMenu.this.desktop.tileFrames ();
        } public boolean isExecutable () {
            return super.isExecutable () && (WindowMenu.this.desktop.getAllFrames ().length > 0);
        }}

    ;
    addMenuListener (new MenuListener () {
        public void menuCanceled (MenuEvent e) {
        } public void menuDeselected (MenuEvent e) {
            removeAll ();
        } public void menuSelected (MenuEvent e) {
            buildChildMenus ();
        }}

    );
}


public void execute () {
    WindowMenu.this.desktop.cascadeFrames ();
}


public boolean isExecutable () {
    return super.isExecutable () && (WindowMenu.this.desktop.getAllFrames ().length > 0);
}


public void execute () {
    WindowMenu.this.desktop.tileFrames ();
}


public boolean isExecutable () {
    return super.isExecutable () && (WindowMenu.this.desktop.getAllFrames ().length > 0);
}


public void menuCanceled (MenuEvent e) {
}


public void menuDeselected (MenuEvent e) {
    removeAll ();
}


public void menuSelected (MenuEvent e) {
    buildChildMenus ();
}


private void buildChildMenus () {
    ChildMenuItem menu;
    JInternalFrame [] array = desktop.getAllFrames ();
    add (new CommandMenuItem (cascadeCommand));
    add (new CommandMenuItem (tileCommand));
    if (array.length > 0) {
        addSeparator ();
    }
    for (int i = 0;
    i 

public void actionPerformed (ActionEvent ae) {
    JInternalFrame frame = ((ChildMenuItem) ae.getSource ()).getFrame ();
    frame.moveToFront ();
    try {
        frame.setSelected (true);
    } catch (PropertyVetoException e) {
        e.printStackTrace ();
    }
}


public ChildMenuItem (JInternalFrame frame) {
    super (frame.getTitle ());
    this.frame = frame;
}


public JInternalFrame getFrame () {
    return frame;
}


public PolygonFigure () {
    super ();
    setInternalPolygon (new Polygon ());
}


public PolygonFigure (int x, int y) {
    this ();
    getInternalPolygon ().addPoint (x, y);
}


public PolygonFigure (Polygon p) {
    setInternalPolygon (new Polygon (p.xpoints, p.ypoints, p.npoints));
}


public Rectangle displayBox () {
    return bounds (getInternalPolygon ());
}


public boolean isEmpty () {
    return ((pointCount () 

public HandleEnumeration handles () {
    List handles = CollectionsFactory.current ().createList (pointCount ());
    for (int i = 0;
    i 

public void basicDisplayBox (Point origin, Point corner) {
    Rectangle r = displayBox ();
    int dx = origin.x - r.x;
    int dy = origin.y - r.y;
    getInternalPolygon ().translate (dx, dy);
    r = displayBox ();
    Point oldCorner = new Point (r.x + r.width, r.y + r.height);
    scaleRotate (oldCorner, getInternalPolygon (), corner);
}


public Polygon getPolygon () {
    return new Polygon (fPoly.xpoints, fPoly.ypoints, fPoly.npoints);
}


protected void setInternalPolygon (Polygon newPolygon) {
    fPoly = newPolygon;
}


public Polygon getInternalPolygon () {
    return fPoly;
}


public Point center () {
    return center (getInternalPolygon ());
}


public Iterator points () {
    List pts = CollectionsFactory.current ().createList (pointCount ());
    for (int i = 0;
    i 

public int pointCount () {
    return getInternalPolygon ().npoints;
}


public void basicMoveBy (int dx, int dy) {
    getInternalPolygon ().translate (dx, dy);
}


public void drawBackground (Graphics g) {
    g.fillPolygon (getInternalPolygon ());
}


public void drawFrame (Graphics g) {
    g.drawPolygon (getInternalPolygon ());
}


public boolean containsPoint (int x, int y) {
    return getInternalPolygon ().contains (x, y);
}


public Connector connectorAt (int x, int y) {
    return new ChopPolygonConnector (this);
}


public void addPoint (int x, int y) {
    getInternalPolygon ().addPoint (x, y);
    changed ();
}


public void setPointAt (Point p, int i) {
    willChange ();
    getInternalPolygon ().xpoints [i] = p.x;
    getInternalPolygon ().ypoints [i] = p.y;
    changed ();
}


public void insertPointAt (Point p, int i) {
    willChange ();
    int n = pointCount () + 1;
    int [] xs = new int [n];
    int [] ys = new int [n];
    for (int j = 0;
    j &lt i; ++ j) {
        xs [j] = getInternalPolygon ().xpoints [j];
        ys [j] = getInternalPolygon ().ypoints [j];
    }
    xs [i] = p.x;
    ys [i] = p.y;
    for (int j = i;
    j 

public void removePointAt (int i) {
    willChange ();
    int n = pointCount () - 1;
    int [] xs = new int [n];
    int [] ys = new int [n];
    for (int j = 0;
    j 

public void scaleRotate (Point anchor, Polygon originalPolygon, Point p) {
    willChange ();
    Point ctr = center (originalPolygon);
    double anchorLen = Geom.length (ctr.x, ctr.y, anchor.x, anchor.y);
    if (anchorLen > 0.0) {
        double newLen = Geom.length (ctr.x, ctr.y, p.x, p.y);
        double ratio = newLen / anchorLen;
        double anchorAngle = Math.atan2 (anchor.y - ctr.y, anchor.x - ctr.x);
        double newAngle = Math.atan2 (p.y - ctr.y, p.x - ctr.x);
        double rotation = newAngle - anchorAngle;
        int n = originalPolygon.npoints;
        int [] xs = new int [n];
        int [] ys = new int [n];
        for (int i = 0;
        i 

public void smoothPoints () {
    willChange ();
    boolean removed = false;
    int n = pointCount ();
    do {
        removed = false;
        int i = 0;
        while (i = 3) {
            int nxt = (i + 1) % n;
            int prv = (i - 1 + n) % n;
            if ((Geom.distanceFromLine (getInternalPolygon ().xpoints [prv], getInternalPolygon ().ypoints [prv], getInternalPolygon ().xpoints [nxt], getInternalPolygon ().ypoints [nxt], getInternalPolygon ().xpoints [i], getInternalPolygon ().ypoints [i]) 

public int splitSegment (int x, int y) {
    int i = findSegment (x, y);
    if (i != - 1) {
        insertPointAt (new Point (x, y), i + 1);
        return i + 1;
    } else {
        return - 1;
    }
}


public Point pointAt (int i) {
    return new Point (getInternalPolygon ().xpoints [i], getInternalPolygon ().ypoints [i]);
}


public Point outermostPoint () {
    Point ctr = center ();
    int outer = 0;
    long dist = 0;
    for (int i = 0;
    i  dist) {
            dist = d;
            outer = i;
        }
    }
    return new Point (getInternalPolygon ().xpoints [outer], getInternalPolygon ().ypoints [outer]);
}


public int findSegment (int x, int y) {
    double dist = TOO_CLOSE;
    int best = - 1;
    for (int i = 0;
    i 

public Point chop (Point p) {
    return chop (getInternalPolygon (), p);
}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeInt (pointCount ());
    for (int i = 0;
    i 

public void read (StorableInput dr) throws IOException {
    super.read (dr);
    int size = dr.readInt ();
    int [] xs = new int [size];
    int [] ys = new int [size];
    for (int i = 0;
    i 

public static Locator locator (final int pointIndex) {
    return new AbstractLocator () {
        public Point locate (Figure owner) {
            PolygonFigure plf = (PolygonFigure) owner;
            if (pointIndex 

public Point locate (Figure owner) {
    PolygonFigure plf = (PolygonFigure) owner;
    if (pointIndex 

public static Rectangle bounds (Polygon p) {
    int minx = Integer.MAX_VALUE;
    int miny = Integer.MAX_VALUE;
    int maxx = Integer.MIN_VALUE;
    int maxy = Integer.MIN_VALUE;
    int n = p.npoints;
    for (int i = 0;
    i  maxx) {
            maxx = x;
        }
        if (x  maxy) {
            maxy = y;
        }
        if (y 

public static Point center (Polygon p) {
    long sx = 0;
    long sy = 0;
    int n = p.npoints;
    for (int i = 0;
    i 

public static Point chop (Polygon poly, Point p) {
    Point ctr = center (poly);
    int cx = - 1;
    int cy = - 1;
    long len = Long.MAX_VALUE;
    for (int i = 0;
    i 

static public DrawingView getDrawingView (Container container) {
    DrawingView oldDrawingView = null;
    Component [] components = container.getComponents ();
    for (int i = 0;
    i 

static public DrawingView getDrawingView (Component component) {
    if (Container.class.isInstance (component)) {
        return getDrawingView ((Container) component);
    } else if (DrawingView.class.isInstance (component)) {
        return (DrawingView) component;
    } else {
        return null;
    }

}


public PolygonScaleHandle (PolygonFigure owner) {
    super (owner);
}


public void invokeStart (int x, int y, DrawingView view) {
    fCurrent = new Point (x, y);
    PolygonScaleHandle.UndoActivity activity = (PolygonScaleHandle.UndoActivity) createUndoActivity (view);
    setUndoActivity (activity);
    activity.setAffectedFigures (new SingleFigureEnumerator (owner ()));
    activity.setPolygon (((PolygonFigure) (owner ())).getPolygon ());
}


public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
    fCurrent = new Point (x, y);
    Polygon polygon = ((PolygonScaleHandle.UndoActivity) getUndoActivity ()).getPolygon ();
    ((PolygonFigure) (owner ())).scaleRotate (new Point (anchorX, anchorY), polygon, fCurrent);
}


public void invokeEnd (int x, int y, int anchorX, int anchorY, DrawingView view) {
    ((PolygonFigure) (owner ())).smoothPoints ();
    if ((fCurrent.x == anchorX) && (fCurrent.y == anchorY)) {
        setUndoActivity (null);
    }
    fCurrent = null;
}


public Point locate () {
    if (fCurrent == null) {
        return getOrigin ();
    } else {
        return fCurrent;
    }
}


Point getOrigin () {
    Point outer = ((PolygonFigure) (owner ())).outermostPoint ();
    Point ctr = ((PolygonFigure) (owner ())).center ();
    double len = Geom.length (outer.x, outer.y, ctr.x, ctr.y);
    if (len == 0) {
        return new Point (outer.x - HANDLESIZE / 2, outer.y + HANDLESIZE / 2);
    }
    double u = HANDLESIZE / len;
    if (u > 1.0) {
        return new Point ((outer.x * 3 + ctr.x) / 4, (outer.y * 3 + ctr.y) / 4);
    } else {
        return new Point ((int) (outer.x * (1.0 - u) + ctr.x * u), (int) (outer.y * (1.0 - u) + ctr.y * u));
    }
}


public void draw (Graphics g) {
    Rectangle r = displayBox ();
    g.setColor (Color.yellow);
    g.fillOval (r.x, r.y, r.width, r.height);
    g.setColor (Color.black);
    g.drawOval (r.x, r.y, r.width, r.height);
}


protected Undoable createUndoActivity (DrawingView newView) {
    return new PolygonScaleHandle.UndoActivity (newView);
}


public UndoActivity (DrawingView newView) {
    super (newView);
    setUndoable (true);
    setRedoable (true);
}


public boolean undo () {
    if (! super.undo ()) {
        return false;
    }
    return resetPolygon ();
}


public boolean redo () {
    if (! isRedoable ()) {
        return false;
    }
    return resetPolygon ();
}


protected boolean resetPolygon () {
    FigureEnumeration fe = getAffectedFigures ();
    if (! fe.hasNextFigure ()) {
        return false;
    }
    PolygonFigure figure = (PolygonFigure) fe.nextFigure ();
    Polygon backupPolygon = figure.getPolygon ();
    figure.willChange ();
    figure.setInternalPolygon (getPolygon ());
    figure.changed ();
    setPolygon (backupPolygon);
    return true;
}


protected void setPolygon (Polygon newPolygon) {
    myPolygon = newPolygon;
}


public Polygon getPolygon () {
    return myPolygon;
}


public static void main (String [] args) {
    SVGDrawApp window = new SVGDrawApp ();
    window.open ();
}


public SVGDrawApp () {
    super ("JHotDraw");
}


protected DrawApplication createApplication () {
    return new SVGDrawApp ();
}


public StorageFormatManager createStorageFormatManager () {
    StorageFormatManager storageFormatManager = new StorageFormatManager ();
    SVGStorageFormat format = new SVGStorageFormat ();
    storageFormatManager.addStorageFormat (format);
    storageFormatManager.setDefaultStorageFormat (format);
    return storageFormatManager;
}


public ZoomAreaTracker (DrawingEditor editor) {
    super (editor);
}


public void mouseUp (MouseEvent e, int x, int y) {
    Rectangle zoomArea = getArea ();
    super.mouseUp (e, x, y);
    if (zoomArea.width > 4 && zoomArea.height > 4) ((ZoomDrawingView) view ()).zoom (zoomArea.x, zoomArea.y, zoomArea.width, zoomArea.height);

}


public ScalingGraphics (Graphics realGraphics) {
    real = realGraphics;
}


public void setScale (double scale) {
    this.scale = scale;
}


public double getScale () {
    return scale;
}


private static Font scaledFont (Font f, double scale) {
    int size = f.getSize ();
    int scaledSize = (int) (size * scale);
    return new Font (f.getFamily (), f.getStyle (), scaledSize);
}


private static Shape scaledShape (Shape s, double scale) {
    if (s instanceof Rectangle) {
        Rectangle r = (Rectangle) s;
        return new Rectangle ((int) (r.x * scale), (int) (r.y * scale), (int) (r.width * scale), (int) (r.height * scale));
    } else {
        throw new RuntimeException ("Cannot scale shape: " + s.getClass ().getName ());
    }
}


public Graphics create () {
    Graphics realCopy = real.create ();
    ScalingGraphics result = new ScalingGraphics (realCopy);
    result.setScale (getScale ());
    return result;
}


public void translate (int x, int y) {
    real.translate ((int) (x * scale), (int) (y * scale));
}


public Color getColor () {
    return real.getColor ();
}


public void setColor (Color c) {
    real.setColor (c);
}


public void setPaintMode () {
    real.setPaintMode ();
}


public void setXORMode (Color c1) {
    real.setXORMode (c1);
}


public Font getFont () {
    if (userFont == null) userFont = real.getFont ();

    return userFont;
}


public void setFont (Font font) {
    userFont = font;
    real.setFont (scaledFont (font, scale));
}


public FontMetrics getFontMetrics () {
    return new ScalingFontMetrics (userFont, real.getFontMetrics ());
}


public FontMetrics getFontMetrics (Font f) {
    return new ScalingFontMetrics (f, real.getFontMetrics (scaledFont (f, scale)));
}


public Rectangle getClipBounds () {
    return userClip;
}


public void clipRect (int x, int y, int width, int height) {
    if (userClip == null) userClip = new Rectangle (x, y, width, height);
    else userClip = userClip.intersection (new Rectangle (x, y, width, height));

    real.clipRect ((int) (x * scale), (int) (y * scale), (int) (width * scale), (int) (height * scale));
}


public void setClip (int x, int y, int width, int height) {
    userClip = new Rectangle (x, y, width, height);
    real.setClip ((int) (x * scale), (int) (y * scale), (int) (width * scale), (int) (height * scale));
}


public Shape getClip () {
    return userClip;
}


public void setClip (Shape clip) {
    userClip = (Rectangle) clip;
    if (clip != null) real.setClip (scaledShape (clip, scale));
    else real.setClip (null);

}


public void copyArea (int x, int y, int width, int height, int dx, int dy) {
    real.copyArea ((int) (x * scale), (int) (y * scale), (int) (width * scale), (int) (height * scale), (int) (dx * scale), (int) (dy * scale));
}


public void drawLine (int x1, int y1, int x2, int y2) {
    real.drawLine ((int) (x1 * scale), (int) (y1 * scale), (int) (x2 * scale), (int) (y2 * scale));
}


public void fillRect (int x, int y, int width, int height) {
    real.fillRect ((int) (x * scale), (int) (y * scale), (int) (width * scale), (int) (height * scale));
}


public void clearRect (int x, int y, int width, int height) {
    real.clearRect ((int) (x * scale), (int) (y * scale), (int) (width * scale), (int) (height * scale));
}


public void drawRoundRect (int x, int y, int width, int height, int arcWidth, int arcHeight) {
    real.drawRoundRect ((int) (x * scale), (int) (y * scale), (int) (width * scale), (int) (height * scale), (int) (arcWidth * scale), (int) (arcHeight * scale));
}


public void fillRoundRect (int x, int y, int width, int height, int arcWidth, int arcHeight) {
    real.fillRoundRect ((int) (x * scale), (int) (y * scale), (int) (width * scale), (int) (height * scale), (int) (arcWidth * scale), (int) (arcHeight * scale));
}


public void drawOval (int x, int y, int width, int height) {
    real.drawOval ((int) (x * scale), (int) (y * scale), (int) (width * scale), (int) (height * scale));
}


public void fillOval (int x, int y, int width, int height) {
    real.fillOval ((int) (x * scale), (int) (y * scale), (int) (width * scale), (int) (height * scale));
}


public void drawArc (int x, int y, int width, int height, int startAngle, int arcAngle) {
    real.drawArc ((int) (x * scale), (int) (y * scale), (int) (width * scale), (int) (height * scale), startAngle, arcAngle);
}


public void fillArc (int x, int y, int width, int height, int startAngle, int arcAngle) {
    real.fillArc ((int) (x * scale), (int) (y * scale), (int) (width * scale), (int) (height * scale), startAngle, arcAngle);
}


public void drawPolyline (int xPoints [], int yPoints [], int nPoints) {
    int [] realXPoints = new int [nPoints];
    int [] realYPoints = new int [nPoints];
    for (int i = 0;
    i 

public void drawPolygon (int xPoints [], int yPoints [], int nPoints) {
    int [] realXPoints = new int [nPoints];
    int [] realYPoints = new int [nPoints];
    for (int i = 0;
    i 

public void fillPolygon (int xPoints [], int yPoints [], int nPoints) {
    int [] realXPoints = new int [nPoints];
    int [] realYPoints = new int [nPoints];
    for (int i = 0;
    i 

public void drawString (String str, int x, int y) {
    real.drawString (str, (int) (x * scale), (int) (y * scale));
}


public void drawString (java.text.AttributedCharacterIterator iterator, int x, int y) {
    real.drawString (iterator, (int) (x * scale), (int) (y * scale));
}


public boolean drawImage (Image img, int x, int y, ImageObserver observer) {
    if (img instanceof DoubleBufferImage) return real.drawImage (((DoubleBufferImage) img).getRealImage (), x, y, observer);
    else return real.drawImage (img, (int) (x * scale), (int) (y * scale), (int) (img.getWidth (observer) * scale), (int) (img.getHeight (observer) * scale), observer);

}


public boolean drawImage (Image img, int x, int y, int width, int height, ImageObserver observer) {
    if (img instanceof DoubleBufferImage) return real.drawImage (((DoubleBufferImage) img).getRealImage (), x, y, width, height, observer);
    else return real.drawImage (img, (int) (x * scale), (int) (y * scale), (int) (width * scale), (int) (height * scale), observer);

}


public boolean drawImage (Image img, int x, int y, Color bgcolor, ImageObserver observer) {
    if (img instanceof DoubleBufferImage) return real.drawImage (((DoubleBufferImage) img).getRealImage (), x, y, bgcolor, observer);
    else return real.drawImage (img, (int) (x * scale), (int) (y * scale), (int) (img.getWidth (observer) * scale), (int) (img.getHeight (observer) * scale), bgcolor, observer);

}


public boolean drawImage (Image img, int x, int y, int width, int height, Color bgcolor, ImageObserver observer) {
    if (img instanceof DoubleBufferImage) return real.drawImage (((DoubleBufferImage) img).getRealImage (), x, y, width, height, bgcolor, observer);
    else return real.drawImage (img, (int) (x * scale), (int) (y * scale), (int) (width * scale), (int) (height * scale), bgcolor, observer);

}


public boolean drawImage (Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2, ImageObserver observer) {
    if (img instanceof DoubleBufferImage) return real.drawImage (((DoubleBufferImage) img).getRealImage (), dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, observer);
    else return real.drawImage (img, (int) (dx1 * scale), (int) (dy1 * scale), (int) (dx2 * scale), (int) (dy2 * scale), (int) (sx1 * scale), (int) (sy1 * scale), (int) (sx2 * scale), (int) (sy2 * scale), observer);

}


public boolean drawImage (Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2, Color bgcolor, ImageObserver observer) {
    if (img instanceof DoubleBufferImage) return real.drawImage (((DoubleBufferImage) img).getRealImage (), dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, bgcolor, observer);
    else return real.drawImage (img, (int) (dx1 * scale), (int) (dy1 * scale), (int) (dx2 * scale), (int) (dy2 * scale), (int) (sx1 * scale), (int) (sy1 * scale), (int) (sx2 * scale), (int) (sy2 * scale), bgcolor, observer);

}


public void dispose () {
    real.dispose ();
}


public ScalingFontMetrics (Font userFont, FontMetrics real) {
    super (null);
    this.userFont = userFont;
    this.real = real;
}


public Font getFont () {
    return userFont;
}


public int getAscent () {
    return (int) (real.getAscent () / ScalingGraphics.this.getScale ());
}


public int getLeading () {
    return (int) (real.getLeading () / ScalingGraphics.this.getScale ());
}


public int getMaxAdvance () {
    return (int) (real.getMaxAdvance () / ScalingGraphics.this.getScale ());
}


public int charWidth (char ch) {
    return (int) (real.charWidth (ch) / ScalingGraphics.this.getScale ());
}


public int charsWidth (char [] data, int off, int len) {
    return (int) (real.charsWidth (data, off, len) / ScalingGraphics.this.getScale ());
}


public MiniMapZoomableView (DrawingView newMappedDrawingView, JScrollPane subject) {
    super (newMappedDrawingView, subject);
}


public AffineTransform getInverseSubjectTransform () {
    double subjectsScale = ((ZoomDrawingView) getMappedComponent ()).getScale ();
    AffineTransform at = null;
    try {
        at = AffineTransform.getScaleInstance (subjectsScale, subjectsScale).createInverse ();
    } catch (NoninvertibleTransformException nte) {
    }
    return at;
}


public ZoomCommand (String name, float scale, DrawingEditor newDrawingEditor) {
    super (name, newDrawingEditor, true);
    this.scale = scale;
}


public void execute () {
    super.execute ();
    zoomView ().zoom (scale);
}


public ZoomDrawingView zoomView () {
    Object view = super.view ();
    if (view instanceof ZoomDrawingView) {
        return (ZoomDrawingView) view;
    }
    throw new JHotDrawRuntimeException ("execute should NOT be getting called when view not instanceof ZoomDrawingView");
}


public float getScale () {
    return scale;
}


public void setScale (float newScale) {
    scale = newScale;
}


protected boolean isExecutableWithView () {
    return (view () instanceof ZoomDrawingView);
}


public DoubleBufferImage (Image real, double scale) {
    this.real = real;
    this.scale = scale;
}


public Image getRealImage () {
    return real;
}


public void flush () {
    real.flush ();
}


public Graphics getGraphics () {
    ScalingGraphics result = new ScalingGraphics (real.getGraphics ());
    result.setScale (scale);
    return result;
}


public int getHeight (ImageObserver observer) {
    return real.getHeight (observer);
}


public Object getProperty (String name, ImageObserver observer) {
    return real.getProperty (name, observer);
}


public Image getScaledInstance (int width, int height, int hints) {
    return real.getScaledInstance (width, height, hints);
}


public ImageProducer getSource () {
    return real.getSource ();
}


public int getWidth (ImageObserver observer) {
    return real.getWidth (observer);
}


public void draw (Graphics g, DrawingView view) {
    Dimension d = view.getSize ();
    if ((fOffscreen == null) || (d.width != fImagewidth) || (d.height != fImageheight)) {
        fOffscreen = view.createImage (d.width, d.height);
        fImagewidth = d.width;
        fImageheight = d.height;
    }
    Graphics g2 = fOffscreen.getGraphics ();
    Rectangle r = g.getClipBounds ();
    if (g2 instanceof ScalingGraphics) {
        ScalingGraphics s2 = (ScalingGraphics) g2;
        if (r != null) {
            r = new Rectangle ((int) ((r.x - 2) / s2.getScale ()), (int) ((r.y - 2) / s2.getScale ()), (int) ((r.width + 4) / s2.getScale ()), (int) ((r.height + 4) / s2.getScale ()));
            g.setClip (r);
        }
    }
    g2.setClip (r);
    view.drawAll (g2);
    g.drawImage (fOffscreen, 0, 0, view);
}


public ZoomTool (DrawingEditor editor) {
    super (editor);
}


public void mouseDown (MouseEvent e, int x, int y) {
    super.mouseDown (e, x, y);
    if ((e.getModifiers () & InputEvent.BUTTON1_MASK) != 0) {
        if (child != null) {
            return;
        }
        view ().freezeView ();
        child = new ZoomAreaTracker (editor ());
        child.mouseDown (e, x, y);
    } else if ((e.getModifiers () & InputEvent.BUTTON2_MASK) != 0) {
        ((ZoomDrawingView) view ()).deZoom (x, y);
    } else if ((e.getModifiers () & InputEvent.BUTTON3_MASK) != 0) {
        if ((e.getModifiers () & InputEvent.SHIFT_MASK) != 0) {
            ((ZoomDrawingView) view ()).zoomIn (x, y);
        } else if ((e.getModifiers () & InputEvent.CTRL_MASK) != 0) {
            ((ZoomDrawingView) view ()).deZoom (x, y);
        } else {
            ((ZoomDrawingView) view ()).zoomOut (x, y);
        }

    }

}


public void mouseDrag (MouseEvent e, int x, int y) {
    if (child != null) {
        child.mouseDrag (e, x, y);
    }
}


public void mouseUp (MouseEvent e, int x, int y) {
    if (child != null) {
        view ().unfreezeView ();
        child.mouseUp (e, x, y);
    }
    child = null;
}


public ZoomDrawingView (DrawingEditor editor) {
    this (editor, MINIMUM_WIDTH, MINIMUM_HEIGHT);
}


public ZoomDrawingView (DrawingEditor editor, int width, int height) {
    super (editor, width, height);
}


public final double getScale () {
    return scale;
}


private void setScale (double scale) {
    Dimension oldSize = getUserSize ();
    this.scale = scale;
    setUserSize (oldSize.width, oldSize.height);
    centralize (drawing ());
    forceRedraw ();
}


private void forceRedraw () {
    drawingInvalidated (new DrawingChangeEvent (drawing (), new Rectangle (getSize ())));
    repairDamage ();
}


public void setUserSize (int width, int height) {
    setSize ((int) (width * getScale ()), (int) (height * getScale ()));
}


public void setUserSize (Dimension d) {
    setUserSize (d.width, d.height);
}


public Dimension getSize () {
    return super.getSize ();
}


public Dimension getViewportSize () {
    return getParent ().getSize ();
}


protected boolean hasZoomSupport () {
    return getParent () instanceof JViewport;
}


public void setOriginPosition (Point newOrigin) {
    setViewPosition (newOrigin);
    forceRedraw ();
}


protected void setViewPosition (Point newPosition) {
    ((JViewport) getParent ()).setViewPosition (newPosition);
}


public Dimension getUserSize () {
    Dimension screenSize = getSize ();
    return new Dimension ((int) (screenSize.width / getScale ()), (int) (screenSize.height / getScale ()));
}


public void zoom (int x, int y, int width, int height) {
    if (hasZoomSupport ()) {
        Dimension viewportSize = getViewportSize ();
        double xScale = (double) viewportSize.width / (double) width;
        double yScale = (double) viewportSize.height / (double) height;
        double newScale = Math.min (xScale, yScale);
        Dimension userSize = getUserSize ();
        this.scale = newScale;
        setUserSize (userSize);
        revalidate ();
        setViewPosition (new Point ((int) (x * getScale ()), (int) (y * getScale ())));
        forceRedraw ();
    } else {
        throw new RuntimeException ("zooming only works if this view is contained in a ScrollPane");
    }
}


public void zoom (float scale) {
    if (hasZoomSupport ()) {
        JViewport viewport = (JViewport) getParent ();
        Dimension viewportSize = viewport.getSize ();
        Dimension userSize = getUserSize ();
        this.scale = scale;
        Point viewOrg = viewport.getViewPosition ();
        viewOrg.x = viewOrg.x + (viewportSize.width / 2);
        viewOrg.y = viewOrg.y + (viewportSize.height / 2);
        int xScreen = (int) (viewOrg.x * scale);
        int yScreen = (int) (viewOrg.y * scale);
        int xOrigin = xScreen - viewportSize.width / 2;
        int yOrigin = yScreen - viewportSize.height / 2;
        if (xOrigin 

public void zoomOut (int x, int y) {
    if (hasZoomSupport ()) {
        Dimension viewportSize = getViewportSize ();
        Dimension userSize = getUserSize ();
        this.scale = getScale () / getZoomSpeed ();
        int xScreen = (int) (x * getScale ());
        int yScreen = (int) (y * getScale ());
        int xOrigin = xScreen - viewportSize.width / 2;
        int yOrigin = yScreen - viewportSize.height / 2;
        if (xOrigin 

public void zoomIn (int x, int y) {
    if (hasZoomSupport ()) {
        JViewport viewport = (JViewport) getParent ();
        Dimension viewportSize = viewport.getSize ();
        Dimension userSize = getUserSize ();
        this.scale = getScale () * getZoomSpeed ();
        int xScreen = (int) (x * getScale ());
        int yScreen = (int) (y * getScale ());
        int xOrigin = xScreen - viewportSize.width / 2;
        int yOrigin = yScreen - viewportSize.height / 2;
        if (xOrigin 

public void deZoom (int x, int y) {
    if (hasZoomSupport ()) {
        Dimension viewportSize = getViewportSize ();
        Dimension userSize = getUserSize ();
        int xOrigin = x - viewportSize.width / 2;
        int yOrigin = y - viewportSize.height / 2;
        if (xOrigin 

public void paint (Graphics g) {
    super.paint (transformGraphics (g, getScale ()));
}


public Graphics getGraphics () {
    return transformGraphics (super.getGraphics (), getScale ());
}


private final Graphics transformGraphics (Graphics g, double scale) {
    if (scale != 1.0) {
        Graphics2D g2 = (Graphics2D) g;
        g2.transform (AffineTransform.getScaleInstance (scale, scale));
    }
    return g;
}


protected Point constrainPoint (Point p) {
    Dimension size = getSize ();
    p.x = Geom.range (1, (int) (size.width / getScale ()), p.x);
    p.y = Geom.range (1, (int) (size.height / getScale ()), p.y);
    if (getConstrainer () != null) {
        return getConstrainer ().constrainPoint (p);
    }
    return p;
}


public void drawBackground (Graphics g) {
    g.setColor (getBackground ());
    g.fillRect (0, 0, (int) (getBounds ().width / getScale ()), (int) (getBounds ().height / getScale ()));
}


private void centralize (Drawing d, Dimension bounds) {
    Point boundsCenter = new Point (bounds.width / 2, bounds.height / 2);
    Rectangle r = ((StandardDrawing) d).displayBox ();
    Point drawingCenter = new Point (r.x + r.width / 2, r.y + r.height / 2);
    int diffX = boundsCenter.x - drawingCenter.x;
    int diffY = boundsCenter.y - drawingCenter.y;
    if (diffX != 0 || diffY != 0) {
        for (FigureEnumeration fe = d.figures ();
        fe.hasNextFigure ();) {
            fe.nextFigure ().moveBy (diffX, diffY);
        }
    }
}


private void centralize (Drawing d) {
    centralize (d, getUserSize ());
}


public void setDrawing (Drawing d) {
    super.setDrawing (d);
    Rectangle r = ((StandardDrawing) d).displayBox ();
    Dimension drawingSize = new Dimension (r.width, r.height);
    Dimension viewportSize = new Dimension (r.width, r.height);
    if (getParent () != null) {
        viewportSize = getViewportSize ();
    }
    super.setPreferredSize (viewportSize);
    super.setSize (viewportSize);
    revalidate ();
}


public Dimension getMinimumSize () {
    return super.getSize ();
}


public Dimension getPreferredSize () {
    return getMinimumSize ();
}


public void repairDamage () {
    Rectangle damagedArea = getDamage ();
    if (damagedArea != null) {
        repaint ((int) (damagedArea.x * getScale ()), (int) (damagedArea.y * getScale ()), (int) (damagedArea.width * getScale ()), (int) (damagedArea.height * getScale ()));
        setDamage (null);
    }
}


public void drawingInvalidated (DrawingChangeEvent e) {
    Rectangle r = e.getInvalidatedRectangle ();
    if (getDamage () == null) {
        setDamage (r);
    } else {
        Rectangle damagedArea = getDamage ();
        damagedArea.add (r);
        setDamage (damagedArea);
    }
}


private MouseEvent createScaledEvent (MouseEvent e) {
    return new MouseEvent (e.getComponent (), e.getID (), e.getWhen (), e.getModifiers (), (int) (e.getX () / getScale ()), (int) (e.getY () / getScale ()), e.getClickCount (), e.isPopupTrigger ());
}


protected MouseListener createMouseListener () {
    return new StandardDrawingView.DrawingViewMouseListener () {
        public void mousePressed (MouseEvent e) {
            super.mousePressed (createScaledEvent (e));
        } public void mouseReleased (MouseEvent e) {
            super.mouseReleased (createScaledEvent (e));
        }}

    ;
}


public void mousePressed (MouseEvent e) {
    super.mousePressed (createScaledEvent (e));
}


public void mouseReleased (MouseEvent e) {
    super.mouseReleased (createScaledEvent (e));
}


protected MouseMotionListener createMouseMotionListener () {
    return new StandardDrawingView.DrawingViewMouseMotionListener () {
        public void mouseDragged (MouseEvent e) {
            super.mouseDragged (createScaledEvent (e));
        } public void mouseMoved (MouseEvent e) {
            super.mouseMoved (createScaledEvent (e));
        }}

    ;
}


public void mouseDragged (MouseEvent e) {
    super.mouseDragged (createScaledEvent (e));
}


public void mouseMoved (MouseEvent e) {
    super.mouseMoved (createScaledEvent (e));
}


protected KeyListener createKeyListener () {
    return new StandardDrawingView.DrawingViewKeyListener () {
        public void keyPressed (KeyEvent e) {
            super.keyPressed (e);
            if (e.getKeyChar () == ' ') {
                forceRedraw ();
            } else if (e.getKeyChar () == 'o') {
                setScale (getScale () / getZoomSpeed ());
            } else if (e.getKeyChar () == 'i') {
                setScale (getScale () * getZoomSpeed ());
            } else if (e.getKeyChar () == 'c') {
                centralize (drawing ());
            } else {
                super.keyPressed (e);
            }

        }}

    ;
}


public void keyPressed (KeyEvent e) {
    super.keyPressed (e);
    if (e.getKeyChar () == ' ') {
        forceRedraw ();
    } else if (e.getKeyChar () == 'o') {
        setScale (getScale () / getZoomSpeed ());
    } else if (e.getKeyChar () == 'i') {
        setScale (getScale () * getZoomSpeed ());
    } else if (e.getKeyChar () == 'c') {
        centralize (drawing ());
    } else {
        super.keyPressed (e);
    }

}


public double getZoomSpeed () {
    return zoomSpeed;
}


public void setZoomSpeed (double newZoomSpeed) {
    zoomSpeed = Math.max (1.1, newZoomSpeed);
}


protected AreaTracker (DrawingEditor editor) {
    super (editor);
}


public Rectangle getArea () {
    return new Rectangle (area.x, area.y, area.width, area.height);
}


public void mouseDown (MouseEvent e, int x, int y) {
    super.mouseDown (e, e.getX (), e.getY ());
    rubberBand (getAnchorX (), getAnchorY (), getAnchorX (), getAnchorY ());
}


public void mouseDrag (MouseEvent e, int x, int y) {
    super.mouseDrag (e, x, y);
    eraseRubberBand ();
    rubberBand (getAnchorX (), getAnchorY (), x, y);
}


public void mouseUp (MouseEvent e, int x, int y) {
    super.mouseUp (e, x, y);
    eraseRubberBand ();
}


private void rubberBand (int x1, int y1, int x2, int y2) {
    area = new Rectangle (new Point (x1, y1));
    area.add (new Point (x2, y2));
    drawXORRect (area);
}


private void eraseRubberBand () {
    drawXORRect (area);
}


private void drawXORRect (Rectangle r) {
    Graphics g = view ().getGraphics ();
    g.setXORMode (view ().getBackground ());
    g.setColor (Color.black);
    g.drawRect (r.x, r.y, r.width, r.height);
}


private SimpleLayouter () {
}


public SimpleLayouter (Layoutable newLayoutable) {
    setLayoutable (newLayoutable);
    setInsets (new Insets (0, 0, 0, 0));
}


public Layoutable getLayoutable () {
    return myLayoutable;
}


public void setLayoutable (Layoutable newLayoutable) {
    myLayoutable = newLayoutable;
}


public void setInsets (Insets newInsets) {
    myInsets = newInsets;
}


public Insets getInsets () {
    return myInsets;
}


public Layouter create (Layoutable newLayoutable) {
    SimpleLayouter newLayouter = new SimpleLayouter (newLayoutable);
    newLayouter.setInsets ((Insets) getInsets ().clone ());
    return newLayouter;
}


public Rectangle calculateLayout (Point origin, Point corner) {
    Rectangle maxRect = new Rectangle (origin);
    maxRect.add (corner);
    FigureEnumeration fe = getLayoutable ().figures ();
    while (fe.hasNextFigure ()) {
        Figure currentFigure = fe.nextFigure ();
        maxRect.union (currentFigure.displayBox ());
    }
    maxRect.width += getInsets ().left + getInsets ().right;
    maxRect.height += getInsets ().top + getInsets ().bottom;
    return maxRect;
}


public Rectangle layout (Point origin, Point corner) {
    return calculateLayout (origin, corner);
}


public void read (StorableInput dr) throws IOException {
    setLayoutable ((Layoutable) dr.readStorable ());
    setInsets (new Insets (dr.readInt (), dr.readInt (), dr.readInt (), dr.readInt ()));
}


public void write (StorableOutput dw) {
    dw.writeStorable (getLayoutable ());
    Insets i = getInsets ();
    dw.writeInt (i.top);
    dw.writeInt (i.left);
    dw.writeInt (i.bottom);
    dw.writeInt (i.right);
}


public AutoscrollHelper (int margin) {
    autoscrollMargin = margin;
}


public void setAutoscrollMargin (int margin) {
    autoscrollMargin = margin;
}


public int getAutoscrollMargin () {
    return autoscrollMargin;
}


public void autoscroll (Point location) {
    int top = 0, left = 0, bottom = 0, right = 0;
    Dimension size = getSize ();
    Rectangle rect = getVisibleRect ();
    int bottomEdge = rect.y + rect.height;
    int rightEdge = rect.x + rect.width;
    if (location.y - rect.y  0) top = autoscrollMargin;

    if (location.x - rect.x  0) left = autoscrollMargin;

    if (bottomEdge - location.y 

public Insets getAutoscrollInsets () {
    Dimension size = getSize ();
    Rectangle rect = getVisibleRect ();
    autoscrollInsets.top = rect.y + autoscrollMargin;
    autoscrollInsets.left = rect.x + autoscrollMargin;
    autoscrollInsets.bottom = size.height - (rect.y + rect.height) + autoscrollMargin;
    autoscrollInsets.right = size.width - (rect.x + rect.width) + autoscrollMargin;
    return autoscrollInsets;
}


public CTXWindowMenu (String newText, MDIDesktopPane newDesktop, DrawingEditor newEditor) {
    super (newText);
    this.desktop = newDesktop;
    cascadeCommand = new CommandMenuItem (new AbstractCommand ("Cascade", newEditor) {
        public void execute () {
            CTXWindowMenu.this.desktop.cascadeFrames ();
        } public boolean isExecutable () {
            return super.isExecutable () && (CTXWindowMenu.this.desktop.getAllFrames ().length > 0);
        }}

    );
    tileHCommand = new CommandMenuItem (new AbstractCommand ("Tile Horizontally", newEditor) {
        public void execute () {
            CTXWindowMenu.this.desktop.tileFramesHorizontally ();
        } public boolean isExecutable () {
            return super.isExecutable () && (CTXWindowMenu.this.desktop.getAllFrames ().length > 0);
        }}

    );
    tileVCommand = new CommandMenuItem (new AbstractCommand ("Tile Vertically", newEditor) {
        public void execute () {
            CTXWindowMenu.this.desktop.tileFramesVertically ();
        } public boolean isExecutable () {
            return super.isExecutable () && (CTXWindowMenu.this.desktop.getAllFrames ().length > 0);
        }}

    );
    arrangeHCommand = new CommandMenuItem (new AbstractCommand ("Arrange Horizontally", newEditor) {
        public void execute () {
            CTXWindowMenu.this.desktop.arrangeFramesHorizontally ();
        } public boolean isExecutable () {
            return super.isExecutable () && (CTXWindowMenu.this.desktop.getAllFrames ().length > 0);
        }}

    );
    arrangeVCommand = new CommandMenuItem (new AbstractCommand ("Arrange Vertically", newEditor) {
        public void execute () {
            CTXWindowMenu.this.desktop.arrangeFramesVertically ();
        } public boolean isExecutable () {
            return super.isExecutable () && (CTXWindowMenu.this.desktop.getAllFrames ().length > 0);
        }}

    );
    addMenuListener (new MenuListener () {
        public void menuCanceled (MenuEvent e) {
        } public void menuDeselected (MenuEvent e) {
            removeWindowsList ();
        } public void menuSelected (MenuEvent e) {
            buildChildMenus ();
        }}

    );
    add (cascadeCommand);
    add (tileHCommand);
    add (tileVCommand);
    add (arrangeHCommand);
    add (arrangeVCommand);
    staticItems = 5;
}


public void execute () {
    CTXWindowMenu.this.desktop.cascadeFrames ();
}


public boolean isExecutable () {
    return super.isExecutable () && (CTXWindowMenu.this.desktop.getAllFrames ().length > 0);
}


public void execute () {
    CTXWindowMenu.this.desktop.tileFramesHorizontally ();
}


public boolean isExecutable () {
    return super.isExecutable () && (CTXWindowMenu.this.desktop.getAllFrames ().length > 0);
}


public void execute () {
    CTXWindowMenu.this.desktop.tileFramesVertically ();
}


public boolean isExecutable () {
    return super.isExecutable () && (CTXWindowMenu.this.desktop.getAllFrames ().length > 0);
}


public void execute () {
    CTXWindowMenu.this.desktop.arrangeFramesHorizontally ();
}


public boolean isExecutable () {
    return super.isExecutable () && (CTXWindowMenu.this.desktop.getAllFrames ().length > 0);
}


public void execute () {
    CTXWindowMenu.this.desktop.arrangeFramesVertically ();
}


public boolean isExecutable () {
    return super.isExecutable () && (CTXWindowMenu.this.desktop.getAllFrames ().length > 0);
}


public void menuCanceled (MenuEvent e) {
}


public void menuDeselected (MenuEvent e) {
    removeWindowsList ();
}


public void menuSelected (MenuEvent e) {
    buildChildMenus ();
}


protected void removeWindowsList () {
    while (this.getItemCount () > staticItems) {
        remove (staticItems);
    }
}


private void buildChildMenus () {
    JInternalFrame [] array = desktop.getAllFrames ();
    cascadeCommand.setEnabled (array.length > 0);
    tileHCommand.setEnabled (array.length > 0);
    tileVCommand.setEnabled (array.length > 0);
    arrangeHCommand.setEnabled (array.length > 0);
    arrangeVCommand.setEnabled (array.length > 0);
    if (array.length == 0) {
        return;
    }
    addSeparator ();
    for (int i = 0;
    i 

public void actionPerformed (ActionEvent ae) {
    JInternalFrame frame = ((ChildMenuItem) ae.getSource ()).getFrame ();
    frame.moveToFront ();
    try {
        frame.setSelected (true);
    } catch (PropertyVetoException e) {
        e.printStackTrace ();
    }
}


public ChildMenuItem (JInternalFrame frame) {
    super (frame.getTitle ());
    this.frame = frame;
}


public JInternalFrame getFrame () {
    return frame;
}


public CommandMenuItem (Command command) {
    super (command.name ());
    setCommand (command);
    addActionListener (this);
}


public CommandMenuItem (Command command, Icon icon) {
    super (command.name (), icon);
    setCommand (command);
    addActionListener (this);
}


public CommandMenuItem (Command command, int mnemonic) {
    super (command.name (), mnemonic);
    setCommand (command);
}


public Command getCommand () {
    return fCommand;
}


public void setCommand (Command newCommand) {
    fCommand = newCommand;
}


public void actionPerformed (ActionEvent e) {
    getCommand ().execute ();
}


public TriangleFigure () {
    super (new Point (0, 0), new Point (0, 0));
}


public TriangleFigure (Point origin, Point corner) {
    super (origin, corner);
}


public HandleEnumeration handles () {
    List h = super.handles ().toList ();
    h.add (new TriangleRotationHandle (this));
    return new HandleEnumerator (h);
}


public void rotate (double angle) {
    willChange ();
    double dist = Double.MAX_VALUE;
    int best = 0;
    for (int i = 0;
    i 

public Polygon getPolygon () {
    Rectangle r = displayBox ();
    Polygon p = new Polygon ();
    switch (fRotation) {
        case 0 :
            p.addPoint (r.x + r.width / 2, r.y);
            p.addPoint (r.x + r.width, r.y + r.height);
            p.addPoint (r.x, r.y + r.height);
            break;
        case 1 :
            p.addPoint (r.x + r.width, r.y);
            p.addPoint (r.x + r.width, r.y + r.height);
            p.addPoint (r.x, r.y);
            break;
        case 2 :
            p.addPoint (r.x + r.width, r.y + r.height / 2);
            p.addPoint (r.x, r.y + r.height);
            p.addPoint (r.x, r.y);
            break;
        case 3 :
            p.addPoint (r.x + r.width, r.y + r.height);
            p.addPoint (r.x, r.y + r.height);
            p.addPoint (r.x + r.width, r.y);
            break;
        case 4 :
            p.addPoint (r.x + r.width / 2, r.y + r.height);
            p.addPoint (r.x, r.y);
            p.addPoint (r.x + r.width, r.y);
            break;
        case 5 :
            p.addPoint (r.x, r.y + r.height);
            p.addPoint (r.x, r.y);
            p.addPoint (r.x + r.width, r.y + r.height);
            break;
        case 6 :
            p.addPoint (r.x, r.y + r.height / 2);
            p.addPoint (r.x + r.width, r.y);
            p.addPoint (r.x + r.width, r.y + r.height);
            break;
        case 7 :
            p.addPoint (r.x, r.y);
            p.addPoint (r.x + r.width, r.y);
            p.addPoint (r.x, r.y + r.height);
            break;
    }
    return p;
}


public void draw (Graphics g) {
    Polygon p = getPolygon ();
    g.setColor (getFillColor ());
    g.fillPolygon (p);
    g.setColor (getFrameColor ());
    g.drawPolygon (p);
}


public Insets connectionInsets () {
    Rectangle r = displayBox ();
    switch (fRotation) {
        case 0 :
            return new Insets (r.height, r.width / 2, 0, r.width / 2);
        case 1 :
            return new Insets (0, r.width, r.height, 0);
        case 2 :
            return new Insets (r.height / 2, 0, r.height / 2, r.width);
        case 3 :
            return new Insets (r.height, r.width, 0, 0);
        case 4 :
            return new Insets (0, r.width / 2, r.height, r.width / 2);
        case 5 :
            return new Insets (r.height, 0, 0, r.width);
        case 6 :
            return new Insets (r.height / 2, r.width, r.height / 2, 0);
        case 7 :
            return new Insets (0, 0, r.height, r.width);
        default :
            return null;
    }
}


public boolean containsPoint (int x, int y) {
    return getPolygon ().contains (x, y);
}


public Point center () {
    return PolygonFigure.center (getPolygon ());
}


public Point chop (Point p) {
    return PolygonFigure.chop (getPolygon (), p);
}


public Object clone () {
    TriangleFigure figure = (TriangleFigure) super.clone ();
    figure.fRotation = fRotation;
    return figure;
}


public double getRotationAngle () {
    return rotations [fRotation];
}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeInt (fRotation);
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    fRotation = dr.readInt ();
}


public MDIDesktopPane (DrawApplication newDrawApplication) {
    setDrawApplication (newDrawApplication);
    manager = new MDIDesktopManager (this);
    setDesktopManager (manager);
    setDragMode (JDesktopPane.OUTLINE_DRAG_MODE);
    setAlignmentX (JComponent.LEFT_ALIGNMENT);
}


public void internalFrameOpened (InternalFrameEvent e) {
    DrawingView dv = Helper.getDrawingView (e.getInternalFrame ());
    fireDrawingViewAddedEvent (dv);
}


public void internalFrameClosed (InternalFrameEvent e) {
    DrawingView dv = Helper.getDrawingView (e.getInternalFrame ());
    if (getComponentCount () == 0) {
        setActiveDrawingView (null);
        fireDrawingViewSelectedEvent (selectedView);
    }
    fireDrawingViewRemovedEvent (dv);
}


public void internalFrameActivated (InternalFrameEvent e) {
    DrawingView dv = Helper.getDrawingView (e.getInternalFrame ());
    setActiveDrawingView (dv);
    fireDrawingViewSelectedEvent (selectedView);
}


private void fireDrawingViewAddedEvent (final DrawingView dv) {
    final Object [] listeners = listenerList.getListenerList ();
    DesktopListener dpl;
    DesktopEvent dpe = null;
    for (int i = listeners.length - 2;
    i >= 0; i -= 2) {
        if (listeners [i] == DesktopListener.class) {
            if (dpe == null) {
                dpe = new DesktopEvent (MDIDesktopPane.this, dv);
            }
            dpl = (DesktopListener) listeners [i + 1];
            dpl.drawingViewAdded (dpe);
        }
    }
}


private void fireDrawingViewRemovedEvent (final DrawingView dv) {
    final Object [] listeners = listenerList.getListenerList ();
    DesktopListener dpl;
    DesktopEvent dpe = null;
    for (int i = listeners.length - 2;
    i >= 0; i -= 2) {
        if (listeners [i] == DesktopListener.class) {
            if (dpe == null) {
                dpe = new DesktopEvent (MDIDesktopPane.this, dv);
            }
            dpl = (DesktopListener) listeners [i + 1];
            dpl.drawingViewRemoved (dpe);
        }
    }
}


private void fireDrawingViewSelectedEvent (final DrawingView dv) {
    final Object [] listeners = listenerList.getListenerList ();
    DesktopListener dpl;
    DesktopEvent dpe = null;
    for (int i = listeners.length - 2;
    i >= 0; i -= 2) {
        if (listeners [i] == DesktopListener.class) {
            if (dpe == null) {
                dpe = new DesktopEvent (MDIDesktopPane.this, dv);
            }
            dpl = (DesktopListener) listeners [i + 1];
            dpl.drawingViewSelected (dpe);
        }
    }
}


protected Component createContents (DrawingView dv) {
    JScrollPane sp = new JScrollPane ((Component) dv);
    sp.setVerticalScrollBarPolicy (JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
    sp.setHorizontalScrollBarPolicy (JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
    sp.setAlignmentX (LEFT_ALIGNMENT);
    String applicationTitle;
    if (dv.drawing ().getTitle () == null) {
        applicationTitle = getDrawApplication ().getApplicationName () + " - " + getDrawApplication ().getDefaultDrawingTitle ();
    } else {
        applicationTitle = getDrawApplication ().getApplicationName () + " - " + dv.drawing ().getTitle ();
    }
    JInternalFrame internalFrame = new JInternalFrame (applicationTitle, true, true, true, true);
    internalFrame.setName (applicationTitle);
    internalFrame.getContentPane ().add (sp);
    internalFrame.setSize (200, 200);
    return internalFrame;
}


public DrawingView getActiveDrawingView () {
    return selectedView;
}


protected void setActiveDrawingView (DrawingView newSelectedView) {
    selectedView = newSelectedView;
}


public void updateTitle (String newDrawingTitle) {
    getSelectedFrame ().setTitle (newDrawingTitle);
}


public void addToDesktop (DrawingView dv, int location) {
    JInternalFrame frame = (JInternalFrame) createContents (dv);
    JInternalFrame [] array = getAllFrames ();
    Point p = null;
    int w;
    int h;
    frame.addInternalFrameListener (internalFrameListener);
    Component retval = super.add (frame);
    checkDesktopSize ();
    if (array.length > 0) {
        p = array [0].getLocation ();
        p.x = p.x + FRAME_OFFSET;
        p.y = p.y + FRAME_OFFSET;
    } else {
        p = new Point (0, 0);
    }
    frame.setLocation (p.x, p.y);
    if (frame.isResizable ()) {
        w = getWidth () - (getWidth () / 3);
        h = getHeight () - (getHeight () / 3);
        if (w 

public void removeFromDesktop (DrawingView dv, int location) {
    Component [] comps = getComponents ();
    for (int x = 0;
    x 

public void removeAllFromDesktop (int location) {
    JInternalFrame [] jifs = getAllFrames ();
    for (int x = 0;
    x 

public DrawingView [] getAllFromDesktop (int location) {
    Component [] comps = getComponents ();
    java.util.ArrayList al = new java.util.ArrayList ();
    for (int x = 0;
    x 

public void addDesktopListener (DesktopListener dpl) {
    listenerList.add (DesktopListener.class, dpl);
}


public void removeDesktopListener (DesktopListener dpl) {
    listenerList.remove (DesktopListener.class, dpl);
}


public void cascadeFrames () {
    int x = 0;
    int y = 0;
    JInternalFrame [] allFrames = getAllFrames ();
    if (allFrames.length == 0) {
        return;
    }
    manager.setNormalSize ();
    int frameHeight = (getBounds ().height - 5) - allFrames.length * FRAME_OFFSET;
    int frameWidth = (getBounds ().width - 5) - allFrames.length * FRAME_OFFSET;
    for (int i = allFrames.length - 1;
    i >= 0; i --) {
        try {
            allFrames [i].setMaximum (false);
        } catch (PropertyVetoException e) {
            e.printStackTrace ();
        }
        allFrames [i].setBounds (x, y, frameWidth, frameHeight);
        x = x + FRAME_OFFSET;
        y = y + FRAME_OFFSET;
    }
    checkDesktopSize ();
}


public void tileFrames () {
    tileFramesHorizontally ();
}


public void tileFramesHorizontally () {
    Component [] allFrames = getAllFrames ();
    if (allFrames.length == 0) {
        return;
    }
    manager.setNormalSize ();
    int frameHeight = getBounds ().height / allFrames.length;
    int y = 0;
    for (int i = 0;
    i 

public void tileFramesVertically () {
    Component [] allFrames = getAllFrames ();
    if (allFrames.length == 0) {
        return;
    }
    manager.setNormalSize ();
    int frameWidth = getBounds ().width / allFrames.length;
    int x = 0;
    for (int i = 0;
    i 

public void arrangeFramesVertically () {
    Component [] allFrames = getAllFrames ();
    if (allFrames.length == 0) {
        return;
    }
    manager.setNormalSize ();
    int vertFrames = (int) Math.floor (Math.sqrt (allFrames.length));
    int horFrames = (int) Math.ceil (Math.sqrt (allFrames.length));
    int frameWidth = getBounds ().width / horFrames;
    int frameHeight = getBounds ().height / vertFrames;
    int x = 0;
    int y = 0;
    int frameIdx = 0;
    for (int horCnt = 0;
    horCnt 

public void arrangeFramesHorizontally () {
    Component [] allFrames = getAllFrames ();
    if (allFrames.length == 0) {
        return;
    }
    manager.setNormalSize ();
    int vertFrames = (int) Math.ceil (Math.sqrt (allFrames.length));
    int horFrames = (int) Math.floor (Math.sqrt (allFrames.length));
    int frameWidth = getBounds ().width / horFrames;
    int frameHeight = getBounds ().height / vertFrames;
    int x = 0;
    int y = 0;
    int frameIdx = 0;
    for (int vertCnt = 0;
    vertCnt 

public void setAllSize (Dimension d) {
    setMinimumSize (d);
    setMaximumSize (d);
    setPreferredSize (d);
    setBounds (0, 0, d.width, d.height);
}


public void setAllSize (int width, int height) {
    setAllSize (new Dimension (width, height));
}


private void checkDesktopSize () {
    if (getParent () != null && isVisible ()) manager.resizeDesktop ();

}


private void setDrawApplication (DrawApplication newDrawApplication) {
    myDrawApplication = newDrawApplication;
}


protected DrawApplication getDrawApplication () {
    return myDrawApplication;
}


public MDIDesktopManager (MDIDesktopPane newDesktop) {
    this.desktop = newDesktop;
}


public void endResizingFrame (JComponent f) {
    super.endResizingFrame (f);
    resizeDesktop ();
}


public void endDraggingFrame (JComponent f) {
    super.endDraggingFrame (f);
    resizeDesktop ();
}


public void setNormalSize () {
    JScrollPane scrollPane = getScrollPane ();
    Insets scrollInsets = getScrollPaneInsets ();
    if (scrollPane != null) {
        Dimension d = scrollPane.getVisibleRect ().getSize ();
        if (scrollPane.getBorder () != null) {
            d.setSize (d.getWidth () - scrollInsets.left - scrollInsets.right, d.getHeight () - scrollInsets.top - scrollInsets.bottom);
        }
        d.setSize (d.getWidth () - 20, d.getHeight () - 20);
        desktop.setAllSize (d);
        scrollPane.invalidate ();
        scrollPane.validate ();
    }
}


private Insets getScrollPaneInsets () {
    JScrollPane scrollPane = getScrollPane ();
    if ((scrollPane == null) || (getScrollPane ().getBorder () == null)) {
        return new Insets (0, 0, 0, 0);
    } else {
        return getScrollPane ().getBorder ().getBorderInsets (scrollPane);
    }
}


public JScrollPane getScrollPane () {
    if (desktop.getParent () instanceof JViewport) {
        JViewport viewPort = (JViewport) desktop.getParent ();
        if (viewPort.getParent () instanceof JScrollPane) return (JScrollPane) viewPort.getParent ();

    }
    return null;
}


protected void resizeDesktop () {
    int x = 0;
    int y = 0;
    JScrollPane scrollPane = getScrollPane ();
    Insets scrollInsets = getScrollPaneInsets ();
    if (scrollPane != null) {
        JInternalFrame allFrames [] = desktop.getAllFrames ();
        for (int i = 0;
        i  x) {
                x = allFrames [i].getX () + allFrames [i].getWidth ();
            }
            if (allFrames [i].getY () + allFrames [i].getHeight () > y) {
                y = allFrames [i].getY () + allFrames [i].getHeight ();
            }
        }
        Dimension d = scrollPane.getVisibleRect ().getSize ();
        if (scrollPane.getBorder () != null) {
            d.setSize (d.getWidth () - scrollInsets.left - scrollInsets.right, d.getHeight () - scrollInsets.top - scrollInsets.bottom);
        }
        if (x 

public SplitPaneDesktop () {
    setDesktopEventService (createDesktopEventService ());
    setAlignmentX (JSplitPane.LEFT_ALIGNMENT);
    setOneTouchExpandable (true);
    addPropertyChangeListener (createPropertyChangeListener ());
}


protected PropertyChangeListener createPropertyChangeListener () {
    return new PropertyChangeListener () {
        public void propertyChange (PropertyChangeEvent evt) {
            if (getRightComponent () != null) {
                getRightComponent ().repaint ();
            }
            if (getLeftComponent () != null) {
                getLeftComponent ().repaint ();
            }
        }}

    ;
}


public void propertyChange (PropertyChangeEvent evt) {
    if (getRightComponent () != null) {
        getRightComponent ().repaint ();
    }
    if (getLeftComponent () != null) {
        getLeftComponent ().repaint ();
    }
}


protected Component createContents (DrawingView dv, int location) {
    setRightComponent (createRightComponent (dv));
    setLeftComponent (createLeftComponent (dv));
    switch (location) {
        case Desktop.PRIMARY :
            {
                return getLeftComponent ();
            } case Desktop.SECONDARY :
            {
                return getRightComponent ();
            } default :
            {
                return null;
            }}
}


protected Component createRightComponent (DrawingView dv) {
    JScrollPane sp = new JScrollPane ((Component) dv);
    sp.setVerticalScrollBarPolicy (JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
    sp.setHorizontalScrollBarPolicy (JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
    sp.setAlignmentX (LEFT_ALIGNMENT);
    return sp;
}


protected Component createLeftComponent (DrawingView dv) {
    return new JScrollPane (new JList ());
}


public DrawingView getActiveDrawingView () {
    return getDesktopEventService ().getActiveDrawingView ();
}


public void addToDesktop (DrawingView dv, int location) {
    createContents (dv, Desktop.PRIMARY);
    setDividerLocation (getInitDividerLocation ());
}


protected int getInitDividerLocation () {
    return 150;
}


public void removeFromDesktop (DrawingView dv, int location) {
    Component [] comps = getContainer ().getComponents ();
    for (int x = 0;
    x 

public void removeAllFromDesktop (int location) {
    getContainer ().removeAll ();
}


public DrawingView [] getAllFromDesktop (int location) {
    return getDesktopEventService ().getDrawingViews (getComponents ());
}


public void addDesktopListener (DesktopListener dpl) {
    getDesktopEventService ().addDesktopListener (dpl);
}


public void removeDesktopListener (DesktopListener dpl) {
    getDesktopEventService ().removeDesktopListener (dpl);
}


private Container getContainer () {
    return this;
}


protected DesktopEventService getDesktopEventService () {
    return myDesktopEventService;
}


private void setDesktopEventService (DesktopEventService newDesktopEventService) {
    myDesktopEventService = newDesktopEventService;
}


protected DesktopEventService createDesktopEventService () {
    return new DesktopEventService (this, getContainer ());
}


public void updateTitle (String newDrawingTitle) {
    setName (newDrawingTitle);
}


public CustomToolBar () {
    super ();
    standardTools = CollectionsFactory.current ().createList ();
    editTools = CollectionsFactory.current ().createList ();
    currentTools = standardTools;
    needsUpdate = false;
}


public void switchToolBar () {
    if (currentTools == standardTools) {
        switchToEditTools ();
    } else {
        switchToStandardTools ();
    }
}


public void switchToEditTools () {
    if (currentTools != editTools) {
        currentTools = editTools;
        needsUpdate = true;
    }
}


public void switchToStandardTools () {
    if (currentTools != standardTools) {
        currentTools = standardTools;
        needsUpdate = true;
    }
}


public void activateTools () {
    if (! needsUpdate) {
        return;
    } else {
        removeAll ();
        JComponent currentTool = null;
        Iterator iter = currentTools.iterator ();
        while (iter.hasNext ()) {
            currentTool = (JComponent) iter.next ();
            super.add (currentTool);
        }
        validate ();
        needsUpdate = false;
    }
}


public Component add (Component newTool) {
    if (currentTools == editTools) {
        editTools.add (newTool);
    } else {
        standardTools.add (newTool);
    }
    needsUpdate = true;
    return super.add (newTool);
}


protected String createFileExtension () {
    return "svg";
}


public String createFileDescription () {
    return "Scalable Vector Graphics (svg)";
}


public String store (String fileName, Drawing saveDrawing) throws IOException {
    DOMImplementation domImpl = GenericDOMImplementation.getDOMImplementation ();
    Document document = domImpl.createDocument (null, "svg", null);
    SVGGraphics2D svgGenerator = new SVGGraphics2D (document);
    saveDrawing.draw (svgGenerator);
    fileName = adjustFileName (fileName);
    FileOutputStream fos = new FileOutputStream (fileName);
    Writer out = new OutputStreamWriter (fos, "UTF-8");
    svgGenerator.stream (out, true);
    return fileName;
}


public Drawing restore (String fileName) throws IOException {
    throw new IOException ("Not implemented");
}


public ClippingUpdateStrategy () {
    super ();
}


public void draw (Graphics g, DrawingView view) {
    Rectangle viewClipRectangle = g.getClipBounds ();
    if (viewClipRectangle == null) {
        view.drawAll (g);
        return;
    }
    FigureEnumeration fe = view.drawing ().figures ();
    Vector v = new Vector (1000);
    while (fe.hasNextFigure ()) {
        Figure fig = fe.nextFigure ();
        Rectangle r = fig.displayBox ();
        if (r.width 

public CTXCommandMenu (String name) {
    super (name);
}


public synchronized void add (Command command) {
    addMenuItem (new CommandMenuItem (command));
}


public synchronized void add (Command command, MenuShortcut shortcut) {
    addMenuItem (new CommandMenuItem (command, shortcut.getKey ()));
}


public synchronized void addCheckItem (Command command) {
    addMenuItem (new CommandCheckBoxMenuItem (command));
}


public synchronized void add (CommandMenuItem item) {
    addMenuItem (item);
}


public synchronized void add (CommandCheckBoxMenuItem checkItem) {
    addMenuItem (checkItem);
}


protected void addMenuItem (JMenuItem m) {
    m.addActionListener (this);
    add (m);
    ((CommandHolder) m).getCommand ().addCommandListener (this);
}


public synchronized void remove (Command command) {
    throw new JHotDrawRuntimeException ("not implemented");
}


public synchronized void remove (MenuItem item) {
    throw new JHotDrawRuntimeException ("not implemented");
}


public synchronized void enable (String name, boolean state) {
    for (int i = 0;
    i 

public synchronized void checkEnabled () {
    int j = 0;
    for (int i = 0;
    i 

public void actionPerformed (ActionEvent e) {
    int j = 0;
    Object source = e.getSource ();
    for (int i = 0;
    i 

public void commandExecuted (EventObject commandEvent) {
}


public void commandExecutable (EventObject commandEvent) {
}


public void commandNotExecutable (EventObject commandEvent) {
}


public JScrollPaneDesktop () {
    setDesktopEventService (createDesktopEventService ());
    setAlignmentX (LEFT_ALIGNMENT);
    setVerticalScrollBarPolicy (JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
    setHorizontalScrollBarPolicy (JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
}


protected Component createContents (DrawingView dv) {
    return (Component) dv;
}


public DrawingView getActiveDrawingView () {
    return getDesktopEventService ().getActiveDrawingView ();
}


public void addToDesktop (DrawingView dv, int location) {
    getContainer ().add (createContents (dv));
}


public void removeFromDesktop (DrawingView dv, int location) {
    getDesktopEventService ().removeComponent (dv);
}


public void removeAllFromDesktop (int location) {
    getDesktopEventService ().removeAllComponents ();
}


public DrawingView [] getAllFromDesktop (int location) {
    return getDesktopEventService ().getDrawingViews (getComponents ());
}


public void addDesktopListener (DesktopListener dpl) {
    getDesktopEventService ().addDesktopListener (dpl);
}


public void removeDesktopListener (DesktopListener dpl) {
    getDesktopEventService ().removeDesktopListener (dpl);
}


private Container getContainer () {
    return getViewport ();
}


protected DesktopEventService getDesktopEventService () {
    return myDesktopEventService;
}


private void setDesktopEventService (DesktopEventService newDesktopEventService) {
    myDesktopEventService = newDesktopEventService;
}


protected DesktopEventService createDesktopEventService () {
    return new DesktopEventService (this, getContainer ());
}


public void updateTitle (String newDrawingTitle) {
    setName (newDrawingTitle);
}


public JPanelDesktop (DrawApplication newDrawApplication) {
    setDrawApplication (newDrawApplication);
    setDesktopEventService (createDesktopEventService ());
    setAlignmentX (LEFT_ALIGNMENT);
    setLayout (new BorderLayout ());
}


protected Component createContents (DrawingView dv) {
    JScrollPane sp = new JScrollPane ((Component) dv);
    sp.setVerticalScrollBarPolicy (JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
    sp.setHorizontalScrollBarPolicy (JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
    sp.setAlignmentX (LEFT_ALIGNMENT);
    String applicationTitle;
    if (dv.drawing ().getTitle () == null) {
        applicationTitle = getDrawApplication ().getApplicationName () + " - " + getDrawApplication ().getDefaultDrawingTitle ();
    } else {
        applicationTitle = getDrawApplication ().getApplicationName () + " - " + dv.drawing ().getTitle ();
    }
    sp.setName (applicationTitle);
    return sp;
}


public DrawingView getActiveDrawingView () {
    return getDesktopEventService ().getActiveDrawingView ();
}


public void addToDesktop (DrawingView dv, int location) {
    getDesktopEventService ().addComponent (createContents (dv));
    getContainer ().validate ();
}


public void removeFromDesktop (DrawingView dv, int location) {
    getDesktopEventService ().removeComponent (dv);
    getContainer ().validate ();
}


public void removeAllFromDesktop (int location) {
    getDesktopEventService ().removeAllComponents ();
    getContainer ().validate ();
}


public DrawingView [] getAllFromDesktop (int location) {
    return getDesktopEventService ().getDrawingViews (getComponents ());
}


public void addDesktopListener (DesktopListener dpl) {
    getDesktopEventService ().addDesktopListener (dpl);
}


public void removeDesktopListener (DesktopListener dpl) {
    getDesktopEventService ().removeDesktopListener (dpl);
}


private Container getContainer () {
    return this;
}


protected DesktopEventService getDesktopEventService () {
    return myDesktopEventService;
}


private void setDesktopEventService (DesktopEventService newDesktopEventService) {
    myDesktopEventService = newDesktopEventService;
}


protected DesktopEventService createDesktopEventService () {
    return new DesktopEventService (this, getContainer ());
}


private void setDrawApplication (DrawApplication newDrawApplication) {
    myDrawApplication = newDrawApplication;
}


protected DrawApplication getDrawApplication () {
    return myDrawApplication;
}


public void updateTitle (String newDrawingTitle) {
    setName (newDrawingTitle);
}


public DesktopEvent (Desktop source, DrawingView newDrawingView) {
    this (source, newDrawingView, null);
}


public DesktopEvent (Desktop source, DrawingView newDrawingView, DrawingView newPreviousDV) {
    super (source);
    setDrawingView (newDrawingView);
    setPreviousDrawingView (newPreviousDV);
}


private void setDrawingView (DrawingView newDrawingView) {
    myDrawingView = newDrawingView;
}


public DrawingView getDrawingView () {
    return myDrawingView;
}


private void setPreviousDrawingView (DrawingView newPreviousDrawingView) {
    myPreviousDrawingView = newPreviousDrawingView;
}


public DrawingView getPreviousDrawingView () {
    return myPreviousDrawingView;
}


public PolygonHandle (PolygonFigure owner, Locator l, int index) {
    super (owner);
    fLocator = l;
    fIndex = index;
}


public void invokeStart (int x, int y, DrawingView view) {
    setUndoActivity (createUndoActivity (view, fIndex));
    getUndoActivity ().setAffectedFigures (new SingleFigureEnumerator (owner ()));
    ((PolygonHandle.UndoActivity) getUndoActivity ()).setOldPoint (new Point (x, y));
}


public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
    int index = ((PolyLineHandle.UndoActivity) getUndoActivity ()).getPointIndex ();
    myOwner ().setPointAt (new Point (x, y), index);
}


public void invokeEnd (int x, int y, int anchorX, int anchorY, DrawingView view) {
    myOwner ().smoothPoints ();
    if ((x == anchorX) && (y == anchorY)) {
        setUndoActivity (null);
    }
}


public Point locate () {
    return fLocator.locate (owner ());
}


private PolygonFigure myOwner () {
    return (PolygonFigure) owner ();
}


protected Undoable createUndoActivity (DrawingView newView, int newPointIndex) {
    return new PolygonHandle.UndoActivity (newView, newPointIndex);
}


public UndoActivity (DrawingView newView, int newPointIndex) {
    super (newView, newPointIndex);
}


protected boolean movePointToOldLocation () {
    FigureEnumeration fe = getAffectedFigures ();
    if (! fe.hasNextFigure ()) {
        return false;
    }
    PolygonFigure figure = (PolygonFigure) fe.nextFigure ();
    Point backupPoint = figure.pointAt (getPointIndex ());
    figure.setPointAt (getOldPoint (), getPointIndex ());
    figure.smoothPoints ();
    setOldPoint (backupPoint);
    return true;
}


public URLTool (DrawingEditor newDrawingEditor) {
    super (newDrawingEditor);
}


public void mouseDown (MouseEvent e, int x, int y) {
    super.mouseDown (e, x, y);
    Figure pressedFigure = drawing ().findFigureInside (x, y);
    if (pressedFigure != null) {
        beginEdit (pressedFigure);
        return;
    }
    endEdit ();
    editor ().toolDone ();
}


public void mouseUp (MouseEvent e, int x, int y) {
}


public void deactivate (DrawingView view) {
    super.deactivate ();
    endEdit ();
}


private void beginEdit (Figure figure) {
    if (fTextField == null) {
        fTextField = new FloatingTextField ();
        fTextField.addActionListener (new ActionListener () {
            public void actionPerformed (ActionEvent event) {
                endEdit ();
            }}

        );
    }
    if ((figure != fURLTarget) && (fURLTarget != null)) {
        endEdit ();
    }
    if (figure != fURLTarget) {
        fTextField.createOverlay ((Container) view ());
        fTextField.setBounds (fieldBounds (figure), getURL (figure));
        fURLTarget = figure;
    }
}


public void actionPerformed (ActionEvent event) {
    endEdit ();
}


private void endEdit () {
    if (fURLTarget != null) {
        setURL (fURLTarget, fTextField.getText ());
        fURLTarget = null;
        fTextField.endOverlay ();
    }
}


private Rectangle fieldBounds (Figure figure) {
    Rectangle box = figure.displayBox ();
    int nChars = Math.max (20, getURL (figure).length ());
    Dimension d = fTextField.getPreferredSize (nChars);
    box.x = Math.max (0, box.x + (box.width - d.width) / 2);
    box.y = Math.max (0, box.y + (box.height - d.height) / 2);
    return new Rectangle (box.x, box.y, d.width, d.height);
}


private String getURL (Figure figure) {
    String url = (String) figure.getAttribute (FigureAttributeConstant.URL);
    if (url == null) {
        url = "";
    }
    return url;
}


private void setURL (Figure figure, String url) {
    figure.setAttribute (FigureAttributeConstant.URL, url);
}


public MySelectionTool (DrawingEditor newDrawingEditor) {
    super (newDrawingEditor);
}


public void mouseDown (MouseEvent e, int x, int y) {
    setView ((DrawingView) e.getSource ());
    if (e.getClickCount () == 2) {
        Figure figure = drawing ().findFigure (e.getX (), e.getY ());
        if (figure != null) {
            inspectFigure (figure);
            return;
        }
    }
    super.mouseDown (e, x, y);
}


protected void inspectFigure (Figure f) {
    System.out.println ("inspect figure" + f);
}


public synchronized Figure add (Figure figure) {
    if (! (figure instanceof AnimationDecorator) && ! (figure instanceof ConnectionFigure)) {
        figure = new AnimationDecorator (figure);
    }
    return super.add (figure);
}


public synchronized Figure remove (Figure figure) {
    Figure f = super.remove (figure);
    if (f instanceof AnimationDecorator) {
        return ((AnimationDecorator) f).peelDecoration ();
    }
    return f;
}


public synchronized Figure replace (Figure figure, Figure replacement) {
    if (! (replacement instanceof AnimationDecorator) && ! (replacement instanceof ConnectionFigure)) {
        replacement = new AnimationDecorator (replacement);
    }
    return super.replace (figure, replacement);
}


public void animationStep () {
    FigureEnumeration fe = figures ();
    while (fe.hasNextFigure ()) {
        Figure f = fe.nextFigure ();
        if (! (f instanceof ConnectionFigure)) {
            ((AnimationDecorator) f).animationStep ();
        }
    }
}


public PatternPainter (Image image) {
    fImage = image;
}


public void draw (Graphics g, DrawingView view) {
    drawPattern (g, fImage, view);
}


private void drawPattern (Graphics g, Image image, DrawingView view) {
    int iwidth = image.getWidth (view);
    int iheight = image.getHeight (view);
    Dimension d = view.getSize ();
    int x = 0;
    int y = 0;
    while (y 

JavaDrawApp () {
    super ("JHotDraw");
}


public JavaDrawApp (String title) {
    super (title);
}


protected DrawApplication createApplication () {
    return new JavaDrawApp ();
}


protected DrawingView createDrawingView () {
    return new ZoomDrawingView (this);
}


public void destroy () {
    super.destroy ();
    endAnimation ();
}


protected void createTools (JToolBar palette) {
    super.createTools (palette);
    Tool tool = new ZoomTool (this);
    palette.add (createToolButton (IMAGES + "ZOOM", "Zoom Tool", tool));
    tool = new UndoableTool (new TextTool (this, new TextFigure ()));
    palette.add (createToolButton (IMAGES + "TEXT", "Text Tool", tool));
    tool = new UndoableTool (new ConnectedTextTool (this, new TextFigure ()));
    palette.add (createToolButton (IMAGES + "ATEXT", "Connected Text Tool", tool));
    tool = new URLTool (this);
    palette.add (createToolButton (IMAGES + "URL", "URL Tool", tool));
    tool = new UndoableTool (new CreationTool (this, new RectangleFigure ()));
    palette.add (createToolButton (IMAGES + "RECT", "Rectangle Tool", tool));
    tool = new UndoableTool (new CreationTool (this, new RoundRectangleFigure ()));
    palette.add (createToolButton (IMAGES + "RRECT", "Round Rectangle Tool", tool));
    tool = new UndoableTool (new CreationTool (this, new EllipseFigure ()));
    palette.add (createToolButton (IMAGES + "ELLIPSE", "Ellipse Tool", tool));
    tool = new UndoableTool (new PolygonTool (this));
    palette.add (createToolButton (IMAGES + "POLYGON", "Polygon Tool", tool));
    tool = new UndoableTool (new CreationTool (this, new TriangleFigure ()));
    palette.add (createToolButton (IMAGES + "TRIANGLE", "Triangle Tool", tool));
    tool = new UndoableTool (new CreationTool (this, new DiamondFigure ()));
    palette.add (createToolButton (IMAGES + "DIAMOND", "Diamond Tool", tool));
    tool = new UndoableTool (new CreationTool (this, new LineFigure ()));
    palette.add (createToolButton (IMAGES + "LINE", "Line Tool", tool));
    tool = new UndoableTool (new ConnectionTool (this, new LineConnection ()));
    palette.add (createToolButton (IMAGES + "CONN", "Connection Tool", tool));
    tool = new UndoableTool (new ConnectionTool (this, new ElbowConnection ()));
    palette.add (createToolButton (IMAGES + "OCONN", "Elbow Connection Tool", tool));
    tool = new UndoableTool (new ScribbleTool (this));
    palette.add (createToolButton (IMAGES + "SCRIBBL", "Scribble Tool", tool));
    tool = new UndoableTool (new BorderTool (this));
    palette.add (createToolButton (IMAGES + "BORDDEC", "Border Tool", tool));
    Component button = new JButton ("Hello World");
    tool = new CreationTool (this, new ComponentFigure (button));
    palette.add (createToolButton (IMAGES + "RECT", "Component Tool", tool));
    tool = new TextAreaTool (this, new TextAreaFigure ());
    palette.add (createToolButton (IMAGES + "TEXTAREA", "TextArea Tool", tool));
    GraphicalCompositeFigure fig = new GraphicalCompositeFigure ();
    fig.setLayouter (new SimpleLayouter (fig));
    tool = new CreationTool (this, fig);
    palette.add (createToolButton (IMAGES + "RECT", "Container Figure Tool", tool));
    tool = new CompositeFigureCreationTool (this, new RectangleFigure ());
    palette.add (createToolButton (IMAGES + "RECT", "Nested Figure Tool", tool));
    tool = new HTMLTextAreaTool (this, new HTMLTextAreaFigure ());
    palette.add (createToolButton (IMAGES + "TEXTAREA", "HTML TextArea Tool", tool));
    LineConnection lineConnection = new LineConnection ();
    lineConnection.setStartDecoration (null);
    tool = new UndoableTool (new SplitConnectionTool (this, lineConnection));
    palette.add (createToolButton (IMAGES + "OCONN", "Split Connection Tool", tool));
}


protected Tool createSelectionTool () {
    return new MySelectionTool (this);
}


protected void createMenus (JMenuBar mb) {
    super.createMenus (mb);
    addMenuIfPossible (mb, createAnimationMenu ());
    addMenuIfPossible (mb, createImagesMenu ());
    addMenuIfPossible (mb, createWindowMenu ());
}


protected JMenu createAnimationMenu () {
    CommandMenu menu = new CommandMenu ("Animation");
    Command cmd = new AbstractCommand ("Start Animation", this) {
        public void execute () {
            startAnimation ();
        }}

    ;
    menu.add (cmd);
    cmd = new AbstractCommand ("Stop Animation", this) {
        public void execute () {
            endAnimation ();
        }}

    ;
    menu.add (cmd);
    return menu;
}


public void execute () {
    startAnimation ();
}


public void execute () {
    endAnimation ();
}


protected JMenu createWindowMenu () {
    CommandMenu menu = new CommandMenu ("Window");
    Command cmd = new AbstractCommand ("New View", this) {
        public void execute () {
            newView ();
        }}

    ;
    menu.add (cmd);
    cmd = new AbstractCommand ("New Window", this, false) {
        public void execute () {
            newWindow (createDrawing ());
        }}

    ;
    menu.add (cmd);
    menu.addSeparator ();
    menu.add (new WindowMenu ("Window List", (MDIDesktopPane) getDesktop (), this));
    return menu;
}


public void execute () {
    newView ();
}


public void execute () {
    newWindow (createDrawing ());
}


protected JMenu createImagesMenu () {
    CommandMenu menu = new CommandMenu ("Images");
    URL url = getClass ().getResource (fgSampleImagesPath);
    File imagesDirectory = new File (url.getFile ());
    try {
        String [] list = imagesDirectory.list ();
        for (int i = 0;
        i 

protected Drawing createDrawing () {
    Drawing dwg = new BouncingDrawing ();
    dwg.setTitle (getDefaultDrawingTitle ());
    return dwg;
}


public void startAnimation () {
    if (view ().drawing () instanceof Animatable && fAnimator == null) {
        fAnimator = new Animator ((Animatable) view ().drawing (), view ());
        fAnimator.start ();
    }
}


public void endAnimation () {
    if (fAnimator != null) {
        fAnimator.end ();
        fAnimator = null;
    }
}


protected JMenu createDebugMenu () {
    CommandMenu menu = (CommandMenu) super.createDebugMenu ();
    Command cmd = new AbstractCommand ("Clipping Update", this) {
        public void execute () {
            this.view ().setDisplayUpdate (new ClippingUpdateStrategy ());
        }}

    ;
    menu.add (cmd);
    return menu;
}


public void execute () {
    this.view ().setDisplayUpdate (new ClippingUpdateStrategy ());
}


public static void main (String [] args) {
    JavaDrawApp window = new JavaDrawApp ();
    window.open ();
}


public Animator (Animatable animatable, DrawingView view) {
    super ("Animator");
    fView = view;
    fAnimatable = animatable;
}


public void start () {
    super.start ();
    fIsRunning = true;
}


public void end () {
    fIsRunning = false;
}


public void run () {
    while (fIsRunning) {
        long tm = System.currentTimeMillis ();
        fView.freezeView ();
        fAnimatable.animationStep ();
        fView.checkDamage ();
        fView.unfreezeView ();
        try {
            tm += DELAY;
            Thread.sleep (Math.max (0, tm - System.currentTimeMillis ()));
        } catch (InterruptedException e) {
            break;
        }
    }
}


public AnimationDecorator () {
}


public AnimationDecorator (Figure figure) {
    super (figure);
    fXVelocity = 4;
    fYVelocity = 4;
}


public void velocity (int xVelocity, int yVelocity) {
    fXVelocity = xVelocity;
    fYVelocity = yVelocity;
}


public Point velocity () {
    return new Point (fXVelocity, fYVelocity);
}


public void animationStep () {
    int xSpeed = fXVelocity;
    int ySpeed = fYVelocity;
    Rectangle box = displayBox ();
    if ((box.x + box.width > 300) && (xSpeed > 0)) xSpeed = - xSpeed;

    if ((box.y + box.height > 300) && (ySpeed > 0)) ySpeed = - ySpeed;

    if ((box.x 

public synchronized void basicMoveBy (int x, int y) {
    super.basicMoveBy (x, y);
}


public synchronized void basicDisplayBox (Point origin, Point corner) {
    super.basicDisplayBox (origin, corner);
}


public synchronized Rectangle displayBox () {
    return super.displayBox ();
}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeInt (fXVelocity);
    dw.writeInt (fYVelocity);
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    fXVelocity = dr.readInt ();
    fYVelocity = dr.readInt ();
}


public void destroy () {
    super.destroy ();
    endAnimation ();
}


protected void createTools (JPanel palette) {
    super.createTools (palette);
    Tool tool = new TextTool (this, new TextFigure ());
    palette.add (createToolButton (IMAGES + "TEXT", "Text Tool", tool));
    tool = new ConnectedTextTool (this, new TextFigure ());
    palette.add (createToolButton (IMAGES + "ATEXT", "Connected Text Tool", tool));
    tool = new URLTool (this);
    palette.add (createToolButton (IMAGES + "URL", "URL Tool", tool));
    tool = new CreationTool (this, new RectangleFigure ());
    palette.add (createToolButton (IMAGES + "RECT", "Rectangle Tool", tool));
    tool = new CreationTool (this, new RoundRectangleFigure ());
    palette.add (createToolButton (IMAGES + "RRECT", "Round Rectangle Tool", tool));
    tool = new CreationTool (this, new EllipseFigure ());
    palette.add (createToolButton (IMAGES + "ELLIPSE", "Ellipse Tool", tool));
    tool = new PolygonTool (this);
    palette.add (createToolButton (IMAGES + "POLYGON", "Polygon Tool", tool));
    tool = new CreationTool (this, new TriangleFigure ());
    palette.add (createToolButton (IMAGES + "TRIANGLE", "Triangle Tool", tool));
    tool = new CreationTool (this, new DiamondFigure ());
    palette.add (createToolButton (IMAGES + "DIAMOND", "Diamond Tool", tool));
    tool = new CreationTool (this, new LineFigure ());
    palette.add (createToolButton (IMAGES + "LINE", "Line Tool", tool));
    tool = new ConnectionTool (this, new LineConnection ());
    palette.add (createToolButton (IMAGES + "CONN", "Connection Tool", tool));
    tool = new ConnectionTool (this, new ElbowConnection ());
    palette.add (createToolButton (IMAGES + "OCONN", "Elbow Connection Tool", tool));
    tool = new ScribbleTool (this);
    palette.add (createToolButton (IMAGES + "SCRIBBL", "Scribble Tool", tool));
    tool = new PolygonTool (this);
    palette.add (createToolButton (IMAGES + "POLYGON", "Polygon Tool", tool));
    tool = new BorderTool (this);
    palette.add (createToolButton (IMAGES + "BORDDEC", "Border Tool", tool));
}


protected void createButtons (JPanel panel) {
    super.createButtons (panel);
    fAnimationButton = new JButton ("Start Animation");
    fAnimationButton.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent event) {
            toggleAnimation ();
        }}

    );
    panel.add (fAnimationButton);
}


public void actionPerformed (ActionEvent event) {
    toggleAnimation ();
}


protected Drawing createDrawing () {
    return new BouncingDrawing ();
}


public void startAnimation () {
    if ((drawing () instanceof Animatable) && (fAnimator == null)) {
        fAnimator = new Animator ((Animatable) drawing (), view ());
        fAnimator.start ();
        fAnimationButton.setText ("End Animation");
    }
}


public void endAnimation () {
    if (fAnimator != null) {
        fAnimator.end ();
        fAnimator = null;
        fAnimationButton.setText ("Start Animation");
    }
}


public void toggleAnimation () {
    if (fAnimator != null) endAnimation ();
    else startAnimation ();

}


public void init () {
    setUndoManager (new UndoManager ());
    getContentPane ().setLayout (new BorderLayout ());
    fView = new StandardDrawingView (this, 400, 370);
    getContentPane ().add ("Center", fView);
    setTool (new FollowURLTool (this, this));
    String filename = getParameter ("Drawing");
    if (filename != null) {
        loadDrawing (filename);
        fView.setDrawing (fDrawing);
    } else {
        showStatus ("Unable to load drawing");
    }
}


public void addViewChangeListener (ViewChangeListener vsl) {
}


public void removeViewChangeListener (ViewChangeListener vsl) {
}


private void loadDrawing (String filename) {
    try {
        URL url = new URL (getCodeBase (), filename);
        InputStream stream = url.openStream ();
        StorableInput reader = new StorableInput (stream);
        fDrawing = (Drawing) reader.readStorable ();
    } catch (IOException e) {
        fDrawing = createDrawing ();
        System.err.println ("Error when Loading: " + e);
        showStatus ("Error when Loading: " + e);
    }
}


protected Drawing createDrawing () {
    return new StandardDrawing ();
}


public DrawingView view () {
    return fView;
}


public DrawingView [] views () {
    return new DrawingView [] {view ()};
}


public Drawing drawing () {
    return fDrawing;
}


public Tool tool () {
    return fTool;
}


public void setTool (Tool newTool) {
    fTool = newTool;
}


public void toolDone () {
}


public void figureSelectionChanged (DrawingView view) {
}


protected void setUndoManager (UndoManager newUndoManager) {
    myUndoManager = newUndoManager;
}


public UndoManager getUndoManager () {
    return myUndoManager;
}


FollowURLTool (DrawingEditor newDrawingEditor, JApplet applet) {
    super (newDrawingEditor);
    fApplet = applet;
}


public void mouseMove (MouseEvent e, int x, int y) {
    String urlstring = null;
    Figure figure = drawing ().findFigureInside (x, y);
    if (figure != null) {
        urlstring = (String) figure.getAttribute (FigureAttributeConstant.URL);
    }
    if (urlstring != null) {
        fApplet.showStatus (urlstring);
    } else {
        fApplet.showStatus ("");
    }
}


public void mouseUp (MouseEvent e, int x, int y) {
    Figure figure = getActiveDrawing ().findFigureInside (x, y);
    if (figure == null) {
        return;
    }
    String urlstring = (String) figure.getAttribute (FigureAttributeConstant.URL);
    if (urlstring == null) {
        return;
    }
    try {
        URL url = new URL (fApplet.getDocumentBase (), urlstring);
        fApplet.getAppletContext ().showDocument (url);
    } catch (MalformedURLException exception) {
        fApplet.showStatus (exception.toString ());
    }
}


public PertApplication () {
    super ("PERT Editor");
}


protected void createTools (JToolBar palette) {
    super.createTools (palette);
    Tool tool = new TextTool (this, new TextFigure ());
    palette.add (createToolButton (IMAGES + "TEXT", "Text Tool", tool));
    tool = new PertFigureCreationTool (this);
    palette.add (createToolButton (PERTIMAGES + "PERT", "Task Tool", tool));
    tool = new ConnectionTool (this, new PertDependency ());
    palette.add (createToolButton (IMAGES + "CONN", "Dependency Tool", tool));
    tool = new CreationTool (this, new LineFigure ());
    palette.add (createToolButton (IMAGES + "Line", "Line Tool", tool));
}


public static void main (String [] args) {
    PertApplication pert = new PertApplication ();
    pert.open ();
}


protected void createTools (JPanel palette) {
    super.createTools (palette);
    Tool tool = new TextTool (this, new TextFigure ());
    palette.add (createToolButton (IMAGES + "TEXT", "Text Tool", tool));
    tool = new PertFigureCreationTool (this);
    palette.add (createToolButton (PERTIMAGES + "PERT", "Task Tool", tool));
    tool = new ConnectionTool (this, new PertDependency ());
    palette.add (createToolButton (IMAGES + "CONN", "Dependency Tool", tool));
    tool = new CreationTool (this, new LineFigure ());
    palette.add (createToolButton (IMAGES + "LINE", "Line Tool", tool));
}


public PertFigure () {
    initialize ();
}


public int start () {
    int start = 0;
    Iterator iter = fPreTasks.iterator ();
    while (iter.hasNext ()) {
        PertFigure f = (PertFigure) iter.next ();
        start = Math.max (start, f.end ());
    }
    return start;
}


public int end () {
    return asInt (2);
}


public int duration () {
    return asInt (1);
}


public void setEnd (int value) {
    setInt (2, value);
}


public void addPreTask (PertFigure figure) {
    if (! fPreTasks.contains (figure)) {
        fPreTasks.add (figure);
    }
}


public void addPostTask (PertFigure figure) {
    if (! fPostTasks.contains (figure)) {
        fPostTasks.add (figure);
    }
}


public void removePreTask (PertFigure figure) {
    fPreTasks.remove (figure);
}


public void removePostTask (PertFigure figure) {
    fPostTasks.remove (figure);
}


private int asInt (int figureIndex) {
    NumberTextFigure t = (NumberTextFigure) figureAt (figureIndex);
    return t.getValue ();
}


private String taskName () {
    TextFigure t = (TextFigure) figureAt (0);
    return t.getText ();
}


private void setInt (int figureIndex, int value) {
    NumberTextFigure t = (NumberTextFigure) figureAt (figureIndex);
    t.setValue (value);
}


protected void basicMoveBy (int x, int y) {
    fDisplayBox.translate (x, y);
    super.basicMoveBy (x, y);
}


public Rectangle displayBox () {
    return new Rectangle (fDisplayBox.x, fDisplayBox.y, fDisplayBox.width, fDisplayBox.height);
}


public void basicDisplayBox (Point origin, Point corner) {
    fDisplayBox = new Rectangle (origin);
    fDisplayBox.add (corner);
    layout ();
}


private void drawBorder (Graphics g) {
    super.draw (g);
    Rectangle r = displayBox ();
    Figure f = figureAt (0);
    Rectangle rf = f.displayBox ();
    g.setColor (Color.gray);
    g.drawLine (r.x, r.y + rf.height + 2, r.x + r.width, r.y + rf.height + 2);
    g.setColor (Color.white);
    g.drawLine (r.x, r.y + rf.height + 3, r.x + r.width, r.y + rf.height + 3);
    g.setColor (Color.white);
    g.drawLine (r.x, r.y, r.x, r.y + r.height);
    g.drawLine (r.x, r.y, r.x + r.width, r.y);
    g.setColor (Color.gray);
    g.drawLine (r.x + r.width, r.y, r.x + r.width, r.y + r.height);
    g.drawLine (r.x, r.y + r.height, r.x + r.width, r.y + r.height);
}


public void draw (Graphics g) {
    drawBorder (g);
    super.draw (g);
}


public HandleEnumeration handles () {
    List handles = CollectionsFactory.current ().createList ();
    handles.add (new NullHandle (this, RelativeLocator.northWest ()));
    handles.add (new NullHandle (this, RelativeLocator.northEast ()));
    handles.add (new NullHandle (this, RelativeLocator.southWest ()));
    handles.add (new NullHandle (this, RelativeLocator.southEast ()));
    handles.add (new ConnectionHandle (this, RelativeLocator.east (), new PertDependency ()));
    return new HandleEnumerator (handles);
}


private void initialize () {
    fPostTasks = CollectionsFactory.current ().createList ();
    fPreTasks = CollectionsFactory.current ().createList ();
    fDisplayBox = new Rectangle (0, 0, 0, 0);
    Font f = new Font ("Helvetica", Font.PLAIN, 12);
    Font fb = new Font ("Helvetica", Font.BOLD, 12);
    TextFigure name = new TextFigure ();
    name.setFont (fb);
    name.setText ("Task");
    add (name);
    NumberTextFigure duration = new NumberTextFigure ();
    duration.setValue (0);
    duration.setFont (fb);
    add (duration);
    NumberTextFigure end = new NumberTextFigure ();
    end.setValue (0);
    end.setFont (f);
    end.setReadOnly (true);
    add (end);
}


private void layout () {
    Point partOrigin = new Point (fDisplayBox.x, fDisplayBox.y);
    partOrigin.translate (BORDER, BORDER);
    Dimension extent = new Dimension (0, 0);
    FigureEnumeration fe = figures ();
    while (fe.hasNextFigure ()) {
        Figure f = fe.nextFigure ();
        Dimension partExtent = f.size ();
        Point corner = new Point (partOrigin.x + partExtent.width, partOrigin.y + partExtent.height);
        f.basicDisplayBox (partOrigin, corner);
        extent.width = Math.max (extent.width, partExtent.width);
        extent.height += partExtent.height;
        partOrigin.y += partExtent.height;
    }
    fDisplayBox.width = extent.width + 2 * BORDER;
    fDisplayBox.height = extent.height + 2 * BORDER;
}


private boolean needsLayout () {
    Dimension extent = new Dimension (0, 0);
    FigureEnumeration fe = figures ();
    while (fe.hasNextFigure ()) {
        Figure f = fe.nextFigure ();
        extent.width = Math.max (extent.width, f.size ().width);
    }
    int newExtent = extent.width + 2 * BORDER;
    return newExtent != fDisplayBox.width;
}


public void update (FigureChangeEvent e) {
    if (e.getFigure () == figureAt (1)) {
        updateDurations ();
    }
    if (needsLayout ()) {
        layout ();
        changed ();
    }
}


public void figureChanged (FigureChangeEvent e) {
    update (e);
}


public void figureRemoved (FigureChangeEvent e) {
    update (e);
}


public void notifyPostTasks () {
    Iterator iter = fPostTasks.iterator ();
    while (iter.hasNext ()) {
        ((PertFigure) iter.next ()).updateDurations ();
    }
}


public void updateDurations () {
    int newEnd = start () + duration ();
    if (newEnd != end ()) {
        setEnd (newEnd);
        notifyPostTasks ();
    }
}


public boolean hasCycle (Figure start) {
    if (start == this) {
        return true;
    }
    Iterator iter = fPreTasks.iterator ();
    while (iter.hasNext ()) {
        if (((PertFigure) iter.next ()).hasCycle (start)) {
            return true;
        }
    }
    return false;
}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeInt (fDisplayBox.x);
    dw.writeInt (fDisplayBox.y);
    dw.writeInt (fDisplayBox.width);
    dw.writeInt (fDisplayBox.height);
    writeTasks (dw, fPreTasks);
    writeTasks (dw, fPostTasks);
}


public void writeTasks (StorableOutput dw, List l) {
    dw.writeInt (l.size ());
    Iterator iter = l.iterator ();
    while (iter.hasNext ()) {
        dw.writeStorable ((Storable) iter.next ());
    }
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    fDisplayBox = new Rectangle (dr.readInt (), dr.readInt (), dr.readInt (), dr.readInt ());
    layout ();
    fPreTasks = readTasks (dr);
    fPostTasks = readTasks (dr);
}


public Insets connectionInsets () {
    Rectangle r = fDisplayBox;
    int cx = r.width / 2;
    int cy = r.height / 2;
    return new Insets (cy, cx, cy, cx);
}


public List readTasks (StorableInput dr) throws IOException {
    int size = dr.readInt ();
    List l = CollectionsFactory.current ().createList (size);
    for (int i = 0;
    i 

public PertDependency () {
    setEndDecoration (new ArrowTip ());
    setStartDecoration (null);
}


public void handleConnect (Figure start, Figure end) {
    PertFigure source = (PertFigure) start;
    PertFigure target = (PertFigure) end;
    if (source.hasCycle (target)) {
        setAttribute (FigureAttributeConstant.FRAME_COLOR.getName (), Color.red);
    } else {
        target.addPreTask (source);
        source.addPostTask (target);
        source.notifyPostTasks ();
    }
}


public void handleDisconnect (Figure start, Figure end) {
    PertFigure source = (PertFigure) start;
    PertFigure target = (PertFigure) end;
    if (target != null) {
        target.removePreTask (source);
        target.updateDurations ();
    }
    if (source != null) {
        source.removePostTask (target);
    }
}


public boolean canConnect (Figure start, Figure end) {
    return ((start instanceof PertFigure) && (end instanceof PertFigure));
}


public HandleEnumeration handles () {
    List handles = super.handles ().toList ();
    handles.set (0, new NullHandle (this, PolyLineFigure.locator (0)));
    return new HandleEnumerator (handles);
}


public PertFigureCreationTool (DrawingEditor newDrawingEditor) {
    super (newDrawingEditor);
}


protected Figure createFigure () {
    return new PertFigure ();
}


protected Desktop createDesktop () {
    return new MiniMapDesktop ();
}


public static void main (String [] args) {
    MiniMapApplication window = new MiniMapApplication ();
    window.open ();
}


protected Component createRightComponent (DrawingView view) {
    Image image = Iconkit.instance ().registerAndLoadImage ((Component) view, imageName);
    view.add (new ImageFigure (image, imageName, new Point (0, 0)));
    view.checkDamage ();
    return super.createRightComponent (view);
}


protected Component createLeftComponent (DrawingView view) {
    JPanel blankPanel = new JPanel ();
    MiniMapView mmv = new MiniMapView (view, (JScrollPane) getRightComponent ());
    JSplitPane leftSplitPane = new JSplitPane (JSplitPane.VERTICAL_SPLIT, blankPanel, mmv);
    leftSplitPane.setOneTouchExpandable (true);
    leftSplitPane.setDividerLocation (200);
    return leftSplitPane;
}


public NodeFigure () {
    initialize ();
    fConnectors = null;
}


public Rectangle displayBox () {
    Rectangle box = super.displayBox ();
    int d = BORDER;
    box.grow (d, d);
    return box;
}


public boolean containsPoint (int x, int y) {
    if (fConnectorsVisible) {
        Rectangle r = displayBox ();
        int d = LocatorConnector.SIZE / 2;
        r.grow (d, d);
        return r.contains (x, y);
    }
    return super.containsPoint (x, y);
}


private void drawBorder (Graphics g) {
    Rectangle r = displayBox ();
    g.setColor (getFrameColor ());
    g.drawRect (r.x, r.y, r.width - 1, r.height - 1);
}


public void draw (Graphics g) {
    super.draw (g);
    drawBorder (g);
    drawConnectors (g);
}


public HandleEnumeration handles () {
    ConnectionFigure prototype = new LineConnection ();
    List handles = CollectionsFactory.current ().createList ();
    handles.add (new ConnectionHandle (this, RelativeLocator.east (), prototype));
    handles.add (new ConnectionHandle (this, RelativeLocator.west (), prototype));
    handles.add (new ConnectionHandle (this, RelativeLocator.south (), prototype));
    handles.add (new ConnectionHandle (this, RelativeLocator.north (), prototype));
    handles.add (new NullHandle (this, RelativeLocator.southEast ()));
    handles.add (new NullHandle (this, RelativeLocator.southWest ()));
    handles.add (new NullHandle (this, RelativeLocator.northEast ()));
    handles.add (new NullHandle (this, RelativeLocator.northWest ()));
    return new HandleEnumerator (handles);
}


private void drawConnectors (Graphics g) {
    if (fConnectorsVisible) {
        Iterator iter = connectors ();
        while (iter.hasNext ()) {
            ((Connector) iter.next ()).draw (g);
        }
    }
}


public void connectorVisibility (boolean isVisible, ConnectionFigure courtingConnection) {
    fConnectorsVisible = isVisible;
    invalidate ();
}


public Connector connectorAt (int x, int y) {
    return findConnector (x, y);
}


private Iterator connectors () {
    if (fConnectors == null) {
        createConnectors ();
    }
    return fConnectors.iterator ();
}


private void createConnectors () {
    fConnectors = CollectionsFactory.current ().createList (4);
    fConnectors.add (new LocatorConnector (this, RelativeLocator.north ()));
    fConnectors.add (new LocatorConnector (this, RelativeLocator.south ()));
    fConnectors.add (new LocatorConnector (this, RelativeLocator.west ()));
    fConnectors.add (new LocatorConnector (this, RelativeLocator.east ()));
}


private Connector findConnector (int x, int y) {
    long min = Long.MAX_VALUE;
    Connector closest = null;
    Iterator iter = connectors ();
    while (iter.hasNext ()) {
        Connector c = (Connector) iter.next ();
        Point p2 = Geom.center (c.displayBox ());
        long d = Geom.length2 (x, y, p2.x, p2.y);
        if (d 

private void initialize () {
    setText ("node");
    Font fb = new Font ("Helvetica", Font.BOLD, 12);
    setFont (fb);
    createConnectors ();
}


public Figure getRepresentingFigure () {
    return this;
}


public NetApp () {
    super ("Net");
}


protected void createTools (JToolBar palette) {
    super.createTools (palette);
    Tool tool = new TextTool (this, new NodeFigure ());
    palette.add (createToolButton (IMAGES + "TEXT", "Text Tool", tool));
    tool = new CreationTool (this, new NodeFigure ());
    palette.add (createToolButton (IMAGES + "RECT", "Create Org Unit", tool));
    tool = new ConnectionTool (this, new LineConnection ());
    palette.add (createToolButton (IMAGES + "CONN", "Connection Tool", tool));
}


public static void main (String [] args) {
    DrawApplication window = new NetApp ();
    window.open ();
}


protected void createTools (JPanel palette) {
    super.createTools (palette);
    Tool tool = new TextTool (this, new TextFigure ());
    palette.add (createToolButton (IMAGES + "TEXT", "Text Tool", tool));
    tool = new CreationTool (this, new RectangleFigure ());
    palette.add (createToolButton (IMAGES + "RECT", "Rectangle Tool", tool));
    tool = new CreationTool (this, new RoundRectangleFigure ());
    palette.add (createToolButton (IMAGES + "RRECT", "Round Rectangle Tool", tool));
    tool = new CreationTool (this, new EllipseFigure ());
    palette.add (createToolButton (IMAGES + "ELLIPSE", "Ellipse Tool", tool));
    tool = new CreationTool (this, new LineFigure ());
    palette.add (createToolButton (IMAGES + "LINE", "Line Tool", tool));
    tool = new PolygonTool (this);
    palette.add (createToolButton (IMAGES + "POLYGON", "Polygon Tool", tool));
    tool = new ConnectionTool (this, new LineConnection ());
    palette.add (createToolButton (IMAGES + "CONN", "Connection Tool", tool));
    tool = new ConnectionTool (this, new ElbowConnection ());
    palette.add (createToolButton (IMAGES + "OCONN", "Elbow Connection Tool", tool));
}


public NothingApp () {
    super ("Nothing");
}


protected void createTools (JToolBar palette) {
    super.createTools (palette);
    Tool tool = new TextTool (this, new TextFigure ());
    palette.add (createToolButton (IMAGES + "TEXT", "Text Tool", tool));
    tool = new CreationTool (this, new RectangleFigure ());
    palette.add (createToolButton (IMAGES + "RECT", "Rectangle Tool", tool));
    tool = new CreationTool (this, new RoundRectangleFigure ());
    palette.add (createToolButton (IMAGES + "RRECT", "Round Rectangle Tool", tool));
    tool = new CreationTool (this, new EllipseFigure ());
    palette.add (createToolButton (IMAGES + "ELLIPSE", "Ellipse Tool", tool));
    tool = new CreationTool (this, new LineFigure ());
    palette.add (createToolButton (IMAGES + "LINE", "Line Tool", tool));
    tool = new PolygonTool (this);
    palette.add (createToolButton (IMAGES + "POLYGON", "Polygon Tool", tool));
    tool = new ConnectionTool (this, new LineConnection ());
    palette.add (createToolButton (IMAGES + "CONN", "Connection Tool", tool));
    tool = new ConnectionTool (this, new ElbowConnection ());
    palette.add (createToolButton (IMAGES + "OCONN", "Elbow Connection Tool", tool));
}


public static void main (String [] args) {
    DrawApplication window = new NothingApp ();
    window.open ();
}


public LineFigure () {
    addPoint (0, 0);
    addPoint (0, 0);
}


public Point startPoint () {
    return pointAt (0);
}


public Point endPoint () {
    return pointAt (1);
}


public void startPoint (int x, int y) {
    setPointAt (new Point (x, y), 0);
}


public void endPoint (int x, int y) {
    setPointAt (new Point (x, y), 1);
}


public void setPoints (Point start, Point end) {
    setPointAt (start, 0);
    setPointAt (end, 1);
}


public void basicDisplayBox (Point origin, Point corner) {
    setPoints (origin, corner);
}


public boolean canConnect () {
    return false;
}


public Rectangle displayBox () {
    FigureEnumeration fe = figures ();
    Rectangle r = fe.nextFigure ().displayBox ();
    while (fe.hasNextFigure ()) {
        r.add (fe.nextFigure ().displayBox ());
    }
    return r;
}


public void basicDisplayBox (Point origin, Point corner) {
}


public FigureEnumeration decompose () {
    return new FigureEnumerator (fFigures);
}


public HandleEnumeration handles () {
    List handles = CollectionsFactory.current ().createList ();
    handles.add (new GroupHandle (this, RelativeLocator.northWest ()));
    handles.add (new GroupHandle (this, RelativeLocator.northEast ()));
    handles.add (new GroupHandle (this, RelativeLocator.southWest ()));
    handles.add (new GroupHandle (this, RelativeLocator.southEast ()));
    return new HandleEnumerator (handles);
}


public void setAttribute (String name, Object value) {
    super.setAttribute (name, value);
    FigureEnumeration fe = figures ();
    while (fe.hasNextFigure ()) {
        fe.nextFigure ().setAttribute (name, value);
    }
}


public TextTool (DrawingEditor newDrawingEditor, Figure prototype) {
    super (newDrawingEditor, prototype);
}


public void mouseDown (MouseEvent e, int x, int y) {
    setView ((DrawingView) e.getSource ());
    if (getTypingTarget () != null) {
        editor ().toolDone ();
        return;
    }
    TextHolder textHolder = null;
    Figure pressedFigure = drawing ().findFigureInside (x, y);
    if (pressedFigure != null) {
        textHolder = pressedFigure.getTextHolder ();
        setSelectedFigure (pressedFigure);
    }
    if ((textHolder != null) && textHolder.acceptsTyping ()) {
        beginEdit (textHolder);
    } else {
        super.mouseDown (e, x, y);
        view ().checkDamage ();
        beginEdit (getCreatedFigure ().getTextHolder ());
    }
}


public void mouseDrag (MouseEvent e, int x, int y) {
}


public void mouseUp (MouseEvent e, int x, int y) {
    if (! isActive ()) {
        editor ().toolDone ();
    }
}


public void deactivate () {
    endEdit ();
    super.deactivate ();
}


public void activate () {
    super.activate ();
}


public boolean isActive () {
    return (getTypingTarget () != null);
}


protected void beginEdit (TextHolder figure) {
    if (getFloatingTextField () == null) {
        setFloatingTextField (createFloatingTextField ());
    }
    if (figure != getTypingTarget () && getTypingTarget () != null) {
        endEdit ();
    }
    getFloatingTextField ().createOverlay ((Container) view (), figure.getFont ());
    getFloatingTextField ().setBounds (fieldBounds (figure), figure.getText ());
    setTypingTarget (figure);
}


protected void endEdit () {
    if (getTypingTarget () != null) {
        if (getAddedFigure () != null) {
            if (! isDeleteTextFigure ()) {
                setUndoActivity (createPasteUndoActivity ());
                getUndoActivity ().setAffectedFigures (new SingleFigureEnumerator (getAddedFigure ()));
                getTypingTarget ().setText (getFloatingTextField ().getText ());
            }
        } else if (isDeleteTextFigure ()) {
            setUndoActivity (createDeleteUndoActivity ());
            getUndoActivity ().setAffectedFigures (new SingleFigureEnumerator (getSelectedFigure ()));
            getUndoActivity ().redo ();
        } else {
            setUndoActivity (createUndoActivity ());
            getUndoActivity ().setAffectedFigures (new SingleFigureEnumerator (getTypingTarget ().getRepresentingFigure ()));
            getTypingTarget ().setText (getFloatingTextField ().getText ());
            ((TextTool.UndoActivity) getUndoActivity ()).setBackupText (getTypingTarget ().getText ());
        }

        setTypingTarget (null);
        getFloatingTextField ().endOverlay ();
    } else {
        setUndoActivity (null);
    }
    setAddedFigure (null);
    setCreatedFigure (null);
    setSelectedFigure (null);
}


protected boolean isDeleteTextFigure () {
    return getFloatingTextField ().getText ().length () == 0;
}


private Rectangle fieldBounds (TextHolder figure) {
    Rectangle box = figure.textDisplayBox ();
    int nChars = figure.overlayColumns ();
    Dimension d = getFloatingTextField ().getPreferredSize (nChars);
    return new Rectangle (box.x, box.y, d.width, d.height);
}


protected void setTypingTarget (TextHolder newTypingTarget) {
    myTypingTarget = newTypingTarget;
}


protected TextHolder getTypingTarget () {
    return myTypingTarget;
}


private void setSelectedFigure (Figure newSelectedFigure) {
    mySelectedFigure = newSelectedFigure;
}


protected Figure getSelectedFigure () {
    return mySelectedFigure;
}


private FloatingTextField createFloatingTextField () {
    return new FloatingTextField ();
}


private void setFloatingTextField (FloatingTextField newFloatingTextField) {
    myTextField = newFloatingTextField;
}


protected FloatingTextField getFloatingTextField () {
    return myTextField;
}


protected Undoable createDeleteUndoActivity () {
    FigureTransferCommand cmd = new DeleteCommand ("Delete", editor ());
    return new DeleteCommand.UndoActivity (cmd);
}


protected Undoable createPasteUndoActivity () {
    return new PasteCommand.UndoActivity (view ());
}


protected Undoable createUndoActivity () {
    return new TextTool.UndoActivity (view (), getTypingTarget ().getText ());
}


public UndoActivity (DrawingView newDrawingView, String newOriginalText) {
    super (newDrawingView);
    setOriginalText (newOriginalText);
    setUndoable (true);
    setRedoable (true);
}


public boolean undo () {
    if (! super.undo ()) {
        return false;
    }
    getDrawingView ().clearSelection ();
    setText (getOriginalText ());
    return true;
}


public boolean redo () {
    if (! super.redo ()) {
        return false;
    }
    getDrawingView ().clearSelection ();
    setText (getBackupText ());
    return true;
}


protected boolean isValidText (String toBeChecked) {
    return ((toBeChecked != null) && (toBeChecked.length () > 0));
}


protected void setText (String newText) {
    FigureEnumeration fe = getAffectedFigures ();
    while (fe.hasNextFigure ()) {
        Figure currentFigure = fe.nextFigure ();
        if (currentFigure.getTextHolder () != null) {
            currentFigure.getTextHolder ().setText (newText);
        }
    }
}


public void setBackupText (String newBackupText) {
    myBackupText = newBackupText;
}


public String getBackupText () {
    return myBackupText;
}


public void setOriginalText (String newOriginalText) {
    myOriginalText = newOriginalText;
}


public String getOriginalText () {
    return myOriginalText;
}


public UngroupCommand (String name, DrawingEditor newDrawingEditor) {
    super (name, newDrawingEditor);
}


public void execute () {
    super.execute ();
    setUndoActivity (createUndoActivity ());
    getUndoActivity ().setAffectedFigures (view ().selection ());
    view ().clearSelection ();
    ((UngroupCommand.UndoActivity) getUndoActivity ()).ungroupFigures ();
    view ().checkDamage ();
}


public boolean isExecutableWithView () {
    FigureEnumeration fe = view ().selection ();
    while (fe.hasNextFigure ()) {
        Figure currentFigure = fe.nextFigure ();
        currentFigure = currentFigure.getDecoratedFigure ();
        if (! (currentFigure instanceof GroupFigure)) {
            return false;
        }
    }
    return view ().selectionCount () > 0;
}


protected Undoable createUndoActivity () {
    return new UngroupCommand.UndoActivity (view ());
}


public UndoActivity (DrawingView newDrawingView) {
    super (newDrawingView);
    setUndoable (true);
    setRedoable (true);
}


public boolean undo () {
    if (! super.undo ()) {
        return false;
    }
    getDrawingView ().clearSelection ();
    FigureEnumeration groupFigures = getAffectedFigures ();
    while (groupFigures.hasNextFigure ()) {
        Figure groupFigure = groupFigures.nextFigure ();
        getDrawingView ().drawing ().orphanAll (groupFigure.figures ());
        Figure figure = getDrawingView ().drawing ().add (groupFigure);
        getDrawingView ().addToSelection (figure);
    }
    return true;
}


public boolean redo () {
    if (isRedoable ()) {
        getDrawingView ().drawing ().orphanAll (getAffectedFigures ());
        getDrawingView ().clearSelection ();
        ungroupFigures ();
        return true;
    }
    return false;
}


protected void ungroupFigures () {
    FigureEnumeration fe = getAffectedFigures ();
    while (fe.hasNextFigure ()) {
        Figure selected = fe.nextFigure ();
        Figure group = getDrawingView ().drawing ().orphan (selected);
        getDrawingView ().drawing ().addAll (group.figures ());
        getDrawingView ().addToSelectionAll (group.figures ());
    }
}


private NullConnector () {
}


public NullConnector (Figure owner) {
    super (owner);
}


public GroupCommand (String name, DrawingEditor newDrawingEditor) {
    super (name, newDrawingEditor);
}


public void execute () {
    super.execute ();
    setUndoActivity (createUndoActivity ());
    getUndoActivity ().setAffectedFigures (view ().selection ());
    ((GroupCommand.UndoActivity) getUndoActivity ()).groupFigures ();
    view ().checkDamage ();
}


public boolean isExecutableWithView () {
    return view ().selectionCount () > 1;
}


protected Undoable createUndoActivity () {
    return new GroupCommand.UndoActivity (view ());
}


public UndoActivity (DrawingView newDrawingView) {
    super (newDrawingView);
    setUndoable (true);
    setRedoable (true);
}


public boolean undo () {
    if (! super.undo ()) {
        return false;
    }
    getDrawingView ().clearSelection ();
    getDrawingView ().drawing ().orphanAll (getAffectedFigures ());
    List affectedFigures = CollectionsFactory.current ().createList ();
    FigureEnumeration fe = getAffectedFigures ();
    while (fe.hasNextFigure ()) {
        Figure currentFigure = fe.nextFigure ();
        getDrawingView ().drawing ().addAll (currentFigure.figures ());
        getDrawingView ().addToSelectionAll (currentFigure.figures ());
        FigureEnumeration groupedFigures = currentFigure.figures ();
        while (groupedFigures.hasNextFigure ()) {
            affectedFigures.add (groupedFigures.nextFigure ());
        }
    }
    setAffectedFigures (new FigureEnumerator (affectedFigures));
    return true;
}


public boolean redo () {
    if (isRedoable ()) {
        groupFigures ();
        return true;
    }
    return false;
}


public void groupFigures () {
    getDrawingView ().drawing ().orphanAll (getAffectedFigures ());
    getDrawingView ().clearSelection ();
    GroupFigure group = new GroupFigure ();
    group.addAll (getAffectedFigures ());
    Figure figure = getDrawingView ().drawing ().add (group);
    getDrawingView ().addToSelection (figure);
    List affectedFigures = CollectionsFactory.current ().createList ();
    affectedFigures.add (figure);
    setAffectedFigures (new FigureEnumerator (affectedFigures));
}


public ImageFigure () {
    fFileName = null;
    fImage = null;
    fDisplayBox = null;
}


public ImageFigure (Image image, String fileName, Point origin) {
    fFileName = fileName;
    fImage = image;
    basicDisplayBox (origin, new Point (origin.x + fImage.getWidth (this), origin.y + fImage.getHeight (this)));
}


public void basicDisplayBox (Point origin, Point corner) {
    fDisplayBox = new Rectangle (origin);
    fDisplayBox.add (corner);
}


public HandleEnumeration handles () {
    List handles = CollectionsFactory.current ().createList ();
    BoxHandleKit.addHandles (this, handles);
    return new HandleEnumerator (handles);
}


public Rectangle displayBox () {
    return new Rectangle (fDisplayBox.x, fDisplayBox.y, fDisplayBox.width, fDisplayBox.height);
}


protected void basicMoveBy (int x, int y) {
    fDisplayBox.translate (x, y);
}


public void draw (Graphics g) {
    if (fImage == null) {
        fImage = Iconkit.instance ().getImage (fFileName);
    }
    if (fImage != null) {
        g.drawImage (fImage, fDisplayBox.x, fDisplayBox.y, fDisplayBox.width, fDisplayBox.height, this);
    } else {
        drawGhost (g);
    }
}


private void drawGhost (Graphics g) {
    g.setColor (Color.gray);
    g.fillRect (fDisplayBox.x, fDisplayBox.y, fDisplayBox.width, fDisplayBox.height);
}


public boolean imageUpdate (Image img, int flags, int x, int y, int w, int h) {
    if ((flags & (FRAMEBITS | ALLBITS)) != 0) {
        invalidate ();
        if (listener () != null) {
            listener ().figureRequestUpdate (new FigureChangeEvent (this));
        }
    }
    return (flags & (ALLBITS | ABORT)) == 0;
}


public void release () {
    fImage.flush ();
}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeInt (fDisplayBox.x);
    dw.writeInt (fDisplayBox.y);
    dw.writeInt (fDisplayBox.width);
    dw.writeInt (fDisplayBox.height);
    dw.writeString (fFileName);
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    fDisplayBox = new Rectangle (dr.readInt (), dr.readInt (), dr.readInt (), dr.readInt ());
    fFileName = dr.readString ();
    Iconkit.instance ().registerImage (fFileName);
}


private void readObject (ObjectInputStream s) throws ClassNotFoundException, IOException {
    s.defaultReadObject ();
    Iconkit.instance ().registerImage (fFileName);
    fImage = null;
}


public int overlayColumns () {
    return Math.max (4, getText ().length ());
}


public int getValue () {
    int value = 0;
    try {
        value = Integer.parseInt (getText ());
    } catch (NumberFormatException e) {
        value = 0;
    }
    return value;
}


public void setValue (int value) {
    setText (Integer.toString (value));
}


public Figure getRepresentingFigure () {
    return this;
}


public ElbowHandle (LineConnection owner, int segment) {
    super (owner);
    fSegment = segment;
}


public void invokeStart (int x, int y, DrawingView view) {
    fLastX = x;
    fLastY = y;
}


public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
    LineConnection line = ownerConnection ();
    Point p1 = line.pointAt (fSegment);
    Point p2 = line.pointAt (fSegment + 1);
    int ddx = x - fLastX;
    int ddy = y - fLastY;
    Point np1;
    Point np2;
    if (isVertical (p1, p2)) {
        int cx = constrainX (p1.x + ddx);
        np1 = new Point (cx, p1.y);
        np2 = new Point (cx, p2.y);
    } else {
        int cy = constrainY (p1.y + ddy);
        np1 = new Point (p1.x, cy);
        np2 = new Point (p2.x, cy);
    }
    line.setPointAt (np1, fSegment);
    line.setPointAt (np2, fSegment + 1);
    fLastX = x;
    fLastY = y;
}


private boolean isVertical (Point p1, Point p2) {
    return p1.x == p2.x;
}


public Point locate () {
    LineConnection line = ownerConnection ();
    int segment = Math.min (fSegment, line.pointCount () - 2);
    Point p1 = line.pointAt (segment);
    Point p2 = line.pointAt (segment + 1);
    return new Point ((p1.x + p2.x) / 2, (p1.y + p2.y) / 2);
}


public void draw (Graphics g) {
    Rectangle r = displayBox ();
    g.setColor (Color.yellow);
    g.fillOval (r.x, r.y, r.width, r.height);
    g.setColor (Color.black);
    g.drawOval (r.x, r.y, r.width, r.height);
}


private int constrainX (int x) {
    LineConnection line = ownerConnection ();
    Figure startFigure = line.getStartConnector ().owner ();
    Figure endFigure = line.getEndConnector ().owner ();
    Rectangle start = startFigure.displayBox ();
    Rectangle end = endFigure.displayBox ();
    Insets i1 = startFigure.connectionInsets ();
    Insets i2 = endFigure.connectionInsets ();
    int r1x, r1width, r2x, r2width;
    r1x = start.x + i1.left;
    r1width = start.width - i1.left - i1.right - 1;
    r2x = end.x + i2.left;
    r2width = end.width - i2.left - i2.right - 1;
    if (fSegment == 0) {
        x = Geom.range (r1x, r1x + r1width, x);
    }
    if (fSegment == line.pointCount () - 2) {
        x = Geom.range (r2x, r2x + r2width, x);
    }
    return x;
}


private int constrainY (int y) {
    LineConnection line = ownerConnection ();
    Figure startFigure = line.getStartConnector ().owner ();
    Figure endFigure = line.getEndConnector ().owner ();
    Rectangle start = startFigure.displayBox ();
    Rectangle end = endFigure.displayBox ();
    Insets i1 = startFigure.connectionInsets ();
    Insets i2 = endFigure.connectionInsets ();
    int r1y, r1height, r2y, r2height;
    r1y = start.y + i1.top;
    r1height = start.height - i1.top - i1.bottom - 1;
    r2y = end.y + i2.top;
    r2height = end.height - i2.top - i2.bottom - 1;
    if (fSegment == 0) {
        y = Geom.range (r1y, r1y + r1height, y);
    }
    if (fSegment == line.pointCount () - 2) {
        y = Geom.range (r2y, r2y + r2height, y);
    }
    return y;
}


private LineConnection ownerConnection () {
    return (LineConnection) owner ();
}


protected AttributeFigure () {
}


public void draw (Graphics g) {
    Color fill = getFillColor ();
    if (! ColorMap.isTransparent (fill)) {
        g.setColor (fill);
        drawBackground (g);
    }
    Color frame = getFrameColor ();
    if (! ColorMap.isTransparent (frame)) {
        g.setColor (frame);
        drawFrame (g);
    }
}


protected void drawBackground (Graphics g) {
}


protected void drawFrame (Graphics g) {
}


public Color getFillColor () {
    return (Color) getAttribute (FigureAttributeConstant.FILL_COLOR);
}


public Color getFrameColor () {
    return (Color) getAttribute (FigureAttributeConstant.FRAME_COLOR);
}


private static void initializeAttributes () {
    fgDefaultAttributes = new FigureAttributes ();
    fgDefaultAttributes.set (FigureAttributeConstant.FRAME_COLOR, Color.black);
    fgDefaultAttributes.set (FigureAttributeConstant.FILL_COLOR, new Color (0x70DB93));
    fgDefaultAttributes.set (FigureAttributeConstant.TEXT_COLOR, Color.black);
    fgDefaultAttributes.set (FigureAttributeConstant.ARROW_MODE, new Integer (0));
    fgDefaultAttributes.set (FigureAttributeConstant.FONT_NAME, "Helvetica");
    fgDefaultAttributes.set (FigureAttributeConstant.FONT_SIZE, new Integer (12));
    fgDefaultAttributes.set (FigureAttributeConstant.FONT_STYLE, new Integer (Font.PLAIN));
}


public static Object setDefaultAttribute (String name, Object value) {
    Object currentValue = getDefaultAttribute (name);
    fgDefaultAttributes.set (FigureAttributeConstant.getConstant (name), value);
    return currentValue;
}


public static Object initDefaultAttribute (String name, Object value) {
    Object currentValue = getDefaultAttribute (name);
    if (currentValue != null) {
        return currentValue;
    }
    fgDefaultAttributes.set (FigureAttributeConstant.getConstant (name), value);
    return null;
}


public static Object getDefaultAttribute (String name) {
    if (fgDefaultAttributes == null) {
        initializeAttributes ();
    }
    return fgDefaultAttributes.get (FigureAttributeConstant.getConstant (name));
}


public static Object getDefaultAttribute (FigureAttributeConstant attributeConstant) {
    if (fgDefaultAttributes == null) {
        initializeAttributes ();
    }
    return fgDefaultAttributes.get (attributeConstant);
}


public Object getAttribute (String name) {
    return getAttribute (FigureAttributeConstant.getConstant (name));
}


public Object getAttribute (FigureAttributeConstant attributeConstant) {
    if (fAttributes != null) {
        if (fAttributes.hasDefined (attributeConstant)) {
            return fAttributes.get (attributeConstant);
        }
    }
    return getDefaultAttribute (attributeConstant);
}


public void setAttribute (String name, Object value) {
    setAttribute (FigureAttributeConstant.getConstant (name), value);
}


public void setAttribute (FigureAttributeConstant attributeConstant, Object value) {
    if (fAttributes == null) {
        fAttributes = new FigureAttributes ();
    }
    fAttributes.set (attributeConstant, value);
    changed ();
}


public void write (StorableOutput dw) {
    super.write (dw);
    if (fAttributes == null) {
        dw.writeString ("no_attributes");
    } else {
        dw.writeString ("attributes");
        fAttributes.write (dw);
    }
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    String s = dr.readString ();
    if (s.toLowerCase ().equals ("attributes")) {
        fAttributes = new FigureAttributes ();
        fAttributes.read (dr);
    }
}


private void writeObject (ObjectOutputStream o) throws IOException {
    Object associatedMenu = getAttribute (Figure.POPUP_MENU);
    if (associatedMenu != null) {
        setAttribute (Figure.POPUP_MENU, null);
    }
    o.defaultWriteObject ();
    if (associatedMenu != null) {
        setAttribute (Figure.POPUP_MENU, associatedMenu);
    }
}


public InsertImageCommand (String name, String newImageName, DrawingEditor newDrawingEditor) {
    super (name, newDrawingEditor);
    myImageName = newImageName;
}


public void execute () {
    super.execute ();
    setUndoActivity (createUndoActivity ());
    ((InsertImageCommand.UndoActivity) getUndoActivity ()).insertImage ();
    view ().checkDamage ();
}


protected Undoable createUndoActivity () {
    return new InsertImageCommand.UndoActivity (view (), myImageName);
}


UndoActivity (DrawingView newDrawingView, String newAffectedImageName) {
    super (newDrawingView);
    myAffectedImageName = newAffectedImageName;
    setUndoable (true);
    setRedoable (true);
}


protected void setImageFigure (ImageFigure newImageFigure) {
    myAffectedImageFigure = new WeakReference (newImageFigure);
}


protected ImageFigure getImageFigure () {
    if ((myAffectedImageFigure == null) || (myAffectedImageFigure.get () == null)) {
        Image image = Iconkit.instance ().registerAndLoadImage ((Component) getDrawingView (), myAffectedImageName);
        setImageFigure (new ImageFigure (image, myAffectedImageName, getDrawingView ().lastClick ()));
    }
    return (ImageFigure) myAffectedImageFigure.get ();
}


public boolean undo () {
    if (super.undo ()) {
        getDrawingView ().clearSelection ();
        getDrawingView ().drawing ().orphan (getImageFigure ());
        return true;
    }
    return false;
}


public boolean redo () {
    if (isRedoable ()) {
        insertImage ();
        return true;
    }
    return false;
}


protected void insertImage () {
    getDrawingView ().add (getImageFigure ());
    getDrawingView ().clearSelection ();
    getDrawingView ().addToSelection (getImageFigure ());
}


public ArrowTip () {
    this (0.40, 8, 8);
}


public ArrowTip (double angle, double outerRadius, double innerRadius) {
    setAngle (angle);
    setOuterRadius (outerRadius);
    setInnerRadius (innerRadius);
}


public Polygon outline (int x1, int y1, int x2, int y2) {
    double dir = Math.PI / 2 - Math.atan2 (x2 - x1, y2 - y1);
    return outline (x1, y1, dir);
}


private Polygon outline (int x, int y, double direction) {
    Polygon shape = new Polygon ();
    shape.addPoint (x, y);
    addPointRelative (shape, x, y, getOuterRadius (), direction - getAngle ());
    addPointRelative (shape, x, y, getInnerRadius (), direction);
    addPointRelative (shape, x, y, getOuterRadius (), direction + getAngle ());
    shape.addPoint (x, y);
    return shape;
}


private void addPointRelative (Polygon shape, int x, int y, double radius, double angle) {
    shape.addPoint (x + (int) (radius * Math.cos (angle)), y + (int) (radius * Math.sin (angle)));
}


public void write (StorableOutput dw) {
    dw.writeDouble (getAngle ());
    dw.writeDouble (getOuterRadius ());
    dw.writeDouble (getInnerRadius ());
    super.write (dw);
}


public void read (StorableInput dr) throws IOException {
    setAngle (dr.readDouble ());
    setOuterRadius (dr.readDouble ());
    setInnerRadius (dr.readDouble ());
    super.read (dr);
}


protected void setAngle (double newAngle) {
    fAngle = newAngle;
}


protected double getAngle () {
    return fAngle;
}


protected void setInnerRadius (double newInnerRadius) {
    fInnerRadius = newInnerRadius;
}


protected double getInnerRadius () {
    return fInnerRadius;
}


protected void setOuterRadius (double newOuterRadius) {
    fOuterRadius = newOuterRadius;
}


protected double getOuterRadius () {
    return fOuterRadius;
}


public RectangleFigure () {
    this (new Point (0, 0), new Point (0, 0));
}


public RectangleFigure (Point origin, Point corner) {
    basicDisplayBox (origin, corner);
}


public void basicDisplayBox (Point origin, Point corner) {
    fDisplayBox = new Rectangle (origin);
    fDisplayBox.add (corner);
}


public HandleEnumeration handles () {
    List handles = CollectionsFactory.current ().createList ();
    BoxHandleKit.addHandles (this, handles);
    return new HandleEnumerator (handles);
}


public Rectangle displayBox () {
    return new Rectangle (fDisplayBox.x, fDisplayBox.y, fDisplayBox.width, fDisplayBox.height);
}


protected void basicMoveBy (int x, int y) {
    fDisplayBox.translate (x, y);
}


public void drawBackground (Graphics g) {
    Rectangle r = displayBox ();
    g.fillRect (r.x, r.y, r.width, r.height);
}


public void drawFrame (Graphics g) {
    Rectangle r = displayBox ();
    g.drawRect (r.x, r.y, r.width - 1, r.height - 1);
}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeInt (fDisplayBox.x);
    dw.writeInt (fDisplayBox.y);
    dw.writeInt (fDisplayBox.width);
    dw.writeInt (fDisplayBox.height);
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    fDisplayBox = new Rectangle (dr.readInt (), dr.readInt (), dr.readInt (), dr.readInt ());
}


public PolyLineConnector () {
    super ();
}


public PolyLineConnector (Figure owner) {
    super (owner);
}


protected Point chop (Figure target, Point from) {
    PolyLineFigure p = (PolyLineFigure) owner ();
    Point ctr = p.center ();
    int cx = - 1;
    int cy = - 1;
    long len = Long.MAX_VALUE;
    for (int i = 0;
    i 

public PolyLineFigure () {
    this (4);
}


public PolyLineFigure (int size) {
    fPoints = CollectionsFactory.current ().createList (size);
}


public PolyLineFigure (int x, int y) {
    fPoints = CollectionsFactory.current ().createList ();
    fPoints.add (new Point (x, y));
}


public Rectangle displayBox () {
    Iterator iter = points ();
    if (iter.hasNext ()) {
        Rectangle r = new Rectangle ((Point) iter.next ());
        while (iter.hasNext ()) {
            r.add ((Point) iter.next ());
        }
        return r;
    } else {
        return new Rectangle ();
    }
}


public boolean isEmpty () {
    return (size ().width 

public HandleEnumeration handles () {
    List handles = CollectionsFactory.current ().createList (fPoints.size ());
    for (int i = 0;
    i 

public void basicDisplayBox (Point origin, Point corner) {
}


public void addPoint (int x, int y) {
    fPoints.add (new Point (x, y));
    changed ();
}


public Iterator points () {
    return fPoints.iterator ();
}


public int pointCount () {
    return fPoints.size ();
}


protected void basicMoveBy (int dx, int dy) {
    Iterator iter = points ();
    while (iter.hasNext ()) {
        ((Point) iter.next ()).translate (dx, dy);
    }
}


public void setPointAt (Point p, int i) {
    willChange ();
    fPoints.set (i, p);
    changed ();
}


public void insertPointAt (Point p, int i) {
    fPoints.add (i, p);
    changed ();
}


public void removePointAt (int i) {
    willChange ();
    fPoints.remove (i);
    changed ();
}


public int splitSegment (int x, int y) {
    int i = findSegment (x, y);
    if (i != - 1) {
        insertPointAt (new Point (x, y), i + 1);
    }
    return i + 1;
}


public Point pointAt (int i) {
    return (Point) fPoints.get (i);
}


public boolean joinSegments (int x, int y) {
    for (int i = 1;
    i 

public Connector connectorAt (int x, int y) {
    return new PolyLineConnector (this);
}


public void setStartDecoration (LineDecoration l) {
    fStartDecoration = l;
}


public LineDecoration getStartDecoration () {
    return fStartDecoration;
}


public void setEndDecoration (LineDecoration l) {
    fEndDecoration = l;
}


public LineDecoration getEndDecoration () {
    return fEndDecoration;
}


public void draw (Graphics g) {
    g.setColor (getFrameColor ());
    Point p1, p2;
    for (int i = 0;
    i 

protected void drawLine (Graphics g, int x1, int y1, int x2, int y2) {
    g.drawLine (x1, y1, x2, y2);
}


public boolean containsPoint (int x, int y) {
    Rectangle bounds = displayBox ();
    bounds.grow (4, 4);
    if (! bounds.contains (x, y)) {
        return false;
    }
    for (int i = 0;
    i 

public int findSegment (int x, int y) {
    for (int i = 0;
    i 

private void decorate (Graphics g) {
    if (getStartDecoration () != null) {
        Point p1 = pointAt (0);
        Point p2 = pointAt (1);
        getStartDecoration ().draw (g, p1.x, p1.y, p2.x, p2.y);
    }
    if (getEndDecoration () != null) {
        Point p3 = pointAt (fPoints.size () - 2);
        Point p4 = pointAt (fPoints.size () - 1);
        getEndDecoration ().draw (g, p4.x, p4.y, p3.x, p3.y);
    }
}


public Object getAttribute (String name) {
    return getAttribute (FigureAttributeConstant.getConstant (name));
}


public Object getAttribute (FigureAttributeConstant attributeConstant) {
    if (attributeConstant.equals (FigureAttributeConstant.FRAME_COLOR)) {
        return getFrameColor ();
    } else if (attributeConstant.equals (FigureAttributeConstant.ARROW_MODE)) {
        int value = 0;
        if (getStartDecoration () != null) {
            value |= ARROW_TIP_START;
        }
        if (getEndDecoration () != null) {
            value |= ARROW_TIP_END;
        }
        return new Integer (value);
    }

    return super.getAttribute (attributeConstant);
}


public void setAttribute (String name, Object value) {
    setAttribute (FigureAttributeConstant.getConstant (name), value);
}


public void setAttribute (FigureAttributeConstant attributeConstant, Object value) {
    if (attributeConstant.equals (FigureAttributeConstant.FRAME_COLOR)) {
        setFrameColor ((Color) value);
        changed ();
    } else if (attributeConstant.equals (FigureAttributeConstant.ARROW_MODE)) {
        Integer intObj = (Integer) value;
        if (intObj != null) {
            int decoration = intObj.intValue ();
            if ((decoration & ARROW_TIP_START) != 0) {
                setStartDecoration (new ArrowTip ());
            } else {
                setStartDecoration (null);
            }
            if ((decoration & ARROW_TIP_END) != 0) {
                setEndDecoration (new ArrowTip ());
            } else {
                setEndDecoration (null);
            }
        }
        changed ();
    } else {
        super.setAttribute (attributeConstant, value);
    }

}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeInt (fPoints.size ());
    Iterator iter = points ();
    while (iter.hasNext ()) {
        Point p = (Point) iter.next ();
        dw.writeInt (p.x);
        dw.writeInt (p.y);
    }
    dw.writeStorable (fStartDecoration);
    dw.writeStorable (fEndDecoration);
    dw.writeColor (fFrameColor);
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    int size = dr.readInt ();
    fPoints = CollectionsFactory.current ().createList (size);
    for (int i = 0;
    i 

public static Locator locator (int pointIndex) {
    return new PolyLineLocator (pointIndex);
}


protected Color getFrameColor () {
    return fFrameColor;
}


protected void setFrameColor (Color c) {
    fFrameColor = c;
}


protected Rectangle invalidateRectangle (Rectangle r) {
    Rectangle parentR = super.invalidateRectangle (r);
    if (getStartDecoration () != null) {
        parentR.add (getStartDecoration ().displayBox ());
    }
    if (getEndDecoration () != null) {
        parentR.add (getEndDecoration ().displayBox ());
    }
    return parentR;
}


public ConnectedTextTool (DrawingEditor editor, Figure prototype) {
    super (editor, prototype);
}


public void mouseDown (MouseEvent e, int x, int y) {
    super.mouseDown (e, x, y);
    if (getTypingTarget () != null) {
        TextHolder textHolder = getTypingTarget ();
        setConnectedFigure (drawing ().findFigureInsideWithout (x, y, textHolder.getRepresentingFigure ()));
        if ((getConnectedFigure () != null) && (textHolder != null) && (getConnectedFigure ().getTextHolder () != textHolder)) {
            textHolder.connect (getConnectedFigure ().getDecoratedFigure ());
            getConnectedFigure ().addDependendFigure (getAddedFigure ());
        }
    }
}


protected void endEdit () {
    super.endEdit ();
    if ((getUndoActivity () != null) && (getUndoActivity () instanceof ConnectedTextTool.UndoActivity)) {
        ((ConnectedTextTool.UndoActivity) getUndoActivity ()).setConnectedFigure (getConnectedFigure ());
    } else if ((getConnectedFigure () != null) && isDeleteTextFigure ()) {
        getConnectedFigure ().removeDependendFigure (getAddedFigure ());
    }

}


protected void setConnectedFigure (Figure pressedFigure) {
    myConnectedFigure = pressedFigure;
}


public Figure getConnectedFigure () {
    return myConnectedFigure;
}


public void activate () {
    super.activate ();
    setConnectedFigure (null);
}


protected Undoable createDeleteUndoActivity () {
    FigureTransferCommand cmd = new DeleteCommand ("Delete", editor ());
    return new DeleteUndoActivity (cmd, getConnectedFigure ());
}


protected Undoable createUndoActivity () {
    return new ConnectedTextTool.UndoActivity (view (), getTypingTarget ().getText ());
}


public UndoActivity (DrawingView newDrawingView, String newOriginalText) {
    super (newDrawingView, newOriginalText);
}


public boolean undo () {
    if (! super.undo ()) {
        return false;
    }
    FigureEnumeration fe = getAffectedFigures ();
    while (fe.hasNextFigure ()) {
        Figure currentFigure = fe.nextFigure ();
        if (currentFigure.getTextHolder () != null) {
            if (! isValidText (getOriginalText ())) {
                currentFigure.getTextHolder ().disconnect (getConnectedFigure ());
            } else if (! isValidText (getBackupText ())) {
                currentFigure.getTextHolder ().connect (getConnectedFigure ());
            }

        }
    }
    return true;
}


public boolean redo () {
    if (! super.redo ()) {
        return false;
    }
    FigureEnumeration fe = getAffectedFigures ();
    while (fe.hasNextFigure ()) {
        Figure currentFigure = fe.nextFigure ();
        if (currentFigure.getTextHolder () != null) {
            if (! isValidText (getBackupText ())) {
                currentFigure.getTextHolder ().disconnect (getConnectedFigure ());
            } else if (! isValidText (getOriginalText ())) {
                currentFigure.getTextHolder ().connect (getConnectedFigure ());
            }

        }
    }
    return true;
}


public void setConnectedFigure (Figure newConnectedFigure) {
    myConnectedFigure = newConnectedFigure;
}


public Figure getConnectedFigure () {
    return myConnectedFigure;
}


public DeleteUndoActivity (FigureTransferCommand cmd, Figure newConnectedFigure) {
    super (cmd);
    setConnectedFigure (newConnectedFigure);
}


public boolean undo () {
    if (! super.undo ()) {
        return false;
    }
    FigureEnumeration fe = getAffectedFigures ();
    while (fe.hasNextFigure ()) {
        Figure currentFigure = fe.nextFigure ();
        if (currentFigure.getTextHolder () != null) {
            currentFigure.getTextHolder ().connect (getConnectedFigure ().getDecoratedFigure ());
        }
    }
    return true;
}


public boolean redo () {
    if (! super.redo ()) {
        return false;
    }
    FigureEnumeration fe = getAffectedFigures ();
    while (fe.hasNextFigure ()) {
        Figure currentFigure = fe.nextFigure ();
        if (currentFigure.getTextHolder () != null) {
            currentFigure.getTextHolder ().disconnect (getConnectedFigure ().getDecoratedFigure ());
        }
    }
    return true;
}


public void setConnectedFigure (Figure newConnectedFigure) {
    myConnectedFigure = newConnectedFigure;
}


public Figure getConnectedFigure () {
    return myConnectedFigure;
}


public PolyLineHandle (PolyLineFigure owner, Locator l, int index) {
    super (owner, l);
    fIndex = index;
}


public void invokeStart (int x, int y, DrawingView view) {
    setUndoActivity (createUndoActivity (view, fIndex));
    getUndoActivity ().setAffectedFigures (new SingleFigureEnumerator (owner ()));
    ((PolyLineHandle.UndoActivity) getUndoActivity ()).setOldPoint (new Point (x, y));
}


public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
    int fIndex = ((PolyLineHandle.UndoActivity) getUndoActivity ()).getPointIndex ();
    myOwner ().setPointAt (new Point (x, y), fIndex);
}


public void invokeEnd (int x, int y, int anchorX, int anchorY, DrawingView view) {
    if ((x == anchorX) && (y == anchorY)) {
        setUndoActivity (null);
    }
}


private PolyLineFigure myOwner () {
    return (PolyLineFigure) owner ();
}


protected Undoable createUndoActivity (DrawingView newView, int newPointIndex) {
    return new PolyLineHandle.UndoActivity (newView, newPointIndex);
}


public UndoActivity (DrawingView newView, int newPointIndex) {
    super (newView);
    setUndoable (true);
    setRedoable (true);
    setPointIndex (newPointIndex);
}


public boolean undo () {
    if (! super.undo ()) {
        return false;
    }
    return movePointToOldLocation ();
}


public boolean redo () {
    if (! isRedoable ()) {
        return false;
    }
    return movePointToOldLocation ();
}


protected boolean movePointToOldLocation () {
    FigureEnumeration fe = getAffectedFigures ();
    if (! fe.hasNextFigure ()) {
        return false;
    }
    PolyLineFigure figure = (PolyLineFigure) fe.nextFigure ();
    Point backupPoint = figure.pointAt (getPointIndex ());
    figure.setPointAt (getOldPoint (), getPointIndex ());
    setOldPoint (backupPoint);
    return true;
}


public void setOldPoint (Point newOldPoint) {
    myOldPoint = newOldPoint;
}


public Point getOldPoint () {
    return myOldPoint;
}


public void setPointIndex (int newPointIndex) {
    myPointIndex = newPointIndex;
}


public int getPointIndex () {
    return myPointIndex;
}


public GroupHandle (Figure owner, Locator locator) {
    super (owner, locator);
}


public void draw (Graphics g) {
    Rectangle r = displayBox ();
    g.setColor (Color.black);
    g.drawRect (r.x, r.y, r.width, r.height);
    r.grow (- 1, - 1);
    g.setColor (Color.white);
    g.drawRect (r.x, r.y, r.width, r.height);
}


public ChopEllipseConnector () {
}


public ChopEllipseConnector (Figure owner) {
    super (owner);
}


protected Point chop (Figure target, Point from) {
    Rectangle r = target.displayBox ();
    double angle = Geom.pointToAngle (r, from);
    return Geom.ovalAngleToPoint (r, angle);
}


public RadiusHandle (RoundRectangleFigure owner) {
    super (owner);
}


public void invokeStart (int x, int y, DrawingView view) {
    setUndoActivity (createUndoActivity (view));
    getUndoActivity ().setAffectedFigures (new SingleFigureEnumerator (owner ()));
    ((RadiusHandle.UndoActivity) getUndoActivity ()).setOldRadius (((RoundRectangleFigure) owner ()).getArc ());
}


public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
    int dx = x - anchorX;
    int dy = y - anchorY;
    RoundRectangleFigure owner = (RoundRectangleFigure) owner ();
    Rectangle r = owner.displayBox ();
    Point originalRadius = ((RadiusHandle.UndoActivity) getUndoActivity ()).getOldRadius ();
    int rx = Geom.range (0, r.width, 2 * (originalRadius.x / 2 + dx));
    int ry = Geom.range (0, r.height, 2 * (originalRadius.y / 2 + dy));
    owner.setArc (rx, ry);
}


public void invokeEnd (int x, int y, int anchorX, int anchorY, DrawingView view) {
    Point currentRadius = ((RoundRectangleFigure) owner ()).getArc ();
    Point originalRadius = ((RadiusHandle.UndoActivity) getUndoActivity ()).getOldRadius ();
    if ((currentRadius.x == originalRadius.x) && (currentRadius.y == originalRadius.y)) {
        setUndoActivity (null);
    }
}


public Point locate () {
    RoundRectangleFigure owner = (RoundRectangleFigure) owner ();
    Point radius = owner.getArc ();
    Rectangle r = owner.displayBox ();
    return new Point (r.x + radius.x / 2 + OFFSET, r.y + radius.y / 2 + OFFSET);
}


public void draw (Graphics g) {
    Rectangle r = displayBox ();
    g.setColor (Color.yellow);
    g.fillOval (r.x, r.y, r.width, r.height);
    g.setColor (Color.black);
    g.drawOval (r.x, r.y, r.width, r.height);
}


protected Undoable createUndoActivity (DrawingView newView) {
    return new RadiusHandle.UndoActivity (newView);
}


public UndoActivity (DrawingView newView) {
    super (newView);
    setUndoable (true);
    setRedoable (true);
}


public boolean undo () {
    if (! super.undo ()) {
        return false;
    }
    return resetRadius ();
}


public boolean redo () {
    if (! isRedoable ()) {
        return false;
    }
    return resetRadius ();
}


protected boolean resetRadius () {
    FigureEnumeration fe = getAffectedFigures ();
    if (! fe.hasNextFigure ()) {
        return false;
    }
    RoundRectangleFigure currentFigure = (RoundRectangleFigure) fe.nextFigure ();
    Point figureRadius = currentFigure.getArc ();
    currentFigure.setArc (getOldRadius ().x, getOldRadius ().y);
    setOldRadius (figureRadius);
    return true;
}


protected void setOldRadius (Point newOldRadius) {
    myOldRadius = newOldRadius;
}


public Point getOldRadius () {
    return myOldRadius;
}


public LineConnection () {
    super (4);
    setStartDecoration (new ArrowTip ());
    setEndDecoration (new ArrowTip ());
}


public boolean canConnect () {
    return false;
}


protected void basicMoveBy (int dx, int dy) {
    for (int i = 1;
    i 

public void connectStart (Connector newStartConnector) {
    setStartConnector (newStartConnector);
    if (newStartConnector != null) {
        startFigure ().addDependendFigure (this);
        startFigure ().addFigureChangeListener (this);
    }
}


public void connectEnd (Connector newEndConnector) {
    setEndConnector (newEndConnector);
    if (newEndConnector != null) {
        endFigure ().addDependendFigure (this);
        endFigure ().addFigureChangeListener (this);
        handleConnect (startFigure (), endFigure ());
    }
}


public void disconnectStart () {
    startFigure ().removeFigureChangeListener (this);
    startFigure ().removeDependendFigure (this);
    setStartConnector (null);
}


public void disconnectEnd () {
    handleDisconnect (startFigure (), endFigure ());
    endFigure ().removeFigureChangeListener (this);
    endFigure ().removeDependendFigure (this);
    setEndConnector (null);
}


public boolean connectsSame (ConnectionFigure other) {
    return other.getStartConnector () == getStartConnector () && other.getEndConnector () == getEndConnector ();
}


protected void handleDisconnect (Figure start, Figure end) {
}


protected void handleConnect (Figure start, Figure end) {
}


public Figure startFigure () {
    if (getStartConnector () != null) {
        return getStartConnector ().owner ();
    }
    return null;
}


public Figure endFigure () {
    if (getEndConnector () != null) {
        return getEndConnector ().owner ();
    }
    return null;
}


protected void setStartConnector (Connector newStartConnector) {
    myStartConnector = newStartConnector;
}


public Connector getStartConnector () {
    return myStartConnector;
}


protected void setEndConnector (Connector newEndConnector) {
    myEndConnector = newEndConnector;
}


public Connector getEndConnector () {
    return myEndConnector;
}


public boolean canConnect (Figure start, Figure end) {
    return true;
}


public void startPoint (int x, int y) {
    willChange ();
    if (fPoints.size () == 0) {
        fPoints.add (new Point (x, y));
    } else {
        fPoints.set (0, new Point (x, y));
    }
    changed ();
}


public void endPoint (int x, int y) {
    willChange ();
    if (fPoints.size () 

public Point startPoint () {
    Point p = pointAt (0);
    return new Point (p.x, p.y);
}


public Point endPoint () {
    if (fPoints.size () > 0) {
        Point p = pointAt (fPoints.size () - 1);
        return new Point (p.x, p.y);
    } else {
        return null;
    }
}


public HandleEnumeration handles () {
    List handles = CollectionsFactory.current ().createList (fPoints.size ());
    handles.add (new ChangeConnectionStartHandle (this));
    for (int i = 1;
    i 

public void setPointAt (Point p, int i) {
    super.setPointAt (p, i);
    layoutConnection ();
}


public void insertPointAt (Point p, int i) {
    super.insertPointAt (p, i);
    layoutConnection ();
}


public void removePointAt (int i) {
    super.removePointAt (i);
    layoutConnection ();
}


public void updateConnection () {
    if (getStartConnector () != null) {
        Point start = getStartConnector ().findStart (this);
        if (start != null) {
            startPoint (start.x, start.y);
        }
    }
    if (getEndConnector () != null) {
        Point end = getEndConnector ().findEnd (this);
        if (end != null) {
            endPoint (end.x, end.y);
        }
    }
}


public void layoutConnection () {
    updateConnection ();
}


public void figureChanged (FigureChangeEvent e) {
    updateConnection ();
}


public void figureRemoved (FigureChangeEvent e) {
}


public void figureRequestRemove (FigureChangeEvent e) {
}


public void figureInvalidated (FigureChangeEvent e) {
}


public void figureRequestUpdate (FigureChangeEvent e) {
}


public void release () {
    super.release ();
    handleDisconnect (startFigure (), endFigure ());
    if (getStartConnector () != null) {
        startFigure ().removeFigureChangeListener (this);
    }
    if (getEndConnector () != null) {
        endFigure ().removeFigureChangeListener (this);
    }
}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeStorable (getStartConnector ());
    dw.writeStorable (getEndConnector ());
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    Connector start = (Connector) dr.readStorable ();
    if (start != null) {
        connectStart (start);
    }
    Connector end = (Connector) dr.readStorable ();
    if (end != null) {
        connectEnd (end);
    }
    if ((start != null) && (end != null)) {
        updateConnection ();
    }
}


private void readObject (ObjectInputStream s) throws ClassNotFoundException, IOException {
    s.defaultReadObject ();
    if (getStartConnector () != null) {
        connectStart (getStartConnector ());
    }
    if (getEndConnector () != null) {
        connectEnd (getEndConnector ());
    }
}


public void visit (FigureVisitor visitor) {
    visitor.visitFigure (this);
}


public ElbowConnection () {
    super ();
}


public void updateConnection () {
    super.updateConnection ();
    updatePoints ();
}


public void layoutConnection () {
}


public HandleEnumeration handles () {
    List handles = CollectionsFactory.current ().createList (fPoints.size () * 2);
    handles.add (new ChangeConnectionStartHandle (this));
    for (int i = 1;
    i 

public Locator connectedTextLocator (Figure f) {
    return new ElbowTextLocator ();
}


protected void updatePoints () {
    willChange ();
    Point start = startPoint ();
    Point end = endPoint ();
    fPoints.clear ();
    fPoints.add (start);
    if (start.x == end.x || start.y == end.y) {
        fPoints.add (end);
    } else {
        Rectangle r1 = getStartConnector ().owner ().displayBox ();
        Rectangle r2 = getEndConnector ().owner ().displayBox ();
        int dir = Geom.direction (r1.x + r1.width / 2, r1.y + r1.height / 2, r2.x + r2.width / 2, r2.y + r2.height / 2);
        if (dir == Geom.NORTH || dir == Geom.SOUTH) {
            fPoints.add (new Point (start.x, (start.y + end.y) / 2));
            fPoints.add (new Point (end.x, (start.y + end.y) / 2));
        } else {
            fPoints.add (new Point ((start.x + end.x) / 2, start.y));
            fPoints.add (new Point ((start.x + end.x) / 2, end.y));
        }
        fPoints.add (end);
    }
    changed ();
}


public Point locate (Figure owner) {
    Point p = owner.center ();
    return new Point (p.x, p.y - 10);
}


public BorderTool (DrawingEditor editor) {
    super (editor);
}


public void mouseDown (MouseEvent e, int x, int y) {
    setView ((DrawingView) e.getSource ());
    if ((e.getModifiers () & InputEvent.CTRL_MASK) == 0) {
        super.mouseDown (e, x, y);
    } else {
        Figure target = drawing ().findFigure (x, y);
        if ((target != null) && (target != target.getDecoratedFigure ())) {
            view ().addToSelection (target);
            reverseAction (target);
        }
    }
}


public void action (Figure figure) {
    setUndoActivity (createUndoActivity ());
    List l = CollectionsFactory.current ().createList ();
    l.add (figure);
    l.add (new BorderDecorator (figure));
    getUndoActivity ().setAffectedFigures (new FigureEnumerator (l));
    ((BorderTool.UndoActivity) getUndoActivity ()).replaceAffectedFigures ();
}


public void reverseAction (Figure figure) {
    setUndoActivity (createUndoActivity ());
    List l = CollectionsFactory.current ().createList ();
    l.add (figure);
    l.add (((DecoratorFigure) figure).peelDecoration ());
    getUndoActivity ().setAffectedFigures (new FigureEnumerator (l));
    ((BorderTool.UndoActivity) getUndoActivity ()).replaceAffectedFigures ();
}


protected Undoable createUndoActivity () {
    return new BorderTool.UndoActivity (view ());
}


public UndoActivity (DrawingView newDrawingView) {
    super (newDrawingView);
    setUndoable (true);
    setRedoable (true);
}


public boolean undo () {
    if (! super.undo ()) {
        return false;
    }
    getDrawingView ().clearSelection ();
    return replaceAffectedFigures ();
}


public boolean redo () {
    if (! isRedoable ()) {
        return false;
    }
    getDrawingView ().clearSelection ();
    return replaceAffectedFigures ();
}


public boolean replaceAffectedFigures () {
    FigureEnumeration fe = getAffectedFigures ();
    if (! fe.hasNextFigure ()) {
        return false;
    }
    Figure oldFigure = fe.nextFigure ();
    if (! fe.hasNextFigure ()) {
        return false;
    }
    Figure replaceFigure = fe.nextFigure ();
    replaceFigure = getDrawingView ().drawing ().replace (oldFigure, replaceFigure);
    List l = CollectionsFactory.current ().createList ();
    l.add (replaceFigure);
    l.add (oldFigure);
    setAffectedFigures (new FigureEnumerator (l));
    return true;
}


public AbstractLineDecoration () {
}


public void draw (Graphics g, int x1, int y1, int x2, int y2) {
    Polygon p = outline (x1, y1, x2, y2);
    myBounds = p.getBounds ();
    if (getFillColor () == null) {
        g.fillPolygon (p.xpoints, p.ypoints, p.npoints);
    } else {
        Color drawColor = g.getColor ();
        g.setColor (getFillColor ());
        g.fillPolygon (p.xpoints, p.ypoints, p.npoints);
        g.setColor (drawColor);
    }
    if (getBorderColor () != getFillColor ()) {
        Color drawColor = g.getColor ();
        g.setColor (getBorderColor ());
        g.drawPolygon (p.xpoints, p.ypoints, p.npoints);
        g.setColor (drawColor);
    }
}


public Rectangle displayBox () {
    if (myBounds != null) {
        return myBounds;
    } else {
        return new Rectangle (0, 0);
    }
}


public void write (StorableOutput dw) {
    if (getFillColor () != null) {
        FigureAttributes.writeColor (dw, FigureAttributeConstant.FILL_COLOR.getName (), getFillColor ());
    } else {
        dw.writeString ("no" + FigureAttributeConstant.FILL_COLOR.getName ());
    }
    if (getBorderColor () != null) {
        FigureAttributes.writeColor (dw, FigureAttributeConstant.FRAME_COLOR.getName (), getBorderColor ());
    } else {
        dw.writeString ("no" + FigureAttributeConstant.FRAME_COLOR.getName ());
    }
}


public void read (StorableInput dr) throws IOException {
    String fillColorId = dr.readString ();
    if (fillColorId.equals (FigureAttributeConstant.FRAME_COLOR.getName ())) {
        setFillColor (FigureAttributes.readColor (dr));
    }
    String borderColorId = dr.readString ();
    if (borderColorId.equals ("BorderColor") || borderColorId.equals (FigureAttributeConstant.FRAME_COLOR.getName ())) {
        setBorderColor (FigureAttributes.readColor (dr));
    }
}


public void setFillColor (Color fillColor) {
    fFillColor = fillColor;
}


public Color getFillColor () {
    return fFillColor;
}


public void setBorderColor (Color borderColor) {
    fBorderColor = borderColor;
}


public Color getBorderColor () {
    return fBorderColor;
}


public TextFigure () {
    fOriginX = 0;
    fOriginY = 0;
    fFont = createCurrentFont ();
    setAttribute (FigureAttributeConstant.FILL_COLOR, ColorMap.color ("None"));
    fText = new String ("");
    fSizeIsDirty = true;
}


public void moveBy (int x, int y) {
    willChange ();
    basicMoveBy (x, y);
    if (getLocator () != null) {
        getLocator ().moveBy (x, y);
    }
    changed ();
}


protected void basicMoveBy (int x, int y) {
    fOriginX += x;
    fOriginY += y;
}


public void basicDisplayBox (Point newOrigin, Point newCorner) {
    fOriginX = newOrigin.x;
    fOriginY = newOrigin.y;
}


public Rectangle displayBox () {
    Dimension extent = textExtent ();
    return new Rectangle (fOriginX, fOriginY, extent.width, extent.height);
}


public Rectangle textDisplayBox () {
    return displayBox ();
}


public boolean readOnly () {
    return fIsReadOnly;
}


public void setReadOnly (boolean isReadOnly) {
    fIsReadOnly = isReadOnly;
}


public Font getFont () {
    return fFont;
}


public Figure getRepresentingFigure () {
    return this;
}


public void setFont (Font newFont) {
    willChange ();
    fFont = newFont;
    markDirty ();
    changed ();
}


public void changed () {
    super.changed ();
    updateLocation ();
}


public Object getAttribute (String name) {
    return getAttribute (FigureAttributeConstant.getConstant (name));
}


public Object getAttribute (FigureAttributeConstant attributeConstant) {
    Font font = getFont ();
    if (attributeConstant.equals (FigureAttributeConstant.FONT_SIZE)) {
        return new Integer (font.getSize ());
    }
    if (attributeConstant.equals (FigureAttributeConstant.FONT_STYLE)) {
        return new Integer (font.getStyle ());
    }
    if (attributeConstant.equals (FigureAttributeConstant.FONT_NAME)) {
        return font.getName ();
    }
    return super.getAttribute (attributeConstant);
}


public void setAttribute (String name, Object value) {
    setAttribute (FigureAttributeConstant.getConstant (name), value);
}


public void setAttribute (FigureAttributeConstant attributeConstant, Object value) {
    Font font = getFont ();
    if (attributeConstant.equals (FigureAttributeConstant.FONT_SIZE)) {
        Integer s = (Integer) value;
        setFont (new Font (font.getName (), font.getStyle (), s.intValue ()));
    } else if (attributeConstant.equals (FigureAttributeConstant.FONT_STYLE)) {
        Integer s = (Integer) value;
        int style = font.getStyle ();
        if (s.intValue () == Font.PLAIN) {
            style = font.PLAIN;
        } else {
            style = style ^ s.intValue ();
        }
        setFont (new Font (font.getName (), style, font.getSize ()));
    } else if (attributeConstant.equals (FigureAttributeConstant.FONT_NAME)) {
        String n = (String) value;
        setFont (new Font (n, font.getStyle (), font.getSize ()));
    } else {
        super.setAttribute (attributeConstant, value);
    }

}


public String getText () {
    return fText;
}


public void setText (String newText) {
    if (! newText.equals (fText)) {
        willChange ();
        fText = new String (newText);
        markDirty ();
        changed ();
    }
}


public boolean acceptsTyping () {
    return ! fIsReadOnly;
}


public void drawBackground (Graphics g) {
    Rectangle r = displayBox ();
    g.fillRect (r.x, r.y, r.width, r.height);
}


public void drawFrame (Graphics g) {
    g.setFont (fFont);
    g.setColor ((Color) getAttribute (FigureAttributeConstant.TEXT_COLOR));
    FontMetrics metrics = g.getFontMetrics (fFont);
    g.drawString (fText, fOriginX, fOriginY + metrics.getAscent ());
}


protected Dimension textExtent () {
    if (! fSizeIsDirty) {
        return new Dimension (fWidth, fHeight);
    }
    FontMetrics metrics = Toolkit.getDefaultToolkit ().getFontMetrics (fFont);
    fWidth = metrics.stringWidth (fText);
    fHeight = metrics.getHeight ();
    fSizeIsDirty = false;
    return new Dimension (metrics.stringWidth (fText), metrics.getHeight ());
}


protected void markDirty () {
    fSizeIsDirty = true;
}


public int overlayColumns () {
    int length = getText ().length ();
    int columns = 20;
    if (length != 0) {
        columns = getText ().length () + 3;
    }
    return columns;
}


public HandleEnumeration handles () {
    List handles = CollectionsFactory.current ().createList ();
    handles.add (new NullHandle (this, RelativeLocator.northWest ()));
    handles.add (new NullHandle (this, RelativeLocator.northEast ()));
    handles.add (new NullHandle (this, RelativeLocator.southEast ()));
    handles.add (new FontSizeHandle (this, RelativeLocator.southWest ()));
    return new HandleEnumerator (handles);
}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeInt (fOriginX);
    dw.writeInt (fOriginY);
    dw.writeString (fText);
    dw.writeString (fFont.getName ());
    dw.writeInt (fFont.getStyle ());
    dw.writeInt (fFont.getSize ());
    dw.writeBoolean (fIsReadOnly);
    dw.writeStorable (getObservedFigure ());
    dw.writeStorable (getLocator ());
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    markDirty ();
    fOriginX = dr.readInt ();
    fOriginY = dr.readInt ();
    fText = dr.readString ();
    fFont = new Font (dr.readString (), dr.readInt (), dr.readInt ());
    fIsReadOnly = dr.readBoolean ();
    setObservedFigure ((Figure) dr.readStorable ());
    if (getObservedFigure () != null) {
        getObservedFigure ().addFigureChangeListener (this);
    }
    setLocator ((OffsetLocator) dr.readStorable ());
}


private void readObject (ObjectInputStream s) throws ClassNotFoundException, IOException {
    s.defaultReadObject ();
    if (getObservedFigure () != null) {
        getObservedFigure ().addFigureChangeListener (this);
    }
    markDirty ();
}


public void connect (Figure figure) {
    if (getObservedFigure () != null) {
        getObservedFigure ().removeFigureChangeListener (this);
    }
    setObservedFigure (figure);
    setLocator (new OffsetLocator (getObservedFigure ().connectedTextLocator (this)));
    getObservedFigure ().addFigureChangeListener (this);
    updateLocation ();
}


public void figureChanged (FigureChangeEvent e) {
    updateLocation ();
}


public void figureRemoved (FigureChangeEvent e) {
    if (listener () != null) {
        Rectangle rect = invalidateRectangle (displayBox ());
        listener ().figureRemoved (new FigureChangeEvent (this, rect, e));
    }
}


public void figureRequestRemove (FigureChangeEvent e) {
}


public void figureInvalidated (FigureChangeEvent e) {
}


public void figureRequestUpdate (FigureChangeEvent e) {
}


protected void updateLocation () {
    if (getLocator () != null) {
        Point p = getLocator ().locate (getObservedFigure ());
        p.x -= size ().width / 2 + fOriginX;
        p.y -= size ().height / 2 + fOriginY;
        if (p.x != 0 || p.y != 0) {
            willChange ();
            basicMoveBy (p.x, p.y);
            changed ();
        }
    }
}


public void release () {
    super.release ();
    disconnect (getObservedFigure ());
}


public void disconnect (Figure disconnectFigure) {
    if (disconnectFigure != null) {
        disconnectFigure.removeFigureChangeListener (this);
    }
    setLocator (null);
    setObservedFigure (null);
}


protected void setObservedFigure (Figure newObservedFigure) {
    fObservedFigure = newObservedFigure;
}


public Figure getObservedFigure () {
    return fObservedFigure;
}


protected void setLocator (OffsetLocator newLocator) {
    fLocator = newLocator;
}


protected OffsetLocator getLocator () {
    return fLocator;
}


public TextHolder getTextHolder () {
    return this;
}


static public Font createCurrentFont () {
    return new Font (fgCurrentFontName, fgCurrentFontStyle, fgCurrentFontSize);
}


static public void setCurrentFontName (String name) {
    fgCurrentFontName = name;
}


static public void setCurrentFontSize (int size) {
    fgCurrentFontSize = size;
}


static public void setCurrentFontStyle (int style) {
    fgCurrentFontStyle = style;
}


protected void basicMoveBy (int dx, int dy) {
    myDisplayBox.translate (dx, dy);
}


public void basicDisplayBox (Point origin, Point corner) {
    myDisplayBox = new Rectangle (origin);
    myDisplayBox.add (corner);
}


public Rectangle displayBox () {
    return myDisplayBox;
}


public void draw (Graphics g) {
}


public HandleEnumeration handles () {
    return HandleEnumerator.getEmptyEnumeration ();
}


public boolean isEmpty () {
    return true;
}


public FigureEnumeration figures () {
    return FigureEnumerator.getEmptyEnumeration ();
}


public Figure findFigureInside (int x, int y) {
    return null;
}


public Object clone () {
    return super.clone ();
}


public boolean includes (Figure figure) {
    return false;
}


public FigureEnumeration decompose () {
    return new SingleFigureEnumerator (this);
}


public void release () {
}


public void invalidate () {
}


public Object getAttribute (String name) {
    return null;
}


public Object getAttribute (FigureAttributeConstant attributeConstant) {
    return null;
}


public void setAttribute (String name, Object value) {
}


public void setAttribute (FigureAttributeConstant attributeConstant, Object value) {
}


public ScribbleTool (DrawingEditor newDrawingEditor) {
    super (newDrawingEditor);
}


public void activate () {
    super.activate ();
}


public void deactivate () {
    super.deactivate ();
    if (fScribble != null) {
        if (fScribble.size ().width 

private void point (int x, int y) {
    if (fScribble == null) {
        fScribble = new PolyLineFigure (x, y);
        setAddedFigure (view ().add (fScribble));
    } else if (fLastX != x || fLastY != y) {
        fScribble.addPoint (x, y);
    }

    fLastX = x;
    fLastY = y;
}


public void mouseDown (MouseEvent e, int x, int y) {
    super.mouseDown (e, x, y);
    if (e.getClickCount () >= 2) {
        setUndoActivity (createUndoActivity ());
        getUndoActivity ().setAffectedFigures (new SingleFigureEnumerator (getAddedFigure ()));
    } else {
        point (e.getX (), e.getY ());
    }
}


public void mouseDrag (MouseEvent e, int x, int y) {
    if (fScribble != null) {
        point (e.getX (), e.getY ());
    }
}


public void mouseUp (MouseEvent e, int x, int y) {
    super.mouseUp (e, x, y);
    if (e.getClickCount () >= 2) {
        editor ().toolDone ();
    }
}


protected Figure getAddedFigure () {
    return myAddedFigure;
}


private void setAddedFigure (Figure newAddedFigure) {
    myAddedFigure = newAddedFigure;
}


protected Undoable createUndoActivity () {
    return new PasteCommand.UndoActivity (view ());
}


public EllipseFigure () {
    this (new Point (0, 0), new Point (0, 0));
}


public EllipseFigure (Point origin, Point corner) {
    basicDisplayBox (origin, corner);
}


public HandleEnumeration handles () {
    List handles = CollectionsFactory.current ().createList ();
    BoxHandleKit.addHandles (this, handles);
    return new HandleEnumerator (handles);
}


public void basicDisplayBox (Point origin, Point corner) {
    fDisplayBox = new Rectangle (origin);
    fDisplayBox.add (corner);
}


public Rectangle displayBox () {
    return new Rectangle (fDisplayBox.x, fDisplayBox.y, fDisplayBox.width, fDisplayBox.height);
}


protected void basicMoveBy (int x, int y) {
    fDisplayBox.translate (x, y);
}


public void drawBackground (Graphics g) {
    Rectangle r = displayBox ();
    g.fillOval (r.x, r.y, r.width - 1, r.height - 1);
}


public void drawFrame (Graphics g) {
    Rectangle r = displayBox ();
    g.drawOval (r.x, r.y, r.width - 1, r.height - 1);
}


public Insets connectionInsets () {
    Rectangle r = fDisplayBox;
    int cx = r.width / 2;
    int cy = r.height / 2;
    return new Insets (cy, cx, cy, cx);
}


public Connector connectorAt (int x, int y) {
    return new ChopEllipseConnector (this);
}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeInt (fDisplayBox.x);
    dw.writeInt (fDisplayBox.y);
    dw.writeInt (fDisplayBox.width);
    dw.writeInt (fDisplayBox.height);
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    fDisplayBox = new Rectangle (dr.readInt (), dr.readInt (), dr.readInt (), dr.readInt ());
}


public FontSizeHandle (Figure owner, Locator l) {
    super (owner, l);
}


public void invokeStart (int x, int y, DrawingView view) {
    setUndoActivity (createUndoActivity (view));
    getUndoActivity ().setAffectedFigures (new SingleFigureEnumerator (owner ()));
}


public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
    TextFigure textOwner = (TextFigure) owner ();
    FontSizeHandle.UndoActivity activity = (FontSizeHandle.UndoActivity) getUndoActivity ();
    int newSize = activity.getFont ().getSize () + y - anchorY;
    textOwner.setFont (new Font (activity.getFont ().getName (), activity.getFont ().getStyle (), newSize));
}


public void invokeEnd (int x, int y, int anchorX, int anchorY, DrawingView view) {
    TextFigure textOwner = (TextFigure) owner ();
    FontSizeHandle.UndoActivity activity = (FontSizeHandle.UndoActivity) getUndoActivity ();
    if (textOwner.getFont ().getSize () == activity.getOldFontSize ()) {
        setUndoActivity (null);
    } else {
        activity.setFont (textOwner.getFont ());
    }
}


public void draw (Graphics g) {
    Rectangle r = displayBox ();
    g.setColor (Color.yellow);
    g.fillOval (r.x, r.y, r.width, r.height);
    g.setColor (Color.black);
    g.drawOval (r.x, r.y, r.width, r.height);
}


protected Undoable createUndoActivity (DrawingView newView) {
    TextFigure textOwner = (TextFigure) owner ();
    return new FontSizeHandle.UndoActivity (newView, textOwner.getFont ());
}


public UndoActivity (DrawingView newView, Font newFont) {
    super (newView);
    setFont (newFont);
    setOldFontSize (getFont ().getSize ());
    setUndoable (true);
    setRedoable (true);
}


public boolean undo () {
    if (! super.undo ()) {
        return false;
    }
    swapFont ();
    return true;
}


public boolean redo () {
    if (! isRedoable ()) {
        return false;
    }
    swapFont ();
    return true;
}


protected void swapFont () {
    setOldFontSize (replaceFontSize ());
    FigureEnumeration fe = getAffectedFigures ();
    while (fe.hasNextFigure ()) {
        ((TextFigure) fe.nextFigure ()).setFont (getFont ());
    }
}


private int replaceFontSize () {
    int tempFontSize = getFont ().getSize ();
    setFont (new Font (getFont ().getName (), getFont ().getStyle (), getOldFontSize ()));
    return tempFontSize;
}


protected void setFont (Font newFont) {
    myFont = newFont;
}


public Font getFont () {
    return myFont;
}


protected void setOldFontSize (int newOldFontSize) {
    myOldFontSize = newOldFontSize;
}


public int getOldFontSize () {
    return myOldFontSize;
}


public RoundRectangleFigure () {
    this (new Point (0, 0), new Point (0, 0));
    fArcWidth = fArcHeight = DEFAULT_ARC;
}


public RoundRectangleFigure (Point origin, Point corner) {
    basicDisplayBox (origin, corner);
    fArcWidth = fArcHeight = DEFAULT_ARC;
}


public void basicDisplayBox (Point origin, Point corner) {
    fDisplayBox = new Rectangle (origin);
    fDisplayBox.add (corner);
}


public void setArc (int width, int height) {
    willChange ();
    fArcWidth = width;
    fArcHeight = height;
    changed ();
}


public Point getArc () {
    return new Point (fArcWidth, fArcHeight);
}


public HandleEnumeration handles () {
    List handles = CollectionsFactory.current ().createList ();
    BoxHandleKit.addHandles (this, handles);
    handles.add (new RadiusHandle (this));
    return new HandleEnumerator (handles);
}


public Rectangle displayBox () {
    return new Rectangle (fDisplayBox.x, fDisplayBox.y, fDisplayBox.width, fDisplayBox.height);
}


protected void basicMoveBy (int x, int y) {
    fDisplayBox.translate (x, y);
}


public void drawBackground (Graphics g) {
    Rectangle r = displayBox ();
    g.fillRoundRect (r.x, r.y, r.width - 1, r.height - 1, fArcWidth, fArcHeight);
}


public void drawFrame (Graphics g) {
    Rectangle r = displayBox ();
    g.drawRoundRect (r.x, r.y, r.width - 1, r.height - 1, fArcWidth, fArcHeight);
}


public Insets connectionInsets () {
    return new Insets (fArcHeight / 2, fArcWidth / 2, fArcHeight / 2, fArcWidth / 2);
}


public Connector connectorAt (int x, int y) {
    return new ShortestDistanceConnector (this);
}


public void write (StorableOutput dw) {
    super.write (dw);
    dw.writeInt (fDisplayBox.x);
    dw.writeInt (fDisplayBox.y);
    dw.writeInt (fDisplayBox.width);
    dw.writeInt (fDisplayBox.height);
    dw.writeInt (fArcWidth);
    dw.writeInt (fArcHeight);
}


public void read (StorableInput dr) throws IOException {
    super.read (dr);
    fDisplayBox = new Rectangle (dr.readInt (), dr.readInt (), dr.readInt (), dr.readInt ());
    fArcWidth = dr.readInt ();
    fArcHeight = dr.readInt ();
}


public FigureAttributes () {
    fMap = CollectionsFactory.current ().createMap ();
}


public Object get (FigureAttributeConstant attributeConstant) {
    return fMap.get (attributeConstant);
}


public void set (FigureAttributeConstant attributeConstant, Object value) {
    if (value != null) {
        fMap.put (attributeConstant, value);
    } else {
        fMap.remove (attributeConstant);
    }
}


public boolean hasDefined (FigureAttributeConstant attributeConstant) {
    return fMap.containsKey (attributeConstant);
}


public Object clone () {
    try {
        FigureAttributes a = (FigureAttributes) super.clone ();
        a.fMap = CollectionsFactory.current ().createMap (fMap);
        return a;
    } catch (CloneNotSupportedException e) {
        throw new InternalError ();
    }
}


public void read (StorableInput dr) throws IOException {
    String s = dr.readString ();
    if (! s.toLowerCase ().equals ("attributes")) {
        throw new IOException ("Attributes expected");
    }
    fMap = CollectionsFactory.current ().createMap ();
    int size = dr.readInt ();
    for (int i = 0;
    i 

public void write (StorableOutput dw) {
    dw.writeString ("attributes");
    dw.writeInt (fMap.size ());
    Iterator iter = fMap.keySet ().iterator ();
    while (iter.hasNext ()) {
        FigureAttributeConstant fac = (FigureAttributeConstant) iter.next ();
        String attributeName = fac.getName ();
        Object attributeValue = fMap.get (fac);
        dw.writeString (attributeName);
        if (attributeValue instanceof String) {
            dw.writeString ("String");
            dw.writeString ((String) attributeValue);
        } else if (attributeValue instanceof Color) {
            writeColor (dw, "Color", (Color) attributeValue);
        } else if (attributeValue instanceof Boolean) {
            dw.writeString ("Boolean");
            if (((Boolean) attributeValue).booleanValue ()) {
                dw.writeString ("TRUE");
            } else {
                dw.writeString ("FALSE");
            }
        } else if (attributeValue instanceof Integer) {
            dw.writeString ("Int");
            dw.writeInt (((Integer) attributeValue).intValue ());
        } else if (attributeValue instanceof Storable) {
            dw.writeString ("Storable");
            dw.writeStorable ((Storable) attributeValue);
        } else if (attributeValue instanceof javax.swing.JPopupMenu) {
            dw.writeString (Figure.POPUP_MENU);
        } else {
            System.err.println ("Unknown attribute: " + attributeValue);
            dw.writeString ("UNKNOWN");
        }

    }
}


public static void writeColor (StorableOutput dw, String colorName, Color color) {
    if (color != null) {
        dw.writeString (colorName);
        dw.writeInt (color.getRed ());
        dw.writeInt (color.getGreen ());
        dw.writeInt (color.getBlue ());
    }
}


public static Color readColor (StorableInput dr) throws IOException {
    return new Color (dr.readInt (), dr.readInt (), dr.readInt ());
}


public ShortestDistanceConnector () {
    super ();
}


public ShortestDistanceConnector (Figure owner) {
    super (owner);
}


public Point findStart (ConnectionFigure connection) {
    return findPoint (connection, true);
}


public Point findEnd (ConnectionFigure connection) {
    return findPoint (connection, false);
}


protected Point findPoint (ConnectionFigure connection, boolean getStart) {
    Figure startFigure = connection.getStartConnector ().owner ();
    Figure endFigure = connection.getEndConnector ().owner ();
    Rectangle r1 = startFigure.displayBox ();
    Rectangle r2 = endFigure.displayBox ();
    Insets i1 = startFigure.connectionInsets ();
    Insets i2 = endFigure.connectionInsets ();
    Point p1, p2;
    Point start = null, end = null, s = null, e = null;
    long len2 = Long.MAX_VALUE, l2;
    int x1, x2, y1, y2;
    int xmin, xmax, ymin, ymax;
    int r1x, r1width, r2x, r2width, r1y, r1height, r2y, r2height;
    r1x = r1.x + i1.left;
    r1width = r1.width - i1.left - i1.right - 1;
    r2x = r2.x + i2.left;
    r2width = r2.width - i2.left - i2.right - 1;
    if (r1x + r1width  r2x + r2width) {
        x1 = r1x;
        x2 = r2x + r2width;
    } else {
        xmax = Math.max (r1x, r2x);
        xmin = Math.min (r1x + r1width, r2x + r2width);
        x1 = x2 = (xmax + xmin) / 2;
    }

    r1y = r1.y + i1.top;
    r1height = r1.height - i1.top - i1.bottom - 1;
    r2y = r2.y + i2.top;
    r2height = r2.height - i2.top - i2.bottom - 1;
    if (r1y + r1height  r2y + r2height) {
        y1 = r1y;
        y2 = r2y + r2height;
    } else {
        ymax = Math.max (r1y, r2y);
        ymin = Math.min (r1y + r1height, r2y + r2height);
        y1 = y2 = (ymax + ymin) / 2;
    }

    for (int i = 0;
    i 

public PolyLineLocator (int index) {
    fIndex = index;
}


public Point locate (Figure owner) {
    PolyLineFigure plf = (PolyLineFigure) owner;
    if (fIndex 

public BorderDecorator () {
}


public BorderDecorator (Figure figure) {
    super (figure);
}


protected void initialize () {
    setBorderOffset (new Point (3, 3));
}


public void setBorderOffset (Point newBorderOffset) {
    myBorderOffset = newBorderOffset;
}


public Point getBorderOffset () {
    if (myBorderOffset == null) {
        return new Point (0, 0);
    } else {
        return myBorderOffset;
    }
}


public void draw (Graphics g) {
    Rectangle r = displayBox ();
    super.draw (g);
    g.setColor (Color.white);
    g.drawLine (r.x, r.y, r.x, r.y + r.height);
    g.drawLine (r.x, r.y, r.x + r.width, r.y);
    g.setColor (Color.gray);
    g.drawLine (r.x + r.width, r.y, r.x + r.width, r.y + r.height);
    g.drawLine (r.x, r.y + r.height, r.x + r.width, r.y + r.height);
}


public Rectangle displayBox () {
    Rectangle r = getDecoratedFigure ().displayBox ();
    r.grow (getBorderOffset ().x, getBorderOffset ().y);
    return r;
}


public void figureInvalidated (FigureChangeEvent e) {
    Rectangle rect = e.getInvalidatedRectangle ();
    rect.grow (getBorderOffset ().x, getBorderOffset ().y);
    super.figureInvalidated (new FigureChangeEvent (this, rect, e));
}


public Insets connectionInsets () {
    Insets i = super.connectionInsets ();
    i.top -= getBorderOffset ().y;
    i.bottom -= getBorderOffset ().y;
    i.left -= getBorderOffset ().x;
    i.right -= getBorderOffset ().x;
    return i;
}

